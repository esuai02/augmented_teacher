#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  runCLI: () => runCLI
});
module.exports = __toCommonJS(index_exports);
var import_chalk6 = __toESM(require("chalk"));
var import_commander = require("commander");
var import_figlet = __toESM(require("figlet"));

// src/commands/add.ts
var import_chalk = __toESM(require("chalk"));

// src/utils/analytics.ts
var import_node_crypto = __toESM(require("crypto"));
var import_node_os = __toESM(require("os"));
var import_posthog_node = require("posthog-node");
var import_uuid = require("uuid");
var isTelemetryDisabled = /* @__PURE__ */ __name(() => {
  return process.env.VOLTAGENT_TELEMETRY_DISABLED === "1" || process.env.VOLTAGENT_TELEMETRY_DISABLED === "true";
}, "isTelemetryDisabled");
var client = new import_posthog_node.PostHog("phc_cLPjGbbZ9BdRtLG3cxoHNch3ZJnQvNhXCHRkeWUI6z5", {
  host: "https://us.i.posthog.com",
  flushAt: 1,
  flushInterval: 0,
  disableGeoip: false
});
var getMachineId = /* @__PURE__ */ __name(() => {
  try {
    const hostname = import_node_os.default.hostname();
    const cpus = import_node_os.default.cpus().length;
    const platform = import_node_os.default.platform();
    const arch = import_node_os.default.arch();
    const dataToHash = `${hostname}-${cpus}-${platform}-${arch}`;
    return import_node_crypto.default.createHash("sha256").update(dataToHash).digest("hex").substring(0, 32);
  } catch {
    return (0, import_uuid.v4)();
  }
}, "getMachineId");
var getOSInfo = /* @__PURE__ */ __name(() => {
  try {
    return {
      os_platform: import_node_os.default.platform(),
      os_release: import_node_os.default.release(),
      os_version: import_node_os.default.version(),
      os_arch: import_node_os.default.arch()
    };
  } catch {
    return {
      os_platform: "unknown",
      os_release: "unknown",
      os_version: "unknown",
      os_arch: "unknown"
    };
  }
}, "getOSInfo");
var captureInitEvent = /* @__PURE__ */ __name((options) => {
  if (isTelemetryDisabled()) return;
  client.capture({
    distinctId: getMachineId(),
    event: "cli_init",
    properties: {
      package_manager: options.packageManager,
      machine_id: getMachineId(),
      ...getOSInfo()
    }
  });
}, "captureInitEvent");
var captureUpdateEvent = /* @__PURE__ */ __name((options) => {
  if (isTelemetryDisabled()) return;
  client.capture({
    distinctId: getMachineId(),
    event: "cli_update_check",
    properties: {
      had_updates: options.hadUpdates,
      machine_id: getMachineId(),
      ...getOSInfo()
    }
  });
}, "captureUpdateEvent");
var captureError = /* @__PURE__ */ __name((options) => {
  if (isTelemetryDisabled()) return;
  client.capture({
    distinctId: getMachineId(),
    event: "cli_error",
    properties: {
      command: options.command,
      error_message: options.errorMessage,
      machine_id: getMachineId(),
      ...getOSInfo()
    }
  });
}, "captureError");
var captureWhoamiEvent = /* @__PURE__ */ __name((options) => {
  if (isTelemetryDisabled()) return;
  client.capture({
    distinctId: getMachineId(),
    event: "cli_whoami",
    properties: {
      num_volt_packages: options.numVoltPackages,
      machine_id: getMachineId(),
      ...getOSInfo()
    }
  });
}, "captureWhoamiEvent");
var analytics_default = client;

// src/commands/add.ts
var registerAddCommand = /* @__PURE__ */ __name((program) => {
  program.command("add <agent-slug>").description("Add a VoltAgent agent from the marketplace to your project.").action(async (agentSlug) => {
    try {
      console.log(
        import_chalk.default.yellow(
          `
\u{1F6A7} The 'add' command is coming soon! This feature will allow you to easily integrate agents like '${agentSlug}' into your project.
`
        )
      );
      console.log(
        import_chalk.default.cyan("\nWant to be among the first to try it out and shape its development?\n")
      );
      console.log(
        import_chalk.default.cyan(
          `Join the discussion on GitHub and become an early user: ${import_chalk.default.underline(
            "https://github.com/orgs/voltagent/discussions/74/"
          )}
`
        )
      );
      console.log(import_chalk.default.gray("\nWe appreciate your interest!\n"));
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(import_chalk.default.red("\nAn unexpected error occurred:"));
      console.error(errorMessage);
      captureError({
        command: "add",
        errorMessage
      });
      process.exit(1);
    }
  });
}, "registerAddCommand");

// src/commands/init.ts
var import_node_child_process = require("child_process");
var import_node_fs = __toESM(require("fs"));
var import_node_path = __toESM(require("path"));
var import_chalk2 = __toESM(require("chalk"));
var registerInitCommand = /* @__PURE__ */ __name((program) => {
  program.command("init").description("Integrate VoltAgent CLI into a project").action(async () => {
    try {
      console.log(import_chalk2.default.cyan("Integrating VoltAgent CLI into your project..."));
      const packageJsonPath = import_node_path.default.join(process.cwd(), "package.json");
      if (!import_node_fs.default.existsSync(packageJsonPath)) {
        console.error(
          import_chalk2.default.red(
            "Error: package.json file not found. This command must be run inside a Node.js project."
          )
        );
        process.exit(1);
      }
      const packageJson = JSON.parse(import_node_fs.default.readFileSync(packageJsonPath, "utf-8"));
      const scripts = packageJson.scripts || {};
      let packageManager = "npm";
      try {
        if (import_node_fs.default.existsSync(import_node_path.default.join(process.cwd(), "pnpm-lock.yaml"))) {
          packageManager = "pnpm";
        } else if (import_node_fs.default.existsSync(import_node_path.default.join(process.cwd(), "yarn.lock"))) {
          packageManager = "yarn";
        }
      } catch {
        packageManager = "npm";
      }
      console.log(import_chalk2.default.blue(`Detected package manager: ${packageManager}`));
      let modified = false;
      if (!scripts.volt || scripts.volt !== "volt") {
        scripts.volt = "volt";
        modified = true;
      }
      if (!modified) {
        console.log(import_chalk2.default.yellow("No changes made. The 'volt' script is already configured."));
      } else {
        packageJson.scripts = scripts;
        import_node_fs.default.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
        console.log(import_chalk2.default.green("\u2713 Added 'volt' script to package.json"));
      }
      let isPackageInstalled = false;
      try {
        import_node_fs.default.accessSync(
          import_node_path.default.join(process.cwd(), "node_modules", "@voltagent", "cli"),
          import_node_fs.default.constants.F_OK
        );
        isPackageInstalled = true;
      } catch {
        isPackageInstalled = false;
      }
      if (!isPackageInstalled) {
        console.log(import_chalk2.default.cyan("Installing @voltagent/cli locally..."));
        try {
          const installCommand = packageManager === "yarn" ? "yarn add @voltagent/cli --dev" : packageManager === "pnpm" ? "pnpm add @voltagent/cli --save-dev" : "npm install @voltagent/cli --save-dev";
          (0, import_node_child_process.execSync)(installCommand, { stdio: "inherit" });
          console.log(import_chalk2.default.green("\u2713 @voltagent/cli successfully installed!"));
        } catch (error) {
          console.error(
            import_chalk2.default.red("Failed to install @voltagent/cli:"),
            error instanceof Error ? error.message : String(error)
          );
        }
      }
      const voltagentDir = import_node_path.default.join(process.cwd(), ".voltagent");
      if (!import_node_fs.default.existsSync(voltagentDir)) {
        import_node_fs.default.mkdirSync(voltagentDir);
      }
      console.log(import_chalk2.default.green("\u2713 VoltAgent CLI successfully integrated!"));
      console.log("\n", import_chalk2.default.cyan("To run VoltAgent:"), import_chalk2.default.green("npm run volt"));
      captureInitEvent({
        packageManager
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(import_chalk2.default.red("Error:"), errorMessage);
      captureError({
        command: "init",
        errorMessage
      });
      process.exit(1);
    }
  });
}, "registerInitCommand");

// src/commands/mcp.ts
var import_node_fs2 = __toESM(require("fs"));
var import_node_path2 = __toESM(require("path"));
var import_chalk3 = __toESM(require("chalk"));
var import_inquirer = __toESM(require("inquirer"));
var import_ora = __toESM(require("ora"));
var isWindows = process.platform === "win32";
function createMCPConfig(ide, projectRoot) {
  if (ide === "none") return;
  const configs = {
    cursor: {
      dir: ".cursor",
      file: "mcp.json",
      content: {
        mcpServers: {
          voltagent: {
            command: "npx",
            args: ["-y", "@voltagent/docs-mcp"]
          }
        }
      }
    },
    windsurf: {
      dir: ".windsurf",
      file: "mcp.json",
      content: {
        mcpServers: {
          voltagent: {
            command: "npx",
            args: ["-y", "@voltagent/docs-mcp"]
          }
        }
      }
    },
    vscode: {
      dir: ".vscode",
      file: "mcp.json",
      content: isWindows ? {
        servers: {
          voltagent: {
            command: "cmd",
            args: ["/c", "npx", "-y", "@voltagent/docs-mcp"],
            type: "stdio"
          }
        }
      } : {
        servers: {
          voltagent: {
            command: "npx",
            args: ["-y", "@voltagent/docs-mcp"],
            type: "stdio"
          }
        }
      }
    }
  };
  const config = configs[ide];
  const configDir = import_node_path2.default.join(projectRoot, config.dir);
  const configFile = import_node_path2.default.join(configDir, config.file);
  if (!import_node_fs2.default.existsSync(configDir)) {
    import_node_fs2.default.mkdirSync(configDir, { recursive: true });
  }
  import_node_fs2.default.writeFileSync(configFile, JSON.stringify(config.content, null, 2));
}
__name(createMCPConfig, "createMCPConfig");
function checkExistingConfig(projectRoot) {
  const possibleConfigs = [
    { ide: "cursor", path: import_node_path2.default.join(projectRoot, ".cursor", "mcp.json") },
    { ide: "windsurf", path: import_node_path2.default.join(projectRoot, ".windsurf", "mcp.json") },
    { ide: "vscode", path: import_node_path2.default.join(projectRoot, ".vscode", "mcp.json") }
  ];
  for (const config of possibleConfigs) {
    if (import_node_fs2.default.existsSync(config.path)) {
      try {
        const content = import_node_fs2.default.readFileSync(config.path, "utf-8");
        const parsed = JSON.parse(content);
        const hasVoltAgentDocs = parsed.mcpServers?.["voltagent-docs"] || parsed.servers?.["voltagent-docs"];
        if (hasVoltAgentDocs) {
          return {
            hasConfig: true,
            configuredIDE: config.ide,
            configPath: config.path
          };
        }
      } catch {
      }
    }
  }
  return { hasConfig: false };
}
__name(checkExistingConfig, "checkExistingConfig");
async function setupMCP(options = {}) {
  const projectRoot = process.cwd();
  console.log(import_chalk3.default.cyan("\u{1F527} VoltAgent MCP Docs Server Setup\n"));
  try {
    const existingConfig = checkExistingConfig(projectRoot);
    if (existingConfig.hasConfig && !options.force) {
      console.log(
        import_chalk3.default.yellow(`\u26A0\uFE0F  MCP already seems to be installed (${existingConfig.configuredIDE})`)
      );
      console.log(import_chalk3.default.gray(`   Location: ${existingConfig.configPath}
`));
      const shouldContinue = await import_inquirer.default.prompt([
        {
          type: "confirm",
          name: "continue",
          message: "Do you want to reinstall the setup?",
          default: false
        }
      ]);
      if (!shouldContinue.continue) {
        console.log(import_chalk3.default.gray("Setup cancelled."));
        return;
      }
    }
    const ideChoice = await import_inquirer.default.prompt([
      {
        type: "list",
        name: "ide",
        message: "Which IDE are you using?",
        choices: [
          { name: "Cursor", value: "cursor" },
          { name: "Windsurf", value: "windsurf" },
          { name: "VS Code", value: "vscode" },
          { name: "None (manual setup)", value: "none" }
        ]
      }
    ]);
    const ide = ideChoice.ide;
    if (ide === "none") {
      console.log(import_chalk3.default.yellow("\n\u{1F4D6} Manual setup selected."));
      console.log(import_chalk3.default.gray("You will need to configure the MCP server manually."));
      console.log(
        import_chalk3.default.blue("For details: https://voltagent.dev/docs/getting-started/mcp-docs-server\n")
      );
      return;
    }
    const spinner = (0, import_ora.default)("Creating MCP configuration...").start();
    try {
      createMCPConfig(ide, projectRoot);
      spinner.succeed(import_chalk3.default.green(`\u2705 MCP configuration created for ${ide}!`));
      console.log(import_chalk3.default.cyan("\n\u{1F4C1} Created files:"));
      const configPath = import_node_path2.default.join(`.${ide}`, "mcp.json");
      console.log(import_chalk3.default.gray(`   ${configPath}`));
      console.log(import_chalk3.default.cyan("\n\u{1F680} Next steps:"));
      console.log(
        import_chalk3.default.white(
          `   1. Restart ${ide === "cursor" ? "Cursor" : ide === "windsurf" ? "Windsurf" : "VS Code"}`
        )
      );
      console.log(import_chalk3.default.white("   2. Ask your AI assistant questions about VoltAgent"));
      console.log(import_chalk3.default.gray('      Example: "How do I create an agent in VoltAgent?"'));
    } catch (error) {
      spinner.fail(import_chalk3.default.red("Failed to create MCP configuration"));
      throw error;
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(import_chalk3.default.red(`
\u274C Error: ${errorMessage}`));
    captureError({
      command: "mcp_setup",
      errorMessage
    });
    process.exit(1);
  }
}
__name(setupMCP, "setupMCP");
async function testMCP() {
  console.log(import_chalk3.default.cyan("\u{1F9EA} Testing VoltAgent MCP Connection\n"));
  const projectRoot = process.cwd();
  const existingConfig = checkExistingConfig(projectRoot);
  if (!existingConfig.hasConfig) {
    console.log(import_chalk3.default.red("\u274C MCP configuration not found."));
    console.log(import_chalk3.default.gray("Please run 'volt mcp setup' first.\n"));
    return;
  }
  console.log(import_chalk3.default.green(`\u2705 MCP configuration found (${existingConfig.configuredIDE})`));
  console.log(import_chalk3.default.gray(`   Location: ${existingConfig.configPath}`));
  console.log(import_chalk3.default.cyan("\n\u{1F4CB} Test suggestions:"));
  console.log(import_chalk3.default.white("   You can ask your AI assistant these questions:"));
  console.log(import_chalk3.default.gray('   \u2022 "How do I create an agent in VoltAgent?"'));
  console.log(import_chalk3.default.gray('   \u2022 "Is there a VoltAgent example with Next.js?"'));
  console.log(import_chalk3.default.gray('   \u2022 "How do I use voice features?"'));
  console.log(import_chalk3.default.gray('   \u2022 "What are the latest updates?"'));
  console.log(import_chalk3.default.cyan("\n\u{1F527} Having issues?"));
  console.log(
    import_chalk3.default.white(
      `   1. Restart ${existingConfig.configuredIDE === "cursor" ? "Cursor" : existingConfig.configuredIDE === "windsurf" ? "Windsurf" : "VS Code"}`
    )
  );
  console.log(import_chalk3.default.white("   2. Check MCP settings"));
  console.log(
    import_chalk3.default.blue("   3. For help: https://voltagent.dev/docs/getting-started/mcp-docs-server")
  );
}
__name(testMCP, "testMCP");
async function statusMCP() {
  console.log(import_chalk3.default.cyan("\u{1F4CA} VoltAgent MCP Status\n"));
  const projectRoot = process.cwd();
  const existingConfig = checkExistingConfig(projectRoot);
  if (!existingConfig.hasConfig) {
    console.log(import_chalk3.default.red("\u274C MCP configuration not found"));
    console.log(import_chalk3.default.gray("MCP appears to not be installed yet.\n"));
    console.log(import_chalk3.default.blue("To install: volt mcp setup"));
    return;
  }
  console.log(import_chalk3.default.green("\u2705 MCP configuration active"));
  console.log(import_chalk3.default.gray(`   IDE: ${existingConfig.configuredIDE}`));
  console.log(import_chalk3.default.gray(`   File: ${existingConfig.configPath}`));
  if (existingConfig.configPath) {
    try {
      const content = import_node_fs2.default.readFileSync(existingConfig.configPath, "utf-8");
      const config = JSON.parse(content);
      console.log(import_chalk3.default.cyan("\n\u{1F4CB} Configuration details:"));
      console.log(import_chalk3.default.gray(JSON.stringify(config, null, 2)));
    } catch {
      console.log(import_chalk3.default.yellow("\u26A0\uFE0F  Configuration file could not be read"));
    }
  }
}
__name(statusMCP, "statusMCP");
async function removeMCP() {
  console.log(import_chalk3.default.cyan("\u{1F5D1}\uFE0F  VoltAgent MCP Removal\n"));
  const projectRoot = process.cwd();
  const existingConfig = checkExistingConfig(projectRoot);
  if (!existingConfig.hasConfig) {
    console.log(import_chalk3.default.yellow("\u26A0\uFE0F  MCP configuration not found"));
    console.log(import_chalk3.default.gray("It may have already been removed.\n"));
    return;
  }
  console.log(import_chalk3.default.yellow(`MCP configuration found (${existingConfig.configuredIDE})`));
  console.log(import_chalk3.default.gray(`Location: ${existingConfig.configPath}`));
  const shouldRemove = await import_inquirer.default.prompt([
    {
      type: "confirm",
      name: "remove",
      message: "Are you sure you want to remove the MCP configuration?",
      default: false
    }
  ]);
  if (!shouldRemove.remove) {
    console.log(import_chalk3.default.gray("Operation cancelled."));
    return;
  }
  if (existingConfig.configPath) {
    try {
      import_node_fs2.default.unlinkSync(existingConfig.configPath);
      console.log(import_chalk3.default.green("\u2705 MCP configuration removed"));
    } catch (error) {
      console.log(import_chalk3.default.red("\u274C Failed to remove MCP configuration"));
      console.error(error);
    }
  }
}
__name(removeMCP, "removeMCP");
function registerMCPCommand(program) {
  const mcpCommand = program.command("mcp").description("VoltAgent MCP Docs Server management");
  mcpCommand.command("setup").description("MCP Docs Server setup").option("-f, --force", "Overwrite existing configuration").action(async (options) => {
    await setupMCP(options);
  });
  mcpCommand.command("test").description("Test MCP connection").action(async () => {
    await testMCP();
  });
  mcpCommand.command("status").description("Show MCP status").action(async () => {
    await statusMCP();
  });
  mcpCommand.command("remove").description("Remove MCP configuration").action(async () => {
    await removeMCP();
  });
  mcpCommand.action(async () => {
    await setupMCP();
  });
}
__name(registerMCPCommand, "registerMCPCommand");

// src/commands/update.ts
var import_node_fs3 = __toESM(require("fs"));
var import_node_path3 = __toESM(require("path"));
var import_chalk4 = __toESM(require("chalk"));
var import_inquirer2 = __toESM(require("inquirer"));
var ncuPackage = __toESM(require("npm-check-updates"));
var import_ora2 = __toESM(require("ora"));
var checkForUpdates = /* @__PURE__ */ __name(async (packagePath, options) => {
  try {
    const rootDir = packagePath ? import_node_path3.default.dirname(packagePath) : process.cwd();
    const packageJsonPath = packagePath || import_node_path3.default.join(rootDir, "package.json");
    if (!import_node_fs3.default.existsSync(packageJsonPath)) {
      return {
        hasUpdates: false,
        updates: {},
        count: 0,
        message: "Could not find package.json"
      };
    }
    const result = await ncuPackage.default({
      packageFile: packageJsonPath,
      silent: true,
      jsonUpgraded: true,
      filter: options?.filter
    });
    const updates = result;
    const count = Object.keys(updates).length;
    if (count > 0) {
      const updatesList = Object.entries(updates).map(([name, version]) => `  - ${name} \u2192 ${version}`).join("\n");
      return {
        hasUpdates: true,
        updates,
        count,
        message: `Found ${count} outdated packages:
${updatesList}`
      };
    }
    return {
      hasUpdates: false,
      updates: {},
      count: 0,
      message: "All packages are up to date"
    };
  } catch (error) {
    console.error("Error checking for updates:", error);
    return {
      hasUpdates: false,
      updates: {},
      count: 0,
      message: `Error checking for updates: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}, "checkForUpdates");
var interactiveUpdate = /* @__PURE__ */ __name(async (updates, packagePath) => {
  const rootDir = packagePath ? import_node_path3.default.dirname(packagePath) : process.cwd();
  const packageJsonPath = packagePath || import_node_path3.default.join(rootDir, "package.json");
  const choices = Object.entries(updates).map(([name, version]) => {
    return {
      name: `${import_chalk4.default.cyan(name)}: ${import_chalk4.default.gray(getCurrentVersion(name, packageJsonPath))} \u2192 ${import_chalk4.default.green(version)}`,
      value: name,
      short: name
    };
  });
  const { selectedPackages } = await import_inquirer2.default.prompt([
    {
      type: "checkbox",
      name: "selectedPackages",
      message: "Select packages to update:",
      choices,
      pageSize: 15,
      default: choices.map((c) => c.value)
      // Default select all
    }
  ]);
  if (selectedPackages.length === 0) {
    console.log(import_chalk4.default.yellow("No packages selected for update."));
    return;
  }
  const selectedFilter = selectedPackages.join(" ");
  console.log(import_chalk4.default.cyan("\nApplying updates for selected packages..."));
  try {
    await ncuPackage.default({
      packageFile: packageJsonPath,
      upgrade: true,
      filter: selectedFilter
    });
    console.log(import_chalk4.default.green(`\u2713 Updated ${selectedPackages.length} packages in package.json`));
    console.log(import_chalk4.default.green("Run 'npm install' to install updated packages"));
  } catch (error) {
    console.error(import_chalk4.default.red("Error applying updates:"));
    console.error(error instanceof Error ? error.message : String(error));
  }
}, "interactiveUpdate");
var getCurrentVersion = /* @__PURE__ */ __name((packageName, packageJsonPath) => {
  try {
    const packageJson = JSON.parse(import_node_fs3.default.readFileSync(packageJsonPath, "utf8"));
    for (const section of [
      "dependencies",
      "devDependencies",
      "peerDependencies",
      "optionalDependencies"
    ]) {
      if (packageJson[section]?.[packageName]) {
        return packageJson[section][packageName];
      }
    }
    return "unknown";
  } catch {
    return "unknown";
  }
}, "getCurrentVersion");
var registerUpdateCommand = /* @__PURE__ */ __name((program) => {
  program.command("update").description("Interactive update for VoltAgent packages").option("--apply", "Apply updates without interactive mode").action(async (options) => {
    try {
      const spinner = (0, import_ora2.default)("Checking for updates...").start();
      const filter = "@voltagent*";
      const updates = await checkForUpdates(void 0, { filter });
      spinner.stop();
      captureUpdateEvent({
        hadUpdates: updates.hasUpdates
      });
      if (!updates.hasUpdates) {
        console.log(import_chalk4.default.green("\u2713 All VoltAgent packages are up to date"));
        return;
      }
      console.log(import_chalk4.default.yellow(`Found ${updates.count} outdated VoltAgent packages:`));
      Object.entries(updates.updates).forEach(([name, version]) => {
        console.log(`  ${import_chalk4.default.cyan(name)}: ${import_chalk4.default.gray("\u2192")} ${import_chalk4.default.green(version)}`);
      });
      if (options.apply) {
        console.log(import_chalk4.default.cyan("\nApplying updates..."));
        try {
          await ncuPackage.default({
            packageFile: import_node_path3.default.join(process.cwd(), "package.json"),
            upgrade: true,
            filter
          });
          console.log(import_chalk4.default.green("\u2713 Updates applied to package.json"));
          console.log(import_chalk4.default.green("Run 'npm install' to install updated packages"));
          return;
        } catch (error) {
          console.error(import_chalk4.default.red("Error applying updates:"));
          console.error(error instanceof Error ? error.message : String(error));
          return;
        }
      }
      console.log();
      console.log(import_chalk4.default.cyan("Starting interactive update..."));
      await interactiveUpdate(updates.updates);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(import_chalk4.default.red("Error checking for updates:"));
      console.error(errorMessage);
      captureError({
        command: "update",
        errorMessage
      });
    }
  });
}, "registerUpdateCommand");

// src/commands/whoami.ts
var import_node_fs4 = __toESM(require("fs"));
var import_node_os2 = __toESM(require("os"));
var import_node_path4 = __toESM(require("path"));
var import_chalk5 = __toESM(require("chalk"));
var registerWhoamiCommand = /* @__PURE__ */ __name((program) => {
  program.command("whoami").description("Display system and user information").action(async () => {
    try {
      console.log(import_chalk5.default.cyan("System and User Information:"));
      console.log(import_chalk5.default.blue(`Username: ${import_node_os2.default.userInfo().username}`));
      console.log(import_chalk5.default.blue(`Hostname: ${import_node_os2.default.hostname()}`));
      console.log(import_chalk5.default.blue(`Platform: ${import_node_os2.default.platform()}`));
      console.log(import_chalk5.default.blue(`OS: ${import_node_os2.default.type()} ${import_node_os2.default.release()}`));
      console.log(import_chalk5.default.blue(`Architecture: ${import_node_os2.default.arch()}`));
      console.log(import_chalk5.default.blue(`Home Directory: ${import_node_os2.default.homedir()}`));
      console.log(import_chalk5.default.cyan("\nInstalled VoltAgent Packages:"));
      let numVoltPackages = 0;
      const packageJsonPath = import_node_path4.default.join(process.cwd(), "package.json");
      if (import_node_fs4.default.existsSync(packageJsonPath)) {
        const packageJson = JSON.parse(import_node_fs4.default.readFileSync(packageJsonPath, "utf-8"));
        const dependencies = {
          ...packageJson.dependencies,
          ...packageJson.devDependencies
        };
        const voltagentPackages = Object.entries(dependencies || {}).filter(([name]) => name.includes("voltagent")).map(([name, version]) => ({ name, version }));
        numVoltPackages = voltagentPackages.length;
        if (voltagentPackages.length > 0) {
          voltagentPackages.forEach((pkg) => {
            console.log(import_chalk5.default.blue(`${pkg.name}: ${pkg.version}`));
          });
        } else {
          console.log(import_chalk5.default.yellow("No VoltAgent packages found in package.json"));
        }
      } else {
        console.log(import_chalk5.default.yellow("No package.json found in current directory"));
      }
      captureWhoamiEvent({
        numVoltPackages
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(import_chalk5.default.red("Error:"), errorMessage);
      captureError({
        command: "whoami",
        errorMessage
      });
      process.exit(1);
    }
  });
}, "registerWhoamiCommand");

// src/index.ts
var createCLI = /* @__PURE__ */ __name(() => {
  const program = new import_commander.Command();
  program.name("voltagent").description("VoltAgent CLI - CLI tool for update checks").version("0.1.0");
  registerInitCommand(program);
  registerUpdateCommand(program);
  registerWhoamiCommand(program);
  registerAddCommand(program);
  registerMCPCommand(program);
  return program;
}, "createCLI");
var runCLI = /* @__PURE__ */ __name(async () => {
  try {
    console.log(
      import_chalk6.default.cyan(
        import_figlet.default.textSync("VoltAgent CLI", {
          font: "Standard",
          horizontalLayout: "default",
          verticalLayout: "default"
        })
      )
    );
    const program = createCLI();
    await program.parseAsync(process.argv);
    await analytics_default.shutdown();
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(import_chalk6.default.red("An unexpected error occurred:"));
    console.error(errorMessage);
    captureError({
      command: "unknown",
      errorMessage
    });
    await analytics_default.shutdown();
    process.exit(1);
  }
}, "runCLI");
runCLI().catch((error) => {
  const errorMessage = error instanceof Error ? error.message : String(error);
  console.error(`Error: ${errorMessage}`);
  captureError({
    command: "cli_runner",
    errorMessage
  });
  analytics_default.shutdown().then(() => {
    process.exit(1);
  });
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  runCLI
});
//# sourceMappingURL=index.js.map