{"version":3,"sources":["../src/index.ts","../../internal/src/utils/lang.ts","../../internal/src/utils/objects.ts","../../internal/src/utils/async-iterable-stream.ts","../../internal/src/utils/safe-stringify.ts","../src/provider.ts","../src/utils.ts"],"sourcesContent":["export { VercelAIProvider } from \"./provider\";\n","import type { EmptyObject } from \"type-fest\";\nimport type { AnyFunction, Nil, PlainObject } from \"../types\";\n\n/**\n * Check if a value is nil\n *\n * @param obj - The value to check\n * @returns True if the value is nil, false otherwise\n */\nexport function isNil(obj: unknown): obj is Nil {\n  return obj === null || obj === undefined;\n}\n\n/**\n * Check if an object is a JS object\n *\n * @param obj - The object to check\n * @returns True if the object is a JS object}\n */\nexport function isObject<T extends object>(obj: unknown): obj is T {\n  return (typeof obj === \"object\" || typeof obj === \"function\") && !isNil(obj);\n}\n\n/**\n * Check if a value is a function\n *\n * @param obj - The value to check\n * @returns True if the value is a function, false otherwise\n */\nexport function isFunction<T extends AnyFunction>(obj: unknown): obj is T {\n  return typeof obj === \"function\";\n}\n\n/**\n * Check if an object is a plain object (i.e. a JS object but not including arrays or functions)\n *\n * @param obj - The object to check\n * @returns True if the object is a plain object, false otherwise.\n */\nexport function isPlainObject<T extends PlainObject>(obj: unknown): obj is T {\n  if (!isObject(obj)) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(obj);\n  return prototype === Object.prototype || prototype === null;\n}\n\n/**\n * Check if an object is an empty object\n *\n * @param obj - The object to check\n * @returns True if the object is an empty object, false otherwise\n */\nexport function isEmptyObject(obj: unknown): obj is EmptyObject {\n  if (!isObject(obj)) {\n    return false;\n  }\n\n  // Check for own string and symbol properties (enumerable or not)\n  if (Object.getOwnPropertyNames(obj).length > 0 || Object.getOwnPropertySymbols(obj).length > 0) {\n    return false;\n  }\n\n  return true;\n}\n","import type { SetRequired } from \"type-fest\";\nimport type { PlainObject } from \"../types\";\nimport { isObject } from \"./lang\";\n\n/**\n * Deep clone an object\n *\n * @param obj - The object to clone\n * @returns A deep copy of the object (fallback to shallow clone for failures)\n */\nexport function deepClone<T>(obj: T): T {\n  try {\n    // Use structuredClone if available (Node.js 17+, modern browsers)\n    if (typeof structuredClone === \"function\") {\n      return structuredClone(obj);\n    }\n\n    throw new Error(\"structuredClone is not available\");\n  } catch (_error) {\n    // Fallback to shallow clone for primitive types and simple objects\n    if (obj === null || typeof obj !== \"object\") {\n      return obj;\n    }\n    return { ...obj } as T;\n  }\n}\n\n/**\n * Check if an object has a key\n *\n * @param obj - The object to check\n * @param key - The key to check\n * @returns True if the object has the key, false otherwise\n */\nexport function hasKey<T extends PlainObject, K extends string>(\n  obj: T,\n  key: K,\n): obj is T & SetRequired<T, K> {\n  return isObject(obj) && key in obj;\n}\n","import type { Merge } from \"type-fest\";\n\n/**\n * An async iterable stream that can be read from.\n * @example\n * ```typescript\n * const stream: AsyncIterableStream<string> = getStream();\n * for await (const chunk of stream) {\n *   console.log(chunk);\n * }\n * ```\n */\nexport type AsyncIterableStream<T> = Merge<AsyncIterable<T>, ReadableStream<T>>;\n\n/**\n * Create an async iterable stream from a readable stream.\n *\n * This is useful for creating an async iterable stream from a readable stream.\n *\n * @example\n * ```typescript\n * const stream: AsyncIterableStream<string> = createAsyncIterableStream(new ReadableStream({\n *   start(controller) {\n *     controller.enqueue(\"Hello\");\n *     controller.close();\n *   },\n * }));\n * ```\n * @param source The readable stream to create an async iterable stream from.\n * @returns The async iterable stream.\n */\nexport function createAsyncIterableStream<T>(source: ReadableStream<T>): AsyncIterableStream<T> {\n  const stream = source.pipeThrough(new TransformStream<T, T>());\n\n  (stream as AsyncIterableStream<T>)[Symbol.asyncIterator] = () => {\n    const reader = stream.getReader();\n    return {\n      async next(): Promise<IteratorResult<T>> {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: undefined } : { done: false, value };\n      },\n    };\n  };\n\n  return stream as AsyncIterableStream<T>;\n}\n","import type { DangerouslyAllowAny } from \"../types\";\n\nexport type SafeStringifyOptions = {\n  /**\n   * The indentation to use for the output.\n   */\n  indentation?: string | number;\n};\n\n/**\n * Stringifies an object, handling circular references and ensuring the output is safe to use in a JSON string.\n * @param input - The object to stringify.\n * @param options.indentation - The indentation to use for the output.\n * @returns The stringified object.\n */\nexport function safeStringify(\n  input: DangerouslyAllowAny,\n  { indentation }: SafeStringifyOptions = {},\n) {\n  try {\n    const seen = new WeakSet();\n    return JSON.stringify(input, safeStringifyReplacer(seen), indentation);\n  } catch (error) {\n    return `SAFE_STRINGIFY_ERROR: Error stringifying object: ${error instanceof Error ? error.message : \"Unknown error\"}`;\n  }\n}\n\nfunction safeStringifyReplacer(seen: WeakSet<DangerouslyAllowAny>) {\n  const replacer = (_key: string, value: DangerouslyAllowAny) => {\n    // Handle objects with a custom `.toJSON()` method.\n    if (typeof value?.toJSON === \"function\") {\n      // biome-ignore lint/style/noParameterAssign: needed to handle circular references\n      value = value.toJSON();\n    }\n\n    if (!(value !== null && typeof value === \"object\")) {\n      return value;\n    }\n\n    if (seen.has(value)) {\n      return \"[Circular]\";\n    }\n\n    seen.add(value);\n\n    const newValue = Array.isArray(value) ? [] : {};\n\n    for (const [key2, value2] of Object.entries(value)) {\n      // @ts-expect-error - ignore as this is needed to handle circular references\n      newValue[key2] = replacer(key2, value2);\n    }\n\n    seen.delete(value);\n\n    return newValue;\n  };\n\n  return replacer;\n}\n","import type {\n  BaseMessage,\n  GenerateObjectOptions,\n  GenerateTextOptions,\n  LLMProvider,\n  ProviderObjectResponse,\n  ProviderObjectStreamResponse,\n  ProviderTextResponse,\n  ProviderTextStreamResponse,\n  StreamObjectFinishResult,\n  StreamObjectOptions,\n  StreamTextOptions,\n  UsageInfo,\n} from \"@voltagent/core\";\nimport { safeStringify } from \"@voltagent/internal/utils\";\nimport type {\n  CallWarning,\n  FinishReason,\n  GenerateObjectResult,\n  GenerateTextResult,\n  LanguageModelRequestMetadata,\n  LanguageModelResponseMetadata,\n  LanguageModelUsage,\n  ModelMessage,\n  ProviderMetadata,\n  StepResult,\n  StreamObjectOnFinishCallback,\n  StreamObjectResult,\n  StreamTextResult,\n} from \"ai\";\nimport { generateObject, generateText, stepCountIs, streamObject, streamText } from \"ai\";\nimport { P, match } from \"ts-pattern\";\nimport type { SetRequired } from \"type-fest\";\nimport type { z } from \"zod\";\nimport {\n  convertToolsForSDK,\n  createMappedFullStream,\n  createStepFromChunk,\n  createVoltagentErrorFromSdkError,\n} from \"./utils\";\n\n// Type definitions for AI SDK v5\ntype AIGenerateTextParams = Parameters<typeof generateText>[0];\ntype AIModel = AIGenerateTextParams[\"model\"];\n\nexport class VercelAIProvider implements LLMProvider<AIModel> {\n  /**\n   * Provider `generateText` implementation\n   * @param options - The options for the generate text operation\n   * @returns A standardized response for VoltAgent\n   */\n  public async generateText(\n    options: GenerateTextOptions<AIModel>,\n  ): Promise<ProviderTextResponse<GenerateTextResult<Record<string, any>, never>>> {\n    const vercelMessages = options.messages.map(this.toMessage);\n    const vercelTools = options.tools ? convertToolsForSDK(options.tools) : undefined;\n\n    // Process onStepFinish if provided\n    const onStepFinish = options.onStepFinish\n      ? async (result: StepResult<Record<string, any>>) => {\n          if (options.onStepFinish) {\n            // Handle text response\n            if (result.text) {\n              const step = createStepFromChunk({\n                type: \"text\",\n                text: result.text,\n                usage: result.usage,\n              });\n              if (step) await options.onStepFinish(step);\n            }\n\n            // Handle all tool calls - each as a separate step\n            if (result.toolCalls && result.toolCalls.length > 0) {\n              for (const toolCall of result.toolCalls) {\n                const step = createStepFromChunk({\n                  type: \"tool-call\",\n                  toolCallId: toolCall.toolCallId,\n                  toolName: toolCall.toolName,\n                  input: toolCall.input,\n                  usage: result.usage,\n                });\n                if (step) await options.onStepFinish(step);\n              }\n            }\n\n            // Handle all tool results - each as a separate step\n            if (result.toolResults && result.toolResults.length > 0) {\n              for (const toolResult of result.toolResults) {\n                const step = createStepFromChunk({\n                  type: \"tool-result\",\n                  toolCallId: toolResult.toolCallId,\n                  toolName: toolResult.toolName,\n                  output: toolResult.output,\n                  usage: result.usage,\n                });\n                if (step) await options.onStepFinish(step);\n              }\n            }\n          }\n        }\n      : undefined;\n\n    try {\n      const result = await generateText({\n        ...options.provider,\n        messages: vercelMessages,\n        model: options.model,\n        tools: vercelTools,\n        ...match(options.maxSteps)\n          .with(P.number, (maxSteps) => ({ stopWhen: stepCountIs(maxSteps) }))\n          .otherwise(() => ({})),\n        ...match(options.provider?.maxTokens)\n          .with(P.number, (maxTokens) => ({ maxOutputTokens: maxTokens }))\n          .otherwise(() => ({})),\n        abortSignal: options.signal,\n        onStepFinish,\n      });\n\n      // Return standardized response\n      return {\n        provider: result,\n        text: result.text || \"\",\n        usage: getUsageInfo(result.usage),\n        toolCalls: result.toolCalls,\n        toolResults: result.toolResults,\n        finishReason: result.finishReason,\n        reasoning: Array.isArray(result.reasoning)\n          ? result.reasoning.map((r) => r.text || \"\").join(\"\\n\")\n          : result.reasoning,\n        warnings: result.warnings,\n      };\n    } catch (sdkError) {\n      const voltagentErr = createVoltagentErrorFromSdkError(sdkError, \"llm_generate\");\n      throw voltagentErr;\n    }\n  }\n\n  /**\n   * Provider `streamText` implementation\n   * @param options - The options for the stream text operation\n   * @returns A standardized response for VoltAgent\n   */\n  public async streamText(\n    options: StreamTextOptions<AIModel>,\n  ): Promise<\n    SetRequired<\n      ProviderTextStreamResponse<StreamTextResult<Record<string, any>, never>>,\n      \"fullStream\"\n    >\n  > {\n    try {\n      const vercelMessages = options.messages.map(this.toMessage);\n      const vercelTools = options.tools ? convertToolsForSDK(options.tools) : undefined;\n\n      // Process onStepFinish if provided\n      const onStepFinish = options.onStepFinish\n        ? async (result: StepResult<Record<string, any>>) => {\n            if (options.onStepFinish) {\n              // Handle text response\n              if (result.text) {\n                const step = createStepFromChunk({\n                  type: \"text\",\n                  text: result.text,\n                  usage: result.usage,\n                });\n                if (step) await options.onStepFinish(step);\n              }\n\n              // Handle all tool calls - each as a separate step\n              if (result.toolCalls && result.toolCalls.length > 0) {\n                for (const toolCall of result.toolCalls) {\n                  const step = createStepFromChunk({\n                    type: \"tool-call\",\n                    toolCallId: toolCall.toolCallId,\n                    toolName: toolCall.toolName,\n                    input: toolCall.input,\n                    usage: result.usage,\n                  });\n                  if (step) await options.onStepFinish(step);\n                }\n              }\n\n              // Handle all tool results - each as a separate step\n              if (result.toolResults && result.toolResults.length > 0) {\n                for (const toolResult of result.toolResults) {\n                  const step = createStepFromChunk({\n                    type: \"tool-result\",\n                    toolCallId: toolResult.toolCallId,\n                    toolName: toolResult.toolName,\n                    output: toolResult.output,\n                    usage: result.usage,\n                  });\n                  if (step) await options.onStepFinish(step);\n                }\n              }\n            }\n          }\n        : undefined;\n\n      const result = streamText({\n        ...options.provider,\n        messages: vercelMessages,\n        model: options.model,\n        tools: vercelTools,\n        ...match(options.maxSteps)\n          .with(P.number, (maxSteps) => ({ stopWhen: stepCountIs(maxSteps) }))\n          .otherwise(() => ({})),\n        ...match(options.provider?.maxTokens)\n          .with(P.number, (maxTokens) => ({ maxOutputTokens: maxTokens }))\n          .otherwise(() => ({})),\n        abortSignal: options.signal,\n        onStepFinish,\n        onChunk: async ({ chunk }) => {\n          if (options?.onChunk) {\n            // Handle the chunk directly without usage tracking\n            const step = createStepFromChunk(chunk);\n            if (step) await options.onChunk(step);\n          }\n        },\n        onFinish: options.onFinish\n          ? async (\n              result: Omit<StepResult<Record<string, any>>, \"stepType\" | \"isContinued\"> & {\n                readonly steps: StepResult<Record<string, any>>[];\n              },\n            ) => {\n              options.onFinish?.({\n                text: result.text,\n                usage: getUsageInfo(result.usage),\n                finishReason: result.finishReason,\n                warnings: result.warnings,\n                providerResponse: result,\n              });\n            }\n          : undefined,\n        onError: (sdkError) => {\n          // Create the error using the helper\n          const voltagentErr = createVoltagentErrorFromSdkError(sdkError, \"llm_stream\");\n          // Call the agent's onError callback if it exists\n          if (options.onError) {\n            options.onError(voltagentErr);\n          }\n        },\n      });\n\n      // Return provider, textStream, fullStream, and Promise properties\n      return {\n        provider: result,\n        textStream: result.textStream as any,\n        fullStream: createMappedFullStream(result.fullStream),\n        text: result.text,\n        finishReason: result.finishReason,\n        usage: result.usage as any, // fix me\n        reasoning: result.reasoning.then\n          ? result.reasoning.then((r) =>\n              Array.isArray(r) ? r.map((p) => p.text || \"\").join(\"\\n\") : undefined,\n            )\n          : Promise.resolve(undefined),\n      };\n    } catch (error) {\n      throw createVoltagentErrorFromSdkError(error, \"llm_stream\");\n    }\n  }\n\n  /**\n   * Provider `generateObject` implementation.\n   * @param options - The options for the generate object operation\n   * @returns A standardized response for VoltAgent\n   */\n  public async generateObject<TSchema extends z.ZodType>(\n    options: GenerateObjectOptions<AIModel, TSchema>,\n  ): Promise<ProviderObjectResponse<GenerateObjectResult<z.infer<TSchema>>, z.infer<TSchema>>> {\n    const vercelMessages = options.messages.map(this.toMessage);\n\n    // For object generation, we use onFinish as onStepFinish is not supported\n    const onFinish = match(options)\n      .with({ onStepFinish: P.not(P.nullish) }, (o) => {\n        return async (result: {\n          object: z.infer<TSchema>;\n          finishReason: FinishReason;\n          usage: LanguageModelUsage;\n          warnings: CallWarning[] | undefined;\n          request: LanguageModelRequestMetadata;\n          response: LanguageModelResponseMetadata;\n          logprobs: any | undefined;\n          providerMetadata: ProviderMetadata | undefined;\n        }) => {\n          const step = createStepFromChunk({\n            type: \"text\",\n            text: match(result.object)\n              .with(P.string, (s) => s)\n              .otherwise((o) => safeStringify(o)),\n            usage: result.usage,\n          });\n\n          if (step) {\n            await o.onStepFinish(step);\n          }\n        };\n      })\n      .otherwise(() => undefined);\n\n    try {\n      const result = await generateObject({\n        ...options.provider,\n        messages: vercelMessages,\n        model: options.model,\n        schema: options.schema as any,\n        ...match(options.provider?.maxTokens)\n          .with(P.number, (maxTokens) => ({ maxOutputTokens: maxTokens }))\n          .otherwise(() => ({})),\n        abortSignal: options.signal,\n      });\n\n      // Call the custom onFinish handler if defined\n      await onFinish?.({ ...result, logprobs: undefined });\n\n      // Return standardized response\n      return {\n        provider: result,\n        object: result.object as z.infer<TSchema>,\n        usage: getUsageInfo(result.usage),\n        finishReason: result.finishReason,\n        warnings: result.warnings,\n      };\n    } catch (sdkError) {\n      const voltagentErr = createVoltagentErrorFromSdkError(sdkError, \"object_generate\");\n      throw voltagentErr;\n    }\n  }\n\n  /**\n   * Provider `streamObject` implementation\n   * @param options - The options for the stream object operation\n   * @returns The streamed object\n   */\n  public async streamObject<TSchema extends z.ZodType>(\n    options: StreamObjectOptions<AIModel, TSchema>,\n  ): Promise<\n    ProviderObjectStreamResponse<\n      StreamObjectResult<z.infer<TSchema>, unknown, never>,\n      z.infer<TSchema>\n    >\n  > {\n    const vercelMessages = options.messages.map(this.toMessage);\n    const onFinish = match(options)\n      .returnType<StreamObjectOnFinishCallback<z.infer<TSchema>> | null>()\n      .with({ onStepFinish: P.not(P.nullish) }, (o) => {\n        return async (event) => {\n          const jsonResult = event.object ? safeStringify(event.object) : \"\";\n          const step = createStepFromChunk({\n            type: \"text\", // Simulate as a text step containing the final JSON\n            text: jsonResult,\n            usage: event.usage,\n          });\n          if (step) {\n            await o.onStepFinish(step);\n          }\n        };\n      })\n      .with({ onFinish: P.not(P.nullish) }, (o) => {\n        return async (event) => {\n          const finishResult: StreamObjectFinishResult<z.infer<TSchema>> = {\n            object: event.object,\n            usage: getUsageInfo(event.usage), // Mapped usage info\n            warnings: event.warnings,\n            providerResponse: event, // Include the original SDK event object\n            // finishReason is not typically available in Vercel's streamObject finish event\n          };\n          await o.onFinish(finishResult);\n        };\n      })\n      .otherwise(() => null);\n\n    const result = streamObject({\n      ...options.provider,\n      messages: vercelMessages,\n      model: options.model,\n      schema: options.schema as any,\n      abortSignal: options.signal,\n      ...match(options.provider?.maxTokens)\n        .with(P.number, (maxTokens) => ({ maxOutputTokens: maxTokens }))\n        .otherwise(() => ({})),\n      ...match(onFinish)\n        .with(P.not(P.nullish), (handler) => ({ onFinish: handler }))\n        .otherwise(() => ({})),\n      onError: (sdkError) => {\n        // Create the error using the helper\n        const voltagentErr = createVoltagentErrorFromSdkError(sdkError, \"object_stream\");\n        // Call the agent's onError callback if it exists\n        if (options.onError) {\n          options.onError(voltagentErr);\n        }\n      },\n    });\n\n    // TODO: Add usage to the result - https://sdk.vercel.ai/docs/reference/ai-sdk-core/stream-object\n    const partialObjectStream = result.partialObjectStream;\n    // Return provider, objectStream, and Promise properties\n    return {\n      provider: { ...result, partialObjectStream } as any,\n      objectStream: partialObjectStream as any,\n      object: result.object as Promise<z.infer<TSchema>>,\n      usage: result.usage.then(\n        (u) => getUsageInfo(u) || { promptTokens: 0, completionTokens: 0, totalTokens: 0 },\n      ),\n      warnings: result.warnings,\n    };\n  }\n\n  /**\n   * Get the model identifier\n   * @param model - The model to get the identifier for\n   * @returns The model identifier\n   */\n  public getModelIdentifier(model: AIModel): string {\n    return typeof model === \"string\" ? model : model.modelId;\n  }\n\n  /**\n   * Convert a VoltAgent message to a Vercel AI message\n   * @param message - The VoltAgent message to convert\n   * @returns The Vercel AI message\n   */\n  public toMessage(message: BaseMessage): ModelMessage {\n    return message as ModelMessage;\n  }\n}\n\nfunction getUsageInfo(usage?: LanguageModelUsage): UsageInfo | undefined {\n  return match(usage)\n    .with({ inputTokens: P.number, outputTokens: P.number, totalTokens: P.number }, (u) => ({\n      promptTokens: u.inputTokens,\n      completionTokens: u.outputTokens,\n      totalTokens: u.totalTokens,\n      cachedInputTokens: u.cachedInputTokens,\n      reasoningTokens: u.reasoningTokens,\n    }))\n    .otherwise(() => undefined);\n}\n","import type {\n  BaseTool,\n  MessageRole,\n  StepWithContent,\n  StreamPart,\n  ToolErrorInfo,\n  VoltAgentError,\n} from \"@voltagent/core\";\nimport { safeStringify } from \"@voltagent/internal/utils\";\nimport { type Tool as AiTool, type TextStreamPart, tool as createTool, generateId } from \"ai\";\nimport { P, match } from \"ts-pattern\";\n\n/**\n * Convert VoltAgent tools to Vercel AI SDK format\n * @param tools Array of agent tools\n * @returns Object mapping tool names to their SDK implementations or undefined if no tools\n */\nexport function convertToolsForSDK(tools: BaseTool[]): Record<string, AiTool> | undefined {\n  if (!tools || tools.length === 0) {\n    return undefined;\n  }\n  return tools.reduce<Record<string, AiTool>>((acc, tool) => {\n    acc[tool.name] = createTool({\n      description: tool.description,\n      inputSchema: tool.parameters,\n      outputSchema: tool.outputSchema,\n      execute: tool.execute,\n    });\n    return acc;\n  }, {});\n}\n\n/**\n * Create a step from a chunk\n * @param chunk - The chunk to create a step from\n * @returns The step or null if the chunk is not supported\n */\nexport function createStepFromChunk(chunk: {\n  type: string;\n  [key: string]: any;\n}): StepWithContent | null {\n  return match(chunk)\n    .returnType<StepWithContent | null>()\n    .when(\n      (c) => c.type === \"text\" && c.text,\n      (c) => ({\n        id: generateId(),\n        type: \"text\",\n        content: c.text,\n        role: \"assistant\" as MessageRole,\n        usage: c.usage || undefined,\n      }),\n    )\n    .with({ type: P.union(\"tool-call\", \"tool_call\") }, (c) => ({\n      id: c.toolCallId,\n      type: \"tool_call\",\n      name: c.toolName,\n      arguments: c.input,\n      content: safeStringify([\n        {\n          type: \"tool-call\",\n          toolCallId: c.toolCallId,\n          toolName: c.toolName,\n          args: c.input,\n        },\n      ]),\n      role: \"assistant\" as MessageRole,\n      usage: c.usage || undefined,\n    }))\n    .with({ type: P.union(\"tool-result\", \"tool_result\") }, (c) => ({\n      id: c.toolCallId,\n      type: \"tool_result\",\n      name: c.toolName,\n      result: c.output,\n      content: safeStringify([\n        {\n          type: \"tool-result\",\n          toolCallId: c.toolCallId,\n          toolName: c.toolName,\n          result: c.output,\n        },\n      ]),\n      role: \"assistant\" as MessageRole,\n      usage: c.usage || undefined,\n    }))\n    .otherwise(() => null);\n}\n\nexport interface AISDKError extends Error {\n  toolCallId?: string;\n  toolName?: string;\n  input?: Record<string, any>;\n  code?: string;\n}\n\n/**\n * Creates a standardized VoltAgentError from a raw Vercel SDK error object.\n */\nexport function createVoltagentErrorFromSdkError(\n  sdkError: unknown,\n  errorStage:\n    | \"llm_stream\"\n    | \"object_stream\"\n    | \"llm_generate\"\n    | \"object_generate\"\n    | \"tool_execution\" = \"llm_stream\",\n): VoltAgentError {\n  const originalError = match(sdkError)\n    .returnType<AISDKError>()\n    .with({ error: P.not(P.nullish) }, (e) => e.error as AISDKError)\n    .with(P.instanceOf(Error), (e) => e)\n    .otherwise(\n      () =>\n        new Error(`An unknown error occurred during Vercel AI operation (stage: ${errorStage})`),\n    );\n\n  return match(originalError)\n    .returnType<VoltAgentError>()\n    .with({ toolCallId: P.not(P.nullish), toolName: P.not(P.nullish) }, (e) => ({\n      message: `Error during Vercel SDK operation (tool '${e.toolName}'): ${e instanceof Error ? originalError.message : \"Unknown tool error\"}`,\n      originalError: e,\n      toolError: {\n        toolCallId: e.toolCallId,\n        toolName: e.toolName,\n        toolArguments: e.input,\n        toolExecutionError: e,\n      } satisfies ToolErrorInfo,\n      stage: \"tool_execution\",\n      code: e.code,\n    }))\n    .otherwise((e) => ({\n      message: e.message,\n      originalError: e,\n      toolError: undefined,\n      stage: errorStage,\n      code: e.code,\n    }));\n}\n\n/**\n * Map Vercel AI TextStreamPart to our standard StreamPart\n * @param part - The part to map\n * @returns The mapped part or null if the part is not supported\n */\nexport function mapToStreamPart(part: TextStreamPart<Record<string, any>>): StreamPart | null {\n  return match(part)\n    .returnType<StreamPart | null>()\n    .with({ type: \"text-delta\" }, (p) => ({\n      type: \"text-delta\",\n      textDelta: p.text,\n    }))\n    .with({ type: \"reasoning-delta\" }, (p) => ({\n      type: \"reasoning\",\n      reasoning: p.text,\n    }))\n    .with({ type: \"source\", sourceType: \"url\" }, (p) => ({\n      type: \"source\",\n      source: p.url || \"\",\n    }))\n    .with({ type: \"tool-call\" }, (p) => ({\n      type: \"tool-call\",\n      toolCallId: p.toolCallId,\n      toolName: p.toolName,\n      args: p.input as Record<string, any>,\n    }))\n    .with({ type: \"tool-result\" }, (p) => ({\n      type: \"tool-result\",\n      toolCallId: p.toolCallId,\n      toolName: p.toolName,\n      result: p.output,\n    }))\n    .with({ type: \"finish\" }, (p) => ({\n      type: \"finish\",\n      finishReason: p.finishReason,\n      usage: match(p)\n        .with(\n          {\n            totalUsage: {\n              inputTokens: P.number,\n              outputTokens: P.number,\n              totalTokens: P.number,\n              cachedInputTokens: P.optional(P.number),\n              reasoningTokens: P.optional(P.number),\n            },\n          },\n          (p) => ({\n            promptTokens: p.totalUsage.inputTokens,\n            completionTokens: p.totalUsage.outputTokens,\n            totalTokens: p.totalUsage.totalTokens,\n            cachedInputTokens: p.totalUsage.cachedInputTokens,\n            reasoningTokens: p.totalUsage.reasoningTokens,\n          }),\n        )\n        .otherwise(() => undefined),\n    }))\n    .with({ type: \"error\" }, (p) => ({\n      type: \"error\",\n      error: p.error as Error,\n    }))\n    .otherwise(() => null);\n}\n\n/**\n * Create mapped fullStream that converts Vercel AI parts to our standard parts\n * @param originalStream - The original stream of parts from the Vercel AI SDK\n * @returns A new stream of parts that are converted to our standard parts\n */\nexport function createMappedFullStream(\n  originalStream: AsyncIterable<TextStreamPart<Record<string, any>>>,\n): AsyncIterable<StreamPart> {\n  return {\n    async *[Symbol.asyncIterator]() {\n      for await (const part of originalStream) {\n        const mappedPart = mapToStreamPart(part);\n        if (mappedPart !== null) {\n          yield mappedPart;\n        }\n      }\n    },\n  };\n}\n"],"mappings":"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","names":["__name","import_ai","import_ts_pattern","createTool","p","result","o"]}