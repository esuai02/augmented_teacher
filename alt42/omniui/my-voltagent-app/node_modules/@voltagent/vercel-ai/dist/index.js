"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  VercelAIProvider: () => VercelAIProvider
});
module.exports = __toCommonJS(index_exports);

// ../internal/dist/utils/index.mjs
var __defProp2 = Object.defineProperty;
var __name2 = /* @__PURE__ */ __name((target, value) => __defProp2(target, "name", { value, configurable: true }), "__name");
function isNil(obj) {
  return obj === null || obj === void 0;
}
__name(isNil, "isNil");
__name2(isNil, "isNil");
function isObject(obj) {
  return (typeof obj === "object" || typeof obj === "function") && !isNil(obj);
}
__name(isObject, "isObject");
__name2(isObject, "isObject");
function isFunction(obj) {
  return typeof obj === "function";
}
__name(isFunction, "isFunction");
__name2(isFunction, "isFunction");
function isPlainObject(obj) {
  if (!isObject(obj)) {
    return false;
  }
  const prototype = Object.getPrototypeOf(obj);
  return prototype === Object.prototype || prototype === null;
}
__name(isPlainObject, "isPlainObject");
__name2(isPlainObject, "isPlainObject");
function isEmptyObject(obj) {
  if (!isObject(obj)) {
    return false;
  }
  if (Object.getOwnPropertyNames(obj).length > 0 || Object.getOwnPropertySymbols(obj).length > 0) {
    return false;
  }
  return true;
}
__name(isEmptyObject, "isEmptyObject");
__name2(isEmptyObject, "isEmptyObject");
function deepClone(obj) {
  try {
    if (typeof structuredClone === "function") {
      return structuredClone(obj);
    }
    throw new Error("structuredClone is not available");
  } catch (_error) {
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    return { ...obj };
  }
}
__name(deepClone, "deepClone");
__name2(deepClone, "deepClone");
function hasKey(obj, key) {
  return isObject(obj) && key in obj;
}
__name(hasKey, "hasKey");
__name2(hasKey, "hasKey");
function createAsyncIterableStream(source) {
  const stream = source.pipeThrough(new TransformStream());
  stream[Symbol.asyncIterator] = () => {
    const reader = stream.getReader();
    return {
      async next() {
        const { done, value } = await reader.read();
        return done ? { done: true, value: void 0 } : { done: false, value };
      }
    };
  };
  return stream;
}
__name(createAsyncIterableStream, "createAsyncIterableStream");
__name2(createAsyncIterableStream, "createAsyncIterableStream");
function safeStringify(input, { indentation } = {}) {
  try {
    const seen = /* @__PURE__ */ new WeakSet();
    return JSON.stringify(input, safeStringifyReplacer(seen), indentation);
  } catch (error) {
    return `SAFE_STRINGIFY_ERROR: Error stringifying object: ${error instanceof Error ? error.message : "Unknown error"}`;
  }
}
__name(safeStringify, "safeStringify");
__name2(safeStringify, "safeStringify");
function safeStringifyReplacer(seen) {
  const replacer = /* @__PURE__ */ __name2((_key, value) => {
    if (typeof value?.toJSON === "function") {
      value = value.toJSON();
    }
    if (!(value !== null && typeof value === "object")) {
      return value;
    }
    if (seen.has(value)) {
      return "[Circular]";
    }
    seen.add(value);
    const newValue = Array.isArray(value) ? [] : {};
    for (const [key2, value2] of Object.entries(value)) {
      newValue[key2] = replacer(key2, value2);
    }
    seen.delete(value);
    return newValue;
  }, "replacer");
  return replacer;
}
__name(safeStringifyReplacer, "safeStringifyReplacer");
__name2(safeStringifyReplacer, "safeStringifyReplacer");

// src/provider.ts
var import_ai2 = require("ai");
var import_ts_pattern2 = require("ts-pattern");

// src/utils.ts
var import_ai = require("ai");
var import_ts_pattern = require("ts-pattern");
function convertToolsForSDK(tools) {
  if (!tools || tools.length === 0) {
    return void 0;
  }
  return tools.reduce((acc, tool) => {
    acc[tool.name] = (0, import_ai.tool)({
      description: tool.description,
      inputSchema: tool.parameters,
      outputSchema: tool.outputSchema,
      execute: tool.execute
    });
    return acc;
  }, {});
}
__name(convertToolsForSDK, "convertToolsForSDK");
function createStepFromChunk(chunk) {
  return (0, import_ts_pattern.match)(chunk).returnType().when(
    (c) => c.type === "text" && c.text,
    (c) => ({
      id: (0, import_ai.generateId)(),
      type: "text",
      content: c.text,
      role: "assistant",
      usage: c.usage || void 0
    })
  ).with({ type: import_ts_pattern.P.union("tool-call", "tool_call") }, (c) => ({
    id: c.toolCallId,
    type: "tool_call",
    name: c.toolName,
    arguments: c.input,
    content: safeStringify([
      {
        type: "tool-call",
        toolCallId: c.toolCallId,
        toolName: c.toolName,
        args: c.input
      }
    ]),
    role: "assistant",
    usage: c.usage || void 0
  })).with({ type: import_ts_pattern.P.union("tool-result", "tool_result") }, (c) => ({
    id: c.toolCallId,
    type: "tool_result",
    name: c.toolName,
    result: c.output,
    content: safeStringify([
      {
        type: "tool-result",
        toolCallId: c.toolCallId,
        toolName: c.toolName,
        result: c.output
      }
    ]),
    role: "assistant",
    usage: c.usage || void 0
  })).otherwise(() => null);
}
__name(createStepFromChunk, "createStepFromChunk");
function createVoltagentErrorFromSdkError(sdkError, errorStage = "llm_stream") {
  const originalError = (0, import_ts_pattern.match)(sdkError).returnType().with({ error: import_ts_pattern.P.not(import_ts_pattern.P.nullish) }, (e) => e.error).with(import_ts_pattern.P.instanceOf(Error), (e) => e).otherwise(
    () => new Error(`An unknown error occurred during Vercel AI operation (stage: ${errorStage})`)
  );
  return (0, import_ts_pattern.match)(originalError).returnType().with({ toolCallId: import_ts_pattern.P.not(import_ts_pattern.P.nullish), toolName: import_ts_pattern.P.not(import_ts_pattern.P.nullish) }, (e) => ({
    message: `Error during Vercel SDK operation (tool '${e.toolName}'): ${e instanceof Error ? originalError.message : "Unknown tool error"}`,
    originalError: e,
    toolError: {
      toolCallId: e.toolCallId,
      toolName: e.toolName,
      toolArguments: e.input,
      toolExecutionError: e
    },
    stage: "tool_execution",
    code: e.code
  })).otherwise((e) => ({
    message: e.message,
    originalError: e,
    toolError: void 0,
    stage: errorStage,
    code: e.code
  }));
}
__name(createVoltagentErrorFromSdkError, "createVoltagentErrorFromSdkError");
function mapToStreamPart(part) {
  return (0, import_ts_pattern.match)(part).returnType().with({ type: "text-delta" }, (p) => ({
    type: "text-delta",
    textDelta: p.text
  })).with({ type: "reasoning-delta" }, (p) => ({
    type: "reasoning",
    reasoning: p.text
  })).with({ type: "source", sourceType: "url" }, (p) => ({
    type: "source",
    source: p.url || ""
  })).with({ type: "tool-call" }, (p) => ({
    type: "tool-call",
    toolCallId: p.toolCallId,
    toolName: p.toolName,
    args: p.input
  })).with({ type: "tool-result" }, (p) => ({
    type: "tool-result",
    toolCallId: p.toolCallId,
    toolName: p.toolName,
    result: p.output
  })).with({ type: "finish" }, (p) => ({
    type: "finish",
    finishReason: p.finishReason,
    usage: (0, import_ts_pattern.match)(p).with(
      {
        totalUsage: {
          inputTokens: import_ts_pattern.P.number,
          outputTokens: import_ts_pattern.P.number,
          totalTokens: import_ts_pattern.P.number,
          cachedInputTokens: import_ts_pattern.P.optional(import_ts_pattern.P.number),
          reasoningTokens: import_ts_pattern.P.optional(import_ts_pattern.P.number)
        }
      },
      (p2) => ({
        promptTokens: p2.totalUsage.inputTokens,
        completionTokens: p2.totalUsage.outputTokens,
        totalTokens: p2.totalUsage.totalTokens,
        cachedInputTokens: p2.totalUsage.cachedInputTokens,
        reasoningTokens: p2.totalUsage.reasoningTokens
      })
    ).otherwise(() => void 0)
  })).with({ type: "error" }, (p) => ({
    type: "error",
    error: p.error
  })).otherwise(() => null);
}
__name(mapToStreamPart, "mapToStreamPart");
function createMappedFullStream(originalStream) {
  return {
    async *[Symbol.asyncIterator]() {
      for await (const part of originalStream) {
        const mappedPart = mapToStreamPart(part);
        if (mappedPart !== null) {
          yield mappedPart;
        }
      }
    }
  };
}
__name(createMappedFullStream, "createMappedFullStream");

// src/provider.ts
var VercelAIProvider = class {
  static {
    __name(this, "VercelAIProvider");
  }
  /**
   * Provider `generateText` implementation
   * @param options - The options for the generate text operation
   * @returns A standardized response for VoltAgent
   */
  async generateText(options) {
    const vercelMessages = options.messages.map(this.toMessage);
    const vercelTools = options.tools ? convertToolsForSDK(options.tools) : void 0;
    const onStepFinish = options.onStepFinish ? async (result) => {
      if (options.onStepFinish) {
        if (result.text) {
          const step = createStepFromChunk({
            type: "text",
            text: result.text,
            usage: result.usage
          });
          if (step) await options.onStepFinish(step);
        }
        if (result.toolCalls && result.toolCalls.length > 0) {
          for (const toolCall of result.toolCalls) {
            const step = createStepFromChunk({
              type: "tool-call",
              toolCallId: toolCall.toolCallId,
              toolName: toolCall.toolName,
              input: toolCall.input,
              usage: result.usage
            });
            if (step) await options.onStepFinish(step);
          }
        }
        if (result.toolResults && result.toolResults.length > 0) {
          for (const toolResult of result.toolResults) {
            const step = createStepFromChunk({
              type: "tool-result",
              toolCallId: toolResult.toolCallId,
              toolName: toolResult.toolName,
              output: toolResult.output,
              usage: result.usage
            });
            if (step) await options.onStepFinish(step);
          }
        }
      }
    } : void 0;
    try {
      const result = await (0, import_ai2.generateText)({
        ...options.provider,
        messages: vercelMessages,
        model: options.model,
        tools: vercelTools,
        ...(0, import_ts_pattern2.match)(options.maxSteps).with(import_ts_pattern2.P.number, (maxSteps) => ({ stopWhen: (0, import_ai2.stepCountIs)(maxSteps) })).otherwise(() => ({})),
        ...(0, import_ts_pattern2.match)(options.provider?.maxTokens).with(import_ts_pattern2.P.number, (maxTokens) => ({ maxOutputTokens: maxTokens })).otherwise(() => ({})),
        abortSignal: options.signal,
        onStepFinish
      });
      return {
        provider: result,
        text: result.text || "",
        usage: getUsageInfo(result.usage),
        toolCalls: result.toolCalls,
        toolResults: result.toolResults,
        finishReason: result.finishReason,
        reasoning: Array.isArray(result.reasoning) ? result.reasoning.map((r) => r.text || "").join("\n") : result.reasoning,
        warnings: result.warnings
      };
    } catch (sdkError) {
      const voltagentErr = createVoltagentErrorFromSdkError(sdkError, "llm_generate");
      throw voltagentErr;
    }
  }
  /**
   * Provider `streamText` implementation
   * @param options - The options for the stream text operation
   * @returns A standardized response for VoltAgent
   */
  async streamText(options) {
    try {
      const vercelMessages = options.messages.map(this.toMessage);
      const vercelTools = options.tools ? convertToolsForSDK(options.tools) : void 0;
      const onStepFinish = options.onStepFinish ? async (result2) => {
        if (options.onStepFinish) {
          if (result2.text) {
            const step = createStepFromChunk({
              type: "text",
              text: result2.text,
              usage: result2.usage
            });
            if (step) await options.onStepFinish(step);
          }
          if (result2.toolCalls && result2.toolCalls.length > 0) {
            for (const toolCall of result2.toolCalls) {
              const step = createStepFromChunk({
                type: "tool-call",
                toolCallId: toolCall.toolCallId,
                toolName: toolCall.toolName,
                input: toolCall.input,
                usage: result2.usage
              });
              if (step) await options.onStepFinish(step);
            }
          }
          if (result2.toolResults && result2.toolResults.length > 0) {
            for (const toolResult of result2.toolResults) {
              const step = createStepFromChunk({
                type: "tool-result",
                toolCallId: toolResult.toolCallId,
                toolName: toolResult.toolName,
                output: toolResult.output,
                usage: result2.usage
              });
              if (step) await options.onStepFinish(step);
            }
          }
        }
      } : void 0;
      const result = (0, import_ai2.streamText)({
        ...options.provider,
        messages: vercelMessages,
        model: options.model,
        tools: vercelTools,
        ...(0, import_ts_pattern2.match)(options.maxSteps).with(import_ts_pattern2.P.number, (maxSteps) => ({ stopWhen: (0, import_ai2.stepCountIs)(maxSteps) })).otherwise(() => ({})),
        ...(0, import_ts_pattern2.match)(options.provider?.maxTokens).with(import_ts_pattern2.P.number, (maxTokens) => ({ maxOutputTokens: maxTokens })).otherwise(() => ({})),
        abortSignal: options.signal,
        onStepFinish,
        onChunk: /* @__PURE__ */ __name(async ({ chunk }) => {
          if (options?.onChunk) {
            const step = createStepFromChunk(chunk);
            if (step) await options.onChunk(step);
          }
        }, "onChunk"),
        onFinish: options.onFinish ? async (result2) => {
          options.onFinish?.({
            text: result2.text,
            usage: getUsageInfo(result2.usage),
            finishReason: result2.finishReason,
            warnings: result2.warnings,
            providerResponse: result2
          });
        } : void 0,
        onError: /* @__PURE__ */ __name((sdkError) => {
          const voltagentErr = createVoltagentErrorFromSdkError(sdkError, "llm_stream");
          if (options.onError) {
            options.onError(voltagentErr);
          }
        }, "onError")
      });
      return {
        provider: result,
        textStream: result.textStream,
        fullStream: createMappedFullStream(result.fullStream),
        text: result.text,
        finishReason: result.finishReason,
        usage: result.usage,
        // fix me
        reasoning: result.reasoning.then ? result.reasoning.then(
          (r) => Array.isArray(r) ? r.map((p) => p.text || "").join("\n") : void 0
        ) : Promise.resolve(void 0)
      };
    } catch (error) {
      throw createVoltagentErrorFromSdkError(error, "llm_stream");
    }
  }
  /**
   * Provider `generateObject` implementation.
   * @param options - The options for the generate object operation
   * @returns A standardized response for VoltAgent
   */
  async generateObject(options) {
    const vercelMessages = options.messages.map(this.toMessage);
    const onFinish = (0, import_ts_pattern2.match)(options).with({ onStepFinish: import_ts_pattern2.P.not(import_ts_pattern2.P.nullish) }, (o) => {
      return async (result) => {
        const step = createStepFromChunk({
          type: "text",
          text: (0, import_ts_pattern2.match)(result.object).with(import_ts_pattern2.P.string, (s) => s).otherwise((o2) => safeStringify(o2)),
          usage: result.usage
        });
        if (step) {
          await o.onStepFinish(step);
        }
      };
    }).otherwise(() => void 0);
    try {
      const result = await (0, import_ai2.generateObject)({
        ...options.provider,
        messages: vercelMessages,
        model: options.model,
        schema: options.schema,
        ...(0, import_ts_pattern2.match)(options.provider?.maxTokens).with(import_ts_pattern2.P.number, (maxTokens) => ({ maxOutputTokens: maxTokens })).otherwise(() => ({})),
        abortSignal: options.signal
      });
      await onFinish?.({ ...result, logprobs: void 0 });
      return {
        provider: result,
        object: result.object,
        usage: getUsageInfo(result.usage),
        finishReason: result.finishReason,
        warnings: result.warnings
      };
    } catch (sdkError) {
      const voltagentErr = createVoltagentErrorFromSdkError(sdkError, "object_generate");
      throw voltagentErr;
    }
  }
  /**
   * Provider `streamObject` implementation
   * @param options - The options for the stream object operation
   * @returns The streamed object
   */
  async streamObject(options) {
    const vercelMessages = options.messages.map(this.toMessage);
    const onFinish = (0, import_ts_pattern2.match)(options).returnType().with({ onStepFinish: import_ts_pattern2.P.not(import_ts_pattern2.P.nullish) }, (o) => {
      return async (event) => {
        const jsonResult = event.object ? safeStringify(event.object) : "";
        const step = createStepFromChunk({
          type: "text",
          // Simulate as a text step containing the final JSON
          text: jsonResult,
          usage: event.usage
        });
        if (step) {
          await o.onStepFinish(step);
        }
      };
    }).with({ onFinish: import_ts_pattern2.P.not(import_ts_pattern2.P.nullish) }, (o) => {
      return async (event) => {
        const finishResult = {
          object: event.object,
          usage: getUsageInfo(event.usage),
          // Mapped usage info
          warnings: event.warnings,
          providerResponse: event
          // Include the original SDK event object
          // finishReason is not typically available in Vercel's streamObject finish event
        };
        await o.onFinish(finishResult);
      };
    }).otherwise(() => null);
    const result = (0, import_ai2.streamObject)({
      ...options.provider,
      messages: vercelMessages,
      model: options.model,
      schema: options.schema,
      abortSignal: options.signal,
      ...(0, import_ts_pattern2.match)(options.provider?.maxTokens).with(import_ts_pattern2.P.number, (maxTokens) => ({ maxOutputTokens: maxTokens })).otherwise(() => ({})),
      ...(0, import_ts_pattern2.match)(onFinish).with(import_ts_pattern2.P.not(import_ts_pattern2.P.nullish), (handler) => ({ onFinish: handler })).otherwise(() => ({})),
      onError: /* @__PURE__ */ __name((sdkError) => {
        const voltagentErr = createVoltagentErrorFromSdkError(sdkError, "object_stream");
        if (options.onError) {
          options.onError(voltagentErr);
        }
      }, "onError")
    });
    const partialObjectStream = result.partialObjectStream;
    return {
      provider: { ...result, partialObjectStream },
      objectStream: partialObjectStream,
      object: result.object,
      usage: result.usage.then(
        (u) => getUsageInfo(u) || { promptTokens: 0, completionTokens: 0, totalTokens: 0 }
      ),
      warnings: result.warnings
    };
  }
  /**
   * Get the model identifier
   * @param model - The model to get the identifier for
   * @returns The model identifier
   */
  getModelIdentifier(model) {
    return typeof model === "string" ? model : model.modelId;
  }
  /**
   * Convert a VoltAgent message to a Vercel AI message
   * @param message - The VoltAgent message to convert
   * @returns The Vercel AI message
   */
  toMessage(message) {
    return message;
  }
};
function getUsageInfo(usage) {
  return (0, import_ts_pattern2.match)(usage).with({ inputTokens: import_ts_pattern2.P.number, outputTokens: import_ts_pattern2.P.number, totalTokens: import_ts_pattern2.P.number }, (u) => ({
    promptTokens: u.inputTokens,
    completionTokens: u.outputTokens,
    totalTokens: u.totalTokens,
    cachedInputTokens: u.cachedInputTokens,
    reasoningTokens: u.reasoningTokens
  })).otherwise(() => void 0);
}
__name(getUsageInfo, "getUsageInfo");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  VercelAIProvider
});
//# sourceMappingURL=index.js.map