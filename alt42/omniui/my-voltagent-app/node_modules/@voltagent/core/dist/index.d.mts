import { DangerouslyAllowAny, PlainObject } from '@voltagent/internal/types';
import * as zod from 'zod';
import { z } from 'zod';
import { Logger } from '@voltagent/internal';
import { AsyncIterableStream } from '@voltagent/internal/utils';
export { AsyncIterableStream, createAsyncIterableStream } from '@voltagent/internal/utils';
import { Span } from '@opentelemetry/api';
import * as TF from 'type-fest';
import { Simplify, LiteralUnion, MergeDeep } from 'type-fest';
import { EventEmitter } from 'node:events';
import { Client } from '@libsql/client';
import { SpanExporter } from '@opentelemetry/sdk-trace-base';
import { Context } from 'hono';
import { ClientCapabilities } from '@modelcontextprotocol/sdk/types.js';

/**
 * Represents a collection of related tools with optional shared instructions.
 */
type Toolkit = {
    /**
     * Unique identifier name for the toolkit. Used for management and potentially logging.
     */
    name: string;
    /**
     * A brief description of what the toolkit does or what tools it contains.
     * Optional.
     */
    description?: string;
    /**
     * Shared instructions for the LLM on how to use the tools within this toolkit.
     * These instructions are intended to be added to the system prompt if `addInstructions` is true.
     * Optional.
     */
    instructions?: string;
    /**
     * Whether to automatically add the toolkit's `instructions` to the agent's system prompt.
     * If true, the instructions from individual tools within this toolkit might be ignored
     * by the Agent's system message generation logic to avoid redundancy.
     * Defaults to false.
     */
    addInstructions?: boolean;
    /**
     * An array of Tool instances that belong to this toolkit.
     */
    tools: Tool<ToolSchema>[];
};
/**
 * Helper function for creating a new toolkit.
 * Provides default values and ensures the basic structure is met.
 *
 * @param options - The configuration options for the toolkit.
 * @returns A Toolkit object.
 */
declare const createToolkit: (options: Toolkit) => Toolkit;

/**
 * Status of a tool at any given time
 */
type ToolStatus = "idle" | "working" | "error" | "completed";
/**
 * Tool status information
 */
type ToolStatusInfo = {
    name: string;
    status: ToolStatus;
    result?: any;
    error?: any;
    input?: any;
    output?: any;
    timestamp: Date;
    parameters?: any;
};
/**
 * Manager class to handle all tool-related operations, including Toolkits.
 */
declare class ToolManager {
    /**
     * Standalone tools managed by this manager.
     */
    private tools;
    /**
     * Toolkits managed by this manager.
     */
    private toolkits;
    /**
     * Logger instance
     */
    private logger;
    /**
     * Creates a new ToolManager.
     * Accepts both individual tools and toolkits.
     */
    constructor(items?: (AgentTool | Toolkit)[], logger?: Logger);
    /**
     * Get all individual tools and tools within toolkits as a flattened list.
     */
    getTools(): BaseTool[];
    /**
     * Get all toolkits managed by this manager.
     */
    getToolkits(): Toolkit[];
    /**
     * Add an individual tool to the manager.
     * If a standalone tool with the same name already exists, it will be replaced.
     * A warning is issued if the name conflicts with a tool inside a toolkit, but the standalone tool is still added/replaced.
     * @returns true if the tool was successfully added or replaced.
     */
    addTool(tool: AgentTool): boolean;
    /**
     * Add a toolkit to the manager.
     * If a toolkit with the same name already exists, it will be replaced.
     * Also checks if any tool within the toolkit conflicts with existing standalone tools or tools in other toolkits.
     * @returns true if the toolkit was successfully added or replaced.
     */
    addToolkit(toolkit: Toolkit): boolean;
    /**
     * Add multiple tools or toolkits to the manager.
     */
    addItems(items: (AgentTool | Toolkit)[]): void;
    /**
     * Remove a standalone tool by name. Does not remove tools from toolkits.
     * @returns true if the tool was removed, false if it wasn't found.
     */
    removeTool(toolName: string): boolean;
    /**
     * Remove a toolkit by name.
     * @returns true if the toolkit was removed, false if it wasn't found.
     */
    removeToolkit(toolkitName: string): boolean;
    /**
     * Prepare tools for text generation (includes tools from toolkits).
     */
    prepareToolsForGeneration(dynamicTools?: (BaseTool | Toolkit)[]): BaseTool[];
    /**
     * Get agent's tools (including those in toolkits) for API exposure.
     */
    getToolsForApi(): {
        name: string;
        description: string;
        parameters: any;
    }[];
    /**
     * Check if a tool with the given name exists (either standalone or in a toolkit).
     */
    hasTool(toolName: string): boolean;
    /**
     * Get a tool by name (searches standalone tools and tools within toolkits).
     * @param toolName The name of the tool to get
     * @returns The tool (as BaseTool) or undefined if not found
     */
    getToolByName(toolName: string): BaseTool | undefined;
    /**
     * Execute a tool by name
     * @param toolName The name of the tool to execute
     * @param args The arguments to pass to the tool
     * @param options Optional execution options like signal
     * @returns The result of the tool execution
     * @throws Error if the tool doesn't exist or fails to execute
     */
    executeTool(toolName: string, args: any, options?: ToolExecuteOptions): Promise<any>;
}

/**
 * Tool definition compatible with Vercel AI SDK
 */
type AgentTool = BaseTool;
/**
 * Tool options for creating a new tool
 */
type ToolOptions<T extends ToolSchema = ToolSchema, O extends ToolSchema | undefined = undefined> = {
    /**
     * Unique identifier for the tool
     */
    id?: string;
    /**
     * Name of the tool
     */
    name: string;
    /**
     * Description of the tool
     */
    description: string;
    /**
     * Tool parameter schema
     */
    parameters: T;
    /**
     * Tool output schema (optional)
     */
    outputSchema?: O;
    /**
     * Function to execute when the tool is called
     */
    execute: (args: z.infer<T>, options?: ToolExecuteOptions) => Promise<O extends ToolSchema ? z.infer<O> : unknown>;
};
/**
 * Tool class for defining tools that agents can use
 */
declare class Tool<T extends ToolSchema = ToolSchema, O extends ToolSchema | undefined = undefined> {
    /**
     * Unique identifier for the tool
     */
    readonly id: string;
    /**
     * Name of the tool
     */
    readonly name: string;
    /**
     * Description of the tool
     */
    readonly description: string;
    /**
     * Tool parameter schema
     */
    readonly parameters: T;
    /**
     * Tool output schema
     */
    readonly outputSchema?: O;
    /**
     * Function to execute when the tool is called
     */
    readonly execute: (args: z.infer<T>, options?: ToolExecuteOptions) => Promise<O extends ToolSchema ? z.infer<O> : unknown>;
    /**
     * Create a new tool
     */
    constructor(options: ToolOptions<T, O>);
}
/**
 * Helper function for creating a new tool
 */
declare function createTool<T extends ToolSchema>(options: ToolOptions<T, undefined>): Tool<T, undefined>;
declare function createTool<T extends ToolSchema, O extends ToolSchema>(options: ToolOptions<T, O>): Tool<T, O>;
/**
 * Alias for createTool function
 */
declare const tool: typeof createTool;

/**
 * The base input type for the workflow
 * @private - INTERNAL USE ONLY
 */
type InternalBaseWorkflowInputSchema = z.ZodTypeAny | BaseMessage | BaseMessage[] | string;
/**
 * The state parameter for the workflow, used to pass the state to a step or other function (i.e. hooks)
 * @private - INTERNAL USE ONLY
 */
type InternalWorkflowStateParam<INPUT> = Omit<WorkflowState<INPUT, DangerouslyAllowAny>, "data" | "result"> & {
    /** Workflow execution context for event tracking */
    workflowContext?: WorkflowExecutionContext;
    /** AbortSignal for checking suspension during step execution */
    signal?: AbortSignal;
};
/**
 * Context object for new execute API with helper functions
 * @private - INTERNAL USE ONLY
 */
interface WorkflowExecuteContext<INPUT, DATA, SUSPEND_DATA, RESUME_DATA> {
    data: InternalExtractWorkflowInputData<DATA>;
    state: InternalWorkflowStateParam<INPUT>;
    getStepData: (stepId: string) => {
        input: any;
        output: any;
    } | undefined;
    suspend: (reason?: string, suspendData?: SUSPEND_DATA) => Promise<never>;
    resumeData?: RESUME_DATA;
    /**
     * Logger instance for this workflow execution.
     * Provides execution-scoped logging with full context (userId, conversationId, executionId).
     */
    logger: Logger;
    /**
     * Stream writer for emitting events during streaming execution.
     * Always available - uses NoOpWorkflowStreamWriter when not streaming
     */
    writer: WorkflowStreamWriter;
}
/**
 * A function that can be executed by the workflow
 * Uses context-based API with data, state, and helper functions
 * @private - INTERNAL USE ONLY
 */
type InternalWorkflowFunc<INPUT, DATA, RESULT, SUSPEND_DATA, RESUME_DATA> = (context: WorkflowExecuteContext<INPUT, DATA, SUSPEND_DATA, RESUME_DATA>) => Promise<RESULT>;
type InternalWorkflowStepConfig<T extends PlainObject = PlainObject> = {
    /**
     * Unique identifier for the step
     * @required - Must be provided for proper step tracking
     */
    id: string;
    /**
     * Human-readable name for the step
     */
    name?: string;
    /**
     * Description of what the step does
     */
    purpose?: string;
} & T;
/**
 * Base step interface for building new steps
 * @private - INTERNAL USE ONLY
 */
interface InternalBaseWorkflowStep<INPUT, DATA, RESULT, SUSPEND_DATA, RESUME_DATA> {
    /**
     * Unique identifier for the step
     */
    id: string;
    /**
     * Human-readable name for the step
     */
    name: string | null;
    /**
     * Description of what the step does
     */
    purpose: string | null;
    /**
     * Type identifier for the step
     */
    type: string;
    /**
     * Optional input schema for runtime validation
     */
    inputSchema?: z.ZodTypeAny;
    /**
     * Optional output schema for runtime validation
     */
    outputSchema?: z.ZodTypeAny;
    /**
     * Optional suspend data schema for this step
     */
    suspendSchema?: z.ZodTypeAny;
    /**
     * Optional resume data schema for this step
     */
    resumeSchema?: z.ZodTypeAny;
    /**
     * Execute the step with the given context
     * @param context - The execution context containing data, state, and helpers
     * @returns The result of the step
     */
    execute: (context: WorkflowExecuteContext<INPUT, DATA, SUSPEND_DATA, RESUME_DATA>) => Promise<RESULT>;
}
/**
 * Any step that can be accepted by the workflow
 * @private - INTERNAL USE ONLY
 */
type InternalAnyWorkflowStep<INPUT = DangerouslyAllowAny, DATA = DangerouslyAllowAny, RESULT = DangerouslyAllowAny, SUSPEND_DATA = DangerouslyAllowAny, RESUME_DATA = DangerouslyAllowAny> = InternalBaseWorkflowStep<INPUT, DATA, RESULT, SUSPEND_DATA, RESUME_DATA> | Omit<InternalBaseWorkflowStep<INPUT, DATA, RESULT, SUSPEND_DATA, RESUME_DATA>, "type">;
/**
 * Infer the result type from a list of steps
 * @private - INTERNAL USE ONLY
 */
type InternalInferWorkflowStepsResult<STEPS extends ReadonlyArray<InternalAnyWorkflowStep<any, any, any, any, any>>> = {
    [K in keyof STEPS]: ExtractExecuteResult<STEPS[K]>;
};
type InternalExtractWorkflowInputData<T> = TF.IsUnknown<T> extends true ? BaseMessage | BaseMessage[] | string : TF.IsAny<T> extends true ? BaseMessage | BaseMessage[] | string : T extends z.ZodType ? z.infer<T> : T;
type ExtractExecuteResult<T> = T extends {
    execute: (...args: any[]) => infer R;
} ? R extends Promise<infer U> ? U : R : never;

type WorkflowStateStatus = "pending" | "running" | "completed" | "failed" | "suspended";
type WorkflowState<INPUT, RESULT> = {
    executionId: string;
    conversationId?: string;
    userId?: string;
    userContext?: UserContext;
    active: number;
    startAt: Date;
    endAt: Date | null;
    status: WorkflowStateStatus;
    /** the initial input data to the workflow */
    input: InternalExtractWorkflowInputData<INPUT>;
    /** current data being processed */
    data: DangerouslyAllowAny;
    /** the result of workflow execution, null until execution is complete */
    result: RESULT | null;
    error: Error | null;
    /** suspension metadata when workflow is suspended */
    suspension?: WorkflowSuspensionMetadata;
    /** accumulated usage from andAgent calls */
    usage: UsageInfo;
};

interface WorkflowSuspensionMetadata<SUSPEND_DATA = DangerouslyAllowAny> {
    /** Timestamp when the workflow was suspended */
    suspendedAt: Date;
    /** Reason for suspension (user-requested, system, error, etc.) */
    reason?: string;
    /** The step index where suspension occurred */
    suspendedStepIndex: number;
    /** Last event sequence number before suspension */
    lastEventSequence?: number;
    /** Validated data passed when suspending (if suspendSchema was provided) */
    suspendData?: SUSPEND_DATA;
    /** Checkpoint data for resumption */
    checkpoint?: {
        /** Current step's partial execution state */
        stepExecutionState?: DangerouslyAllowAny;
        /** Results from completed steps that need to be preserved */
        completedStepsData?: DangerouslyAllowAny[];
    };
}
/**
 * Custom abort controller for workflow suspension with reason tracking
 */
interface WorkflowSuspendController {
    /**
     * The abort signal to pass to the workflow
     */
    signal: AbortSignal;
    /**
     * Suspend the workflow with a reason
     */
    suspend: (reason?: string) => void;
    /**
     * Check if the workflow has been suspended
     */
    isSuspended: () => boolean;
    /**
     * Get the suspension reason
     */
    getReason: () => string | undefined;
}
/**
 * Base result interface shared by all workflow execution results
 */
interface WorkflowExecutionResultBase<RESULT_SCHEMA extends z.ZodTypeAny, RESUME_SCHEMA extends z.ZodTypeAny = z.ZodAny> {
    /**
     * Unique execution ID for this workflow run
     */
    executionId: string;
    /**
     * The workflow ID
     */
    workflowId: string;
    /**
     * When the workflow execution started
     */
    startAt: Date;
    /**
     * When the workflow execution ended (completed, suspended, or errored)
     */
    endAt: Date | Promise<Date>;
    /**
     * Current status of the workflow execution
     */
    status: "completed" | "suspended" | "error" | Promise<"completed" | "suspended" | "error">;
    /**
     * The result data if workflow completed successfully
     */
    result: z.infer<RESULT_SCHEMA> | null | Promise<z.infer<RESULT_SCHEMA> | null>;
    /**
     * Suspension metadata if workflow was suspended
     */
    suspension?: WorkflowSuspensionMetadata | Promise<WorkflowSuspensionMetadata | undefined>;
    /**
     * Error information if workflow failed
     */
    error?: unknown | Promise<unknown | undefined>;
    /**
     * Total token usage from all andAgent steps in the workflow
     */
    usage: UsageInfo | Promise<UsageInfo>;
}
/**
 * Result returned from workflow execution with suspend/resume capabilities
 */
interface WorkflowExecutionResult<RESULT_SCHEMA extends z.ZodTypeAny, RESUME_SCHEMA extends z.ZodTypeAny = z.ZodAny> extends WorkflowExecutionResultBase<RESULT_SCHEMA, RESUME_SCHEMA> {
    endAt: Date;
    status: "completed" | "suspended" | "error";
    result: z.infer<RESULT_SCHEMA> | null;
    suspension?: WorkflowSuspensionMetadata;
    error?: unknown;
    usage: UsageInfo;
    /**
     * Resume a suspended workflow execution
     * @param input - Optional new input data for resuming (validated against resumeSchema if provided)
     * @param options - Optional options for resuming, including stepId to resume from a specific step
     * @returns A new execution result that can also be resumed if suspended again
     */
    resume: (input: z.infer<RESUME_SCHEMA>, options?: {
        stepId?: string;
    }) => Promise<WorkflowExecutionResult<RESULT_SCHEMA, RESUME_SCHEMA>>;
}
/**
 * Result returned from workflow stream execution
 * Extends base with streaming capabilities and promise-based fields
 */
interface WorkflowStreamResult<RESULT_SCHEMA extends z.ZodTypeAny, RESUME_SCHEMA extends z.ZodTypeAny = z.ZodAny> extends WorkflowExecutionResultBase<RESULT_SCHEMA, RESUME_SCHEMA>, AsyncIterable<WorkflowStreamEvent> {
    endAt: Promise<Date>;
    status: Promise<"completed" | "suspended" | "error">;
    result: Promise<z.infer<RESULT_SCHEMA> | null>;
    suspension: Promise<WorkflowSuspensionMetadata | undefined>;
    error: Promise<unknown | undefined>;
    usage: Promise<UsageInfo>;
    /**
     * Resume a suspended workflow execution
     * @param input - Optional new input data for resuming (validated against resumeSchema if provided)
     * @param options - Optional options for resuming, including stepId to resume from a specific step
     * @returns A new stream result that can also be resumed if suspended again
     */
    resume: (input: z.infer<RESUME_SCHEMA>, options?: {
        stepId?: string;
    }) => Promise<WorkflowStreamResult<RESULT_SCHEMA, RESUME_SCHEMA>>;
    /**
     * Abort the workflow execution
     */
    abort: () => void;
}
interface WorkflowRunOptions {
    /**
     * The active step, this can be used to track the current step in a workflow
     * @default 0
     */
    active?: number;
    /**
     * The execution ID, this can be used to track the current execution in a workflow
     * @default uuidv4
     */
    executionId?: string;
    /**
     * The conversation ID, this can be used to track the current conversation in a workflow
     */
    conversationId?: string;
    /**
     * The user ID, this can be used to track the current user in a workflow
     */
    userId?: string;
    /**
     * The user context, this can be used to track the current user context in a workflow
     */
    userContext?: UserContext;
    /**
     * Override workflow memory storage for this specific execution
     * Takes priority over workflow config memory and global memory
     */
    memory?: Memory;
    /**
     * Suspension controller for managing workflow suspension
     */
    suspendController?: WorkflowSuspendController;
    /**
     * Options for resuming a suspended workflow
     */
    resumeFrom?: WorkflowResumeOptions;
    /**
     * Suspension mode:
     * - 'graceful': Wait for current step to complete before suspending (default)
     * - 'immediate': Suspend immediately, even during step execution
     * @default 'graceful'
     */
    suspensionMode?: "immediate" | "graceful";
    /**
     * Logger instance to use for this workflow execution
     * If not provided, will use the workflow's logger or global logger
     */
    logger?: Logger;
}
interface WorkflowResumeOptions {
    /**
     * The execution ID of the suspended workflow to resume
     */
    executionId: string;
    /**
     * The checkpoint data from the suspension
     */
    checkpoint?: {
        stepExecutionState?: DangerouslyAllowAny;
        completedStepsData?: DangerouslyAllowAny[];
    };
    /**
     * The step index to resume from
     */
    resumeStepIndex: number;
    /**
     * The last event sequence number before suspension
     */
    lastEventSequence?: number;
    /**
     * Data to pass to the resumed step (validated against resumeSchema)
     */
    resumeData?: DangerouslyAllowAny;
}
/**
 * Hooks for the workflow
 * @param DATA - The type of the data
 * @param RESULT - The type of the result
 */
type WorkflowHooks<DATA, RESULT> = {
    /**
     * Called when the workflow starts
     * @param state - The current state of the workflow
     * @returns void
     */
    onStart?: (state: WorkflowState<DATA, RESULT>) => Promise<void>;
    /**
     * Called when a step starts
     * @param state - The current state of the workflow
     * @returns void
     */
    onStepStart?: (state: WorkflowState<DATA, RESULT>) => Promise<void>;
    /**
     * Called when a step ends
     * @param state - The current state of the workflow
     * @returns void
     */
    onStepEnd?: (state: WorkflowState<DATA, RESULT>) => Promise<void>;
    /**
     * Called when the workflow ends
     * @param state - The current state of the workflow
     * @returns void
     */
    onEnd?: (state: WorkflowState<DATA, RESULT>) => Promise<void>;
};
type WorkflowInput<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema> = TF.IsUnknown<INPUT_SCHEMA> extends true ? BaseMessage | BaseMessage[] | string : INPUT_SCHEMA extends z.ZodTypeAny ? z.infer<INPUT_SCHEMA> : undefined;
type WorkflowResult<RESULT_SCHEMA extends z.ZodTypeAny> = RESULT_SCHEMA extends z.ZodTypeAny ? z.infer<RESULT_SCHEMA> : RESULT_SCHEMA;
type WorkflowConfig<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, SUSPEND_SCHEMA extends z.ZodTypeAny = z.ZodAny, RESUME_SCHEMA extends z.ZodTypeAny = z.ZodAny> = {
    /**
     * Unique identifier for the workflow
     */
    id: string;
    /**
     * Human-readable name for the workflow
     */
    name: string;
    /**
     * Description of what the workflow does
     */
    purpose?: string;
    /**
     * Schema for the input data
     */
    input?: INPUT_SCHEMA;
    /**
     * Schema for the result data
     */
    result: RESULT_SCHEMA;
    /**
     * Schema for data passed when suspending (optional)
     */
    suspendSchema?: SUSPEND_SCHEMA;
    /**
     * Schema for data passed when resuming (optional)
     */
    resumeSchema?: RESUME_SCHEMA;
    /**
     * Hooks for the workflow
     */
    hooks?: WorkflowHooks<WorkflowInput<INPUT_SCHEMA>, WorkflowResult<RESULT_SCHEMA>>;
    /**
     * Memory storage for this workflow
     * Overrides global workflow memory from VoltAgent
     */
    memory?: Memory;
    /**
     * Logger instance to use for this workflow
     * If not provided, will use the global logger or create a default one
     */
    logger?: Logger;
};
/**
 * A workflow instance that can be executed
 */
type Workflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, SUSPEND_SCHEMA extends z.ZodTypeAny = z.ZodAny, RESUME_SCHEMA extends z.ZodTypeAny = z.ZodAny> = {
    /**
     * Unique identifier for the workflow
     */
    id: string;
    /**
     * Human-readable name for the workflow
     */
    name: string;
    /**
     * Description of what the workflow does
     * @default "No purpose provided"
     */
    purpose: string;
    /**
     * Array of steps to execute in order
     */
    steps: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, DangerouslyAllowAny, DangerouslyAllowAny>[];
    /**
     * Input schema for the workflow (for API access)
     */
    inputSchema?: INPUT_SCHEMA;
    /**
     * Suspend schema for the workflow (for API access)
     */
    suspendSchema?: SUSPEND_SCHEMA;
    /**
     * Resume schema for the workflow (for API access)
     */
    resumeSchema?: RESUME_SCHEMA;
    /**
     * Memory storage for this workflow (exposed for registry access)
     */
    memory?: Memory;
    /**
     * Execute the workflow with the given input
     * @param input - The input to the workflow
     * @param options - Options for the workflow execution
     * @returns Execution result with final result
     */
    run: (input: WorkflowInput<INPUT_SCHEMA>, options?: WorkflowRunOptions) => Promise<WorkflowExecutionResult<RESULT_SCHEMA, RESUME_SCHEMA>>;
    /**
     * Execute the workflow with streaming support
     * @param input - The input to the workflow
     * @param options - Options for the workflow execution
     * @returns Stream result with real-time events and promise-based fields
     */
    stream: (input: WorkflowInput<INPUT_SCHEMA>, options?: WorkflowRunOptions) => WorkflowStreamResult<RESULT_SCHEMA, RESUME_SCHEMA>;
    /**
     * Create a WorkflowSuspendController that can be used to suspend the workflow
     * @returns A WorkflowSuspendController instance
     */
    createSuspendController?: () => WorkflowSuspendController;
};
/**
 * Base workflow history entry - common fields for all use cases
 */
interface BaseWorkflowHistoryEntry {
    id: string;
    workflowId: string;
    status: "running" | "completed" | "error" | "cancelled";
    startTime: Date;
    endTime?: Date;
    input: unknown;
    output?: unknown;
}
/**
 * Base workflow step history entry - common fields for all use cases
 */
interface BaseWorkflowStepHistoryEntry {
    stepIndex: number;
    stepType: "agent" | "func" | "conditional-when" | "parallel-all" | "parallel-race";
    stepName: string;
    status: "pending" | "running" | "completed" | "error" | "skipped";
    startTime?: Date;
    endTime?: Date;
    input?: unknown;
    output?: unknown;
    agentExecutionId?: string;
    parallelIndex?: number;
}
interface WorkflowHistoryEntry extends BaseWorkflowHistoryEntry {
    workflowName: string;
    steps: WorkflowStepHistoryEntry[];
    events: WorkflowTimelineEvent$1[];
    userId?: string;
    conversationId?: string;
    metadata?: Record<string, unknown>;
    createdAt?: Date;
    updatedAt?: Date;
}
/**
 * Used consistently across memory storage and runtime
 */
interface WorkflowStepHistoryEntry extends BaseWorkflowStepHistoryEntry {
    id: string;
    stepId?: string;
    workflowHistoryId: string;
    startTime: Date;
    error?: unknown;
    parallelIndex?: number;
    parallelParentStepId?: string;
    agentExecutionId?: string;
    metadata?: Record<string, unknown>;
    createdAt?: Date;
    updatedAt?: Date;
}
/**
 * Workflow timeline event - represents events during workflow execution
 */
interface WorkflowTimelineEvent$1 {
    id: string;
    workflowHistoryId: string;
    eventId: string;
    name: string;
    type: "workflow" | "workflow-step";
    startTime: string;
    endTime?: string;
    status: string;
    level?: string;
    input?: unknown;
    output?: unknown;
    statusMessage?: unknown;
    metadata?: Record<string, unknown>;
    traceId?: string;
    parentEventId?: string;
    eventSequence?: number;
    createdAt: Date;
}
/**
 * Workflow statistics for reporting
 */
interface WorkflowStats {
    totalExecutions: number;
    successfulExecutions: number;
    failedExecutions: number;
    averageExecutionTime: number;
    lastExecutionTime?: Date;
}
/**
 * Event emitted during workflow streaming
 */
interface WorkflowStreamEvent {
    /**
     * Type of the event (e.g., "step-start", "step-complete", "custom", "agent-stream")
     */
    type: string;
    /**
     * Unique execution ID for this workflow run
     */
    executionId: string;
    /**
     * Source of the event (step ID or name)
     */
    from: string;
    /**
     * Input data for the step/event
     */
    input?: Record<string, DangerouslyAllowAny>;
    /**
     * Output data from the step/event
     */
    output?: Record<string, DangerouslyAllowAny>;
    /**
     * Current status of the step/event
     */
    status: "pending" | "running" | "success" | "error" | "suspended";
    /**
     * User context passed through the workflow
     */
    userContext?: UserContext;
    /**
     * Timestamp of the event
     */
    timestamp: string;
    /**
     * Current step index in the workflow
     */
    stepIndex?: number;
    /**
     * Step type for step events
     */
    stepType?: "agent" | "func" | "conditional-when" | "parallel-all" | "parallel-race" | "tap" | "workflow";
    /**
     * Additional metadata
     */
    metadata?: Record<string, DangerouslyAllowAny>;
    /**
     * Error information if status is "error"
     */
    error?: DangerouslyAllowAny;
}
/**
 * Writer interface for emitting stream events from workflow steps
 */
interface WorkflowStreamWriter {
    /**
     * Write a custom event to the stream
     */
    write(event: Partial<WorkflowStreamEvent> & {
        type: string;
    }): void;
    /**
     * Pipe events from an agent's fullStream to the workflow stream
     * @param fullStream - The agent's fullStream async iterable
     * @param options - Optional configuration for piping
     */
    pipeFrom(fullStream: AsyncIterable<DangerouslyAllowAny>, options?: {
        prefix?: string;
        agentId?: string;
        filter?: (part: DangerouslyAllowAny) => boolean;
    }): Promise<void>;
}
/**
 * Options for creating workflow execution
 */
interface CreateWorkflowExecutionOptions {
    userId?: string;
    conversationId?: string;
    userContext?: UserContext;
    metadata?: Record<string, unknown>;
    executionId?: string;
}
/**
 * Options for recording workflow step
 */
interface RecordWorkflowStepOptions {
    stepId?: string;
    parallelIndex?: number;
    parentStepId?: string;
    metadata?: Record<string, unknown>;
}
/**
 * Options for updating workflow step
 */
interface UpdateWorkflowStepOptions {
    status?: "completed" | "error" | "skipped";
    output?: unknown;
    errorMessage?: string;
    agentExecutionId?: string;
    metadata?: Record<string, unknown>;
}

/**
 * Context information for a workflow execution
 * Contains all the runtime information about a workflow execution
 */
interface WorkflowExecutionContext {
    /**
     * Unique identifier for the workflow definition
     */
    workflowId: string;
    /**
     * Unique identifier for this specific execution
     */
    executionId: string;
    /**
     * Human-readable name of the workflow
     */
    workflowName: string;
    /**
     * User-defined context passed around during execution
     */
    userContext: Map<string | symbol, unknown>;
    /**
     * Whether the workflow is still actively running
     */
    isActive: boolean;
    /**
     * When the workflow execution started
     */
    startTime: Date;
    /**
     * Current step index being executed
     */
    currentStepIndex: number;
    /**
     * Array of completed steps (for tracking)
     */
    steps: any[];
    /**
     * AbortSignal for cancelling the workflow
     */
    signal?: AbortSignal;
    /**
     * History entry for this execution (if available)
     */
    historyEntry?: WorkflowHistoryEntry;
    /**
     * Memory storage instance for this workflow execution
     * Can be workflow-specific or global
     */
    memory?: Memory;
    /**
     * Map of executed step data (input and output) by step ID
     * Used for accessing previous step results
     */
    stepData: Map<string, {
        input: any;
        output: any;
    }>;
    /**
     * Current event sequence number for this workflow execution
     * Used to maintain event ordering even after server restarts
     */
    eventSequence: number;
    /**
     * Logger instance for this workflow execution
     * Provides execution-scoped logging with full context (userId, conversationId, executionId)
     */
    logger: Logger;
    /**
     * Stream writer for emitting events during streaming execution
     * Always available - uses NoOpWorkflowStreamWriter when not streaming
     */
    streamWriter: WorkflowStreamWriter;
}
/**
 * Workflow step context for individual step tracking
 */
interface WorkflowStepContext {
    stepId: string;
    stepIndex: number;
    stepType: "agent" | "func" | "conditional-when" | "parallel-all" | "parallel-race";
    stepName: string;
    workflowId: string;
    executionId: string;
    parentStepId?: string;
    parallelIndex?: number;
    startTime: Date;
}

/**
 * Memory options
 */
type MemoryOptions = {
    /**
     * Maximum number of messages to store in the database
     * @default 100
     */
    storageLimit?: number;
};
/**
 * Options for filtering messages when retrieving from memory
 */
type MessageFilterOptions = {
    /**
     * User identifier
     */
    userId?: string;
    /**
     * Conversation identifier
     */
    conversationId?: string;
    /**
     * Maximum number of messages to retrieve
     */
    limit?: number;
    /**
     * Only retrieve messages before this timestamp
     */
    before?: number;
    /**
     * Only retrieve messages after this timestamp
     */
    after?: number;
    /**
     * Only retrieve messages with this role
     */
    role?: BaseMessage["role"];
    /**
     * Only retrieve messages with these types
     * If not specified, all message types are returned
     */
    types?: Array<"text" | "tool-call" | "tool-result">;
};
/**
 * Conversation type
 */
type Conversation = {
    id: string;
    resourceId: string;
    userId: string;
    title: string;
    metadata: Record<string, unknown>;
    createdAt: string;
    updatedAt: string;
};
/**
 * Input type for creating a conversation
 */
type CreateConversationInput = {
    id: string;
    resourceId: string;
    userId: string;
    title: string;
    metadata: Record<string, unknown>;
};
/**
 * Query builder options for conversations
 */
type ConversationQueryOptions = {
    userId?: string;
    resourceId?: string;
    limit?: number;
    offset?: number;
    orderBy?: "created_at" | "updated_at" | "title";
    orderDirection?: "ASC" | "DESC";
};
/**
 * Memory interface for storing and retrieving messages
 */
type Memory = {
    /**
     * Add a message to memory
     */
    addMessage(message: BaseMessage, conversationId?: string): Promise<void>;
    /**
     * Get messages from memory
     */
    getMessages(options: MessageFilterOptions): Promise<BaseMessage[]>;
    /**
     * Clear messages from memory
     */
    clearMessages(options: {
        userId: string;
        conversationId?: string;
    }): Promise<void>;
    /**
     * Create a new conversation
     */
    createConversation(conversation: CreateConversationInput): Promise<Conversation>;
    /**
     * Get a conversation by ID
     */
    getConversation(id: string): Promise<Conversation | null>;
    /**
     * Get conversations for a resource
     */
    getConversations(resourceId: string): Promise<Conversation[]>;
    /**
     * Get conversations by user ID with query options
     */
    getConversationsByUserId(userId: string, options?: Omit<ConversationQueryOptions, "userId">): Promise<Conversation[]>;
    /**
     * Get conversations with advanced query options
     */
    queryConversations(options: ConversationQueryOptions): Promise<Conversation[]>;
    /**
     * Get all messages for a specific conversation
     */
    getConversationMessages(conversationId: string, options?: {
        limit?: number;
        offset?: number;
    }): Promise<MemoryMessage[]>;
    /**
     * Update a conversation
     */
    updateConversation(id: string, updates: Partial<Omit<Conversation, "id" | "createdAt" | "updatedAt">>): Promise<Conversation>;
    /**
     * Delete a conversation
     */
    deleteConversation(id: string): Promise<void>;
    /**
     * Add or update a history entry
     * @param key Entry ID
     * @param value Entry data
     * @param agentId Agent ID for filtering
     */
    addHistoryEntry(key: string, value: any, agentId: string): Promise<void>;
    /**
     * Update an existing history entry
     * @param key Entry ID
     * @param value Updated entry data
     * @param agentId Agent ID for filtering
     */
    updateHistoryEntry(key: string, value: any, agentId: string): Promise<void>;
    /**
     * Add a history step
     * @param key Step ID
     * @param value Step data
     * @param historyId Related history entry ID
     * @param agentId Agent ID for filtering
     */
    addHistoryStep(key: string, value: any, historyId: string, agentId: string): Promise<void>;
    /**
     * Update a history step
     * @param key Step ID
     * @param value Updated step data
     * @param historyId Related history entry ID
     * @param agentId Agent ID for filtering
     */
    updateHistoryStep(key: string, value: any, historyId: string, agentId: string): Promise<void>;
    /**
     * Get a history entry by ID
     * @param key Entry ID
     * @returns The history entry or undefined if not found
     */
    getHistoryEntry(key: string): Promise<any | undefined>;
    /**
     * Get a history step by ID
     * @param key Step ID
     * @returns The history step or undefined if not found
     */
    getHistoryStep(key: string): Promise<any | undefined>;
    /**
     * Get all history entries for an agent with pagination
     * @param agentId Agent ID
     * @param page Page number (0-based)
     * @param limit Number of entries per page
     * @returns Object with entries array and total count
     */
    getAllHistoryEntriesByAgent(agentId: string, page: number, limit: number): Promise<{
        entries: any[];
        total: number;
    }>;
    /**
     * Add a timeline event
     * This is part of the new immutable event system.
     * @param key Event ID (UUID)
     * @param value Timeline event data with immutable structure
     * @param historyId Related history entry ID
     * @param agentId Agent ID for filtering
     */
    addTimelineEvent(key: string, value: NewTimelineEvent, historyId: string, agentId: string): Promise<void>;
    storeWorkflowHistory(entry: WorkflowHistoryEntry): Promise<void>;
    getWorkflowHistory(id: string): Promise<WorkflowHistoryEntry | null>;
    getWorkflowHistoryByWorkflowId(workflowId: string): Promise<WorkflowHistoryEntry[]>;
    updateWorkflowHistory(id: string, updates: Partial<WorkflowHistoryEntry>): Promise<void>;
    deleteWorkflowHistory(id: string): Promise<void>;
    storeWorkflowStep(step: WorkflowStepHistoryEntry): Promise<void>;
    getWorkflowStep(id: string): Promise<WorkflowStepHistoryEntry | null>;
    getWorkflowSteps(workflowHistoryId: string): Promise<WorkflowStepHistoryEntry[]>;
    updateWorkflowStep(id: string, updates: Partial<WorkflowStepHistoryEntry>): Promise<void>;
    deleteWorkflowStep(id: string): Promise<void>;
    storeWorkflowTimelineEvent(event: WorkflowTimelineEvent$1): Promise<void>;
    getWorkflowTimelineEvent(id: string): Promise<WorkflowTimelineEvent$1 | null>;
    getWorkflowTimelineEvents(workflowHistoryId: string): Promise<WorkflowTimelineEvent$1[]>;
    deleteWorkflowTimelineEvent(id: string): Promise<void>;
    getAllWorkflowIds(): Promise<string[]>;
    getWorkflowStats(workflowId: string): Promise<WorkflowStats>;
    getWorkflowHistoryWithStepsAndEvents(id: string): Promise<WorkflowHistoryEntry | null>;
    deleteWorkflowHistoryWithRelated(id: string): Promise<void>;
    cleanupOldWorkflowHistories(workflowId: string, maxEntries: number): Promise<number>;
};
/**
 * Memory-specific message type
 */
type MemoryMessage = BaseMessage & {
    id: string;
    type: "text" | "tool-call" | "tool-result";
    createdAt: string;
};

type HistoryStatus = "working" | "completed" | "error";

/**
 * Step information for history
 */
interface HistoryStep {
    type: "message" | "tool_call" | "tool_result" | "text";
    name?: string;
    content?: string;
    arguments?: Record<string, unknown>;
}
/**
 * Parameters for adding a history entry
 */
interface AddEntryParams {
    /**
     * Input to the agent
     */
    input: string | Record<string, unknown> | BaseMessage[];
    /**
     * Output from the agent
     */
    output: string;
    /**
     * Status of the entry
     */
    status: AgentStatus;
    /**
     * Steps taken during generation
     */
    steps?: HistoryStep[];
    /**
     * Additional options for the entry
     */
    options?: Partial<Omit<AgentHistoryEntry, "id" | "timestamp" | "input" | "output" | "status" | "steps">>;
    /**
     * Optional userId for telemetry
     */
    userId?: string;
    /**
     * Optional conversationId for telemetry
     */
    conversationId?: string;
    /**
     * Optional model name for telemetry
     */
    model?: string;
}
/**
 * Agent history entry
 */
interface AgentHistoryEntry {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Timestamp of the entry
     */
    startTime: Date;
    endTime?: Date;
    /**
     * Original input to the agent
     */
    input: string | Record<string, unknown> | BaseMessage[];
    /**
     * Final output from the agent
     */
    output: string;
    /**
     * Status of the history entry
     */
    status: AgentStatus;
    /**
     * Steps taken during generation
     */
    steps?: HistoryStep[];
    /**
     * Usage information returned by the LLM
     */
    usage?: UsageInfo;
    metadata?: Record<string, unknown>;
    /**
     * User ID associated with this history entry
     */
    userId?: string;
    /**
     * Conversation ID associated with this history entry
     */
    conversationId?: string;
    /**
     * Sequence number for the history entry
     */
    _sequenceNumber?: number;
}
/**
 * Manages agent interaction history
 */
declare class HistoryManager {
    /**
     * Maximum number of history entries to keep
     * Set to 0 for unlimited
     */
    private maxEntries;
    /**
     * Agent ID for emitting events
     */
    private agentId?;
    /**
     * Memory manager for storing history entries
     */
    private memoryManager;
    /**
     * Optional VoltAgentExporter for sending telemetry data.
     */
    private voltAgentExporter?;
    /**
     * Background queue for non-blocking history operations
     * Uses lower concurrency to preserve operation order when telemetryExporter is enabled
     */
    private historyQueue;
    /**
     * Logger instance
     */
    private logger;
    /**
     * Create a new history manager
     *
     * @param agentId - Agent ID for emitting events and for storage
     * @param memoryManager - Memory manager instance to use
     * @param maxEntries - Maximum number of history entries to keep (0 = unlimited)
     * @param voltAgentExporter - Optional exporter for telemetry
     */
    constructor(agentId: string, memoryManager: MemoryManager, maxEntries?: number, voltAgentExporter?: VoltAgentExporter, logger?: Logger);
    /**
     * Set the agent ID for this history manager
     */
    setAgentId(agentId: string): void;
    /**
     * Sets the VoltAgentExporter for this history manager instance.
     * This allows the exporter to be set after the HistoryManager is created.
     */
    setExporter(exporter: VoltAgentExporter): void;
    /**
     * Get the VoltAgentExporter instance
     * @returns The VoltAgentExporter instance or undefined if not configured
     */
    getExporter(): VoltAgentExporter | undefined;
    /**
     * Checks if a VoltAgentExporter is configured for this history manager.
     * @returns True if an exporter is configured, false otherwise.
     */
    isExporterConfigured(): boolean;
    /**
     * Queue a history operation for background processing
     * @param operationId Unique identifier for the operation
     * @param operation The async operation to execute
     */
    private queueHistoryOperation;
    /**
     * Add a new history entry
     *
     * @param params - Parameters for adding a history entry
     * @returns The new history entry
     */
    addEntry(params: AddEntryParams): Promise<AgentHistoryEntry>;
    /**
     * Add steps to an existing history entry
     *
     * @param entryId - ID of the entry to update
     * @param steps - Steps to add
     * @returns The updated entry or undefined if not found
     */
    addStepsToEntry(entryId: string, steps: StepWithContent[]): void;
    /**
     * Get history entry by ID
     *
     * @param id - ID of the entry to find
     * @returns The history entry or undefined if not found
     */
    getEntryById(id: string): Promise<AgentHistoryEntry | undefined>;
    /**
     * Get all history entries with optional pagination
     *
     * @returns Object with entries array and pagination info
     */
    getEntries(options?: {
        page?: number;
        limit?: number;
    }): Promise<{
        entries: AgentHistoryEntry[];
        pagination: {
            page: number;
            limit: number;
            total: number;
            totalPages: number;
        };
    }>;
    /**
     * Clear all history entries
     */
    clear(): Promise<void>;
    /**
     * Update an existing history entry
     *
     * @param id - ID of the entry to update
     * @param updates - Partial entry with fields to update
     * @returns The updated entry or undefined if not found
     */
    updateEntry(id: string, updates: Partial<Omit<AgentHistoryEntry, "id" | "timestamp"> & {
        metadata?: Record<string, unknown>;
    }>): void;
    /**
     * Persists a timeline event for a history entry.
     * This is used by the new immutable event system.
     *
     *
     * @param historyId - ID of the history entry
     * @param event - The NewTimelineEvent object to persist
     * @returns A promise that resolves to the updated entry or undefined if an error occurs
     */
    persistTimelineEvent(historyId: string, event: NewTimelineEvent): Promise<AgentHistoryEntry | undefined>;
}

interface ExportAgentHistoryPayload {
    agent_id: string;
    project_id: string;
    history_id: string;
    startTime: string;
    endTime?: string;
    status: string;
    input: Record<string, unknown>;
    output?: Record<string, unknown>;
    error?: Record<string, unknown>;
    usage?: Record<string, unknown>;
    metadata?: Record<string, unknown>;
    steps?: HistoryStep[];
    userId?: string;
    conversationId?: string;
    model?: string;
}
interface ExportTimelineEventPayload {
    history_id: string;
    event_id: string;
    agent_id: string;
    event: NewTimelineEvent;
}
interface AgentHistoryUpdatableFields {
    input?: AgentHistoryEntry["input"];
    output?: string;
    status?: AgentStatus;
    usage?: UsageInfo;
    metadata?: Record<string, unknown>;
    endTime?: string;
}

/**
 * Options for configuring the VoltAgentExporter.
 */
interface VoltAgentExporterOptions {
    /**
     * The base URL for the VoltAgent Edge Functions.
     */
    baseUrl: string;
    /**
     * The public API key for the project, used to identify the project
     * when sending telemetry data.
     */
    publicKey: string;
    /**
     * The client's secret key (obtained once during project creation)
     * used for authenticating requests to the telemetry Edge Functions.
     * This will be sent as 'clientSecretKey' in the request body.
     */
    secretKey: string;
    /**
     * Optional fetch implementation. Defaults to global fetch.
     * Useful for environments where global fetch might not be available or needs to be polyfilled (e.g., some Node.js versions).
     */
    fetch?: typeof fetch;
}

declare class VoltAgentExporter {
    private apiClient;
    readonly publicKey: string;
    private logger;
    /**
     * Internal queue for all telemetry export operations
     * Ensures non-blocking exports that don't interfere with event ordering
     */
    private telemetryQueue;
    constructor(options: VoltAgentExporterOptions);
    /**
     * Exports a single agent history entry.
     * @param historyEntryData - The agent history data to export.
     * @returns A promise that resolves with the response from the telemetry service.
     */
    exportHistoryEntry(historyEntryData: ExportAgentHistoryPayload): Promise<{
        historyEntryId: string;
    }>;
    /**
     * Exports a single agent history entry asynchronously (non-blocking).
     * Queues the export operation to avoid blocking the calling thread.
     * @param historyEntryData - The agent history data to export.
     */
    exportHistoryEntryAsync(historyEntryData: ExportAgentHistoryPayload): void;
    /**
     * Exports a single timeline event.
     * @param timelineEventData - The timeline event data to export.
     * @returns A promise that resolves with the response from the telemetry service.
     */
    exportTimelineEvent(timelineEventData: ExportTimelineEventPayload): Promise<{
        timelineEventId: string;
    }>;
    /**
     * Exports a single timeline event asynchronously (non-blocking).
     * Queues the export operation to avoid blocking the calling thread.
     * @param timelineEventData - The timeline event data to export.
     */
    exportTimelineEventAsync(timelineEventData: ExportTimelineEventPayload): void;
    /**
     * Exports history steps for a specific agent history entry.
     * @param history_id - The ID of the history entry to export steps for.
     * @param steps - The steps data to export.
     * @returns A promise that resolves when the export is complete.
     */
    exportHistorySteps(history_id: string, steps: HistoryStep[]): Promise<void>;
    /**
     * Exports history steps for a specific agent history entry asynchronously (non-blocking).
     * @param history_id - The ID of the history entry to export steps for.
     * @param steps - The steps data to export.
     */
    exportHistoryStepsAsync(history_id: string, steps: HistoryStep[]): void;
    /**
     * Updates specific fields of an agent history entry.
     * @param history_id - The ID of the history entry to update.
     * @param updates - An object containing the fields to update.
     * @returns A promise that resolves when the update is complete.
     */
    updateHistoryEntry(history_id: string, updates: Partial<AgentHistoryUpdatableFields>): Promise<void>;
    /**
     * Updates specific fields of an agent history entry asynchronously (non-blocking).
     * @param history_id - The ID of the history entry to update.
     * @param updates - An object containing the fields to update.
     */
    updateHistoryEntryAsync(history_id: string, updates: Partial<AgentHistoryUpdatableFields>): void;
}

type StreamEventType = StreamEvent["type"];
type StreamEvent = StreamEventTextDelta | StreamEventReasoning | StreamEventSource | StreamEventToolCall | StreamEventToolResult | StreamEventFinish | StreamEventError;
type StreamEventTextDelta = InferStreamEventBase<TextDeltaStreamPart>;
type StreamEventReasoning = InferStreamEventBase<ReasoningStreamPart>;
type StreamEventSource = InferStreamEventBase<SourceStreamPart>;
type StreamEventToolCall = InferStreamEventBase<ToolCallStreamPart>;
type StreamEventToolResult = InferStreamEventBase<ToolResultStreamPart>;
type StreamEventFinish = InferStreamEventBase<FinishStreamPart>;
type StreamEventError = InferStreamEventBase<ErrorStreamPart>;
type InferStreamEventBase<TStreamPart extends StreamPart> = {
    type: TStreamPart["type"];
    data: InferStreamEventData<TStreamPart> | null;
    timestamp: string;
    subAgentId: string;
    subAgentName: string;
};
type InferStreamEventData<TStreamPart extends StreamPart> = Simplify<Omit<TStreamPart, "type" | "subAgentId" | "subAgentName">>;

interface StreamEventForwarderOptions {
    forwarder: (event: StreamEvent) => Promise<void>;
    types: Array<LiteralUnion<StreamEventType, string>> | ReadonlyArray<LiteralUnion<StreamEventType, string>>;
    addSubAgentPrefix?: boolean;
    logger?: Logger;
}
/**
 * Forwards SubAgent events to a stream with optional filtering and prefixing
 * @param event - The SubAgent event to forward
 * @param options - Configuration options for forwarding
 */
declare function streamEventForwarder(event: StreamEvent, options: StreamEventForwarderOptions): Promise<void>;
/**
 * Creates a configured streamEventForwarder function
 * @param options - Configuration options
 * @returns A configured forwarder function
 */
declare function createStreamEventForwarder(options: StreamEventForwarderOptions): (event: StreamEvent) => Promise<void>;

/**
 * Available methods for subagent execution
 */
type SubAgentMethod = "streamText" | "generateText" | "streamObject" | "generateObject";
/**
 * Base configuration for a subagent with specific method and options
 */
interface BaseSubAgentConfig {
    /** The agent to be used as a subagent */
    agent: Agent<any>;
    /** Provider options for the specific method call */
    options?: ProviderOptions;
}
/**
 * Configuration for text-based subagent methods (streamText and generateText)
 */
interface TextSubAgentConfig extends BaseSubAgentConfig {
    /** The method to use when calling the subagent */
    method: "streamText" | "generateText";
    /** Schema for object generation methods (optional for text methods) */
    schema?: z.ZodType;
}
/**
 * Configuration for object-based subagent methods (streamObject and generateObject)
 */
interface ObjectSubAgentConfig extends BaseSubAgentConfig {
    /** The method to use when calling the subagent */
    method: "streamObject" | "generateObject";
    /** Schema for object generation methods (required for object methods) */
    schema: z.ZodType;
}
/**
 * Configuration for a subagent with specific method and options
 * Schema is required for object generation methods (streamObject and generateObject)
 */
type SubAgentConfigObject = TextSubAgentConfig | ObjectSubAgentConfig;
/**
 * Union type for subagent configuration
 * - Direct Agent instance (backward compatibility): defaults to streamText method
 * - SubAgentConfigObject: allows specifying method, schema, and options
 */
type SubAgentConfig = Agent<any> | SubAgentConfigObject;
/**
 * Helper function to create a subagent configuration with specific method and options
 * This provides a convenient API for configuring subagents with different execution methods
 *
 * @param config - The configuration object containing agent, method, and optional schema/options
 * @returns A SubAgentConfigObject that can be used in the Agent constructor
 *
 * @example
 * // Backward compatible - direct agent (uses streamText by default)
 * const supervisorAgent = new Agent({
 *   name: "Supervisor",
 *   instructions: "...",
 *   llm: myLLM,
 *   subAgents: [myAgent] // <- This still works! Uses streamText by default
 * });
 *
 * @example
 * // New API - mixed usage
 * const supervisorAgent = new Agent({
 *   name: "Supervisor",
 *   instructions: "...",
 *   llm: myLLM,
 *   subAgents: [
 *     myAgent, // <- Direct agent, uses streamText
 *     createSubagent({
 *       agent: myAgent,
 *       method: 'generateObject',
 *       schema: z.object({ result: z.string() }) // <- Schema is required for generateObject
 *     })
 *   ]
 * });
 *
 * @example
 * // Create a subagent that uses generateText with custom options
 * createSubagent({
 *   agent: myAgent,
 *   method: 'generateText',
 *   options: { temperature: 0.7, maxTokens: 1000 }
 *   // schema is optional for generateText
 * })
 *
 * @example
 * // Create a subagent that uses streamObject - schema is required
 * createSubagent({
 *   agent: myAgent,
 *   method: 'streamObject',
 *   schema: z.object({
 *     progress: z.number(),
 *     status: z.string()
 *   }),
 *   options: { temperature: 0.2 }
 * })
 */
declare function createSubagent(config: TextSubAgentConfig): TextSubAgentConfig;
declare function createSubagent(config: ObjectSubAgentConfig): ObjectSubAgentConfig;

/**
 * VoltOps Client Type Definitions
 *
 * All types related to VoltOps client functionality including
 * prompt management, telemetry, and API interactions.
 */

/**
 * Reference to a prompt in the VoltOps system
 */
type PromptReference = {
    /** Name of the prompt */
    promptName: string;
    /** Specific version number (takes precedence over label) */
    version?: number;
    /** Label to fetch (e.g., 'latest', 'production', 'staging') */
    label?: string;
    /** Variables to substitute in the template */
    variables?: Record<string, any>;
    /** Per-prompt cache configuration (overrides global settings) */
    promptCache?: {
        enabled?: boolean;
        ttl?: number;
        maxSize?: number;
    };
};
/**
 * Helper interface for prompt operations in agent instructions
 */
type PromptHelper = {
    /** Get prompt content by reference */
    getPrompt: (reference: PromptReference) => Promise<PromptContent>;
};
/**
 * Enhanced dynamic value options with prompts support
 */
interface DynamicValueOptions {
    /** User context map */
    userContext: Map<string | symbol, unknown>;
    /** Prompt helper (available when VoltOpsClient is configured) */
    prompts: PromptHelper;
}
/**
 * Dynamic value type for agent configuration
 */
type DynamicValue<T> = (options: DynamicValueOptions) => Promise<T> | T;
/**
 * VoltOps client configuration options
 */
type VoltOpsClientOptions = {
    /** Base URL of the VoltOps API (default: https://api.voltagent.dev) */
    baseUrl?: string;
    /**
     * Public API key for VoltOps authentication
     *
     * @description Your VoltOps public key used for API authentication and prompt management.
     * This key is safe to use in client-side applications as it only provides read access.
     *
     * @format Should start with `pk_` prefix (e.g., `pk_1234567890abcdef`)
     *
     * @example
     * ```typescript
     * publicKey: process.env.VOLTOPS_PUBLIC_KEY
     * ```
     *
     *
     * @obtain Get your API keys from: https://console.voltagent.dev/settings/projects
     */
    publicKey?: string;
    /**
     * Secret API key for VoltOps authentication
     *
     * @description Your VoltOps secret key used for secure API operations and analytics.
     * This key provides full access to your VoltOps project and should be kept secure.
     *
     * @format Should start with `sk_` prefix (e.g., `sk_abcdef1234567890`)
     *
     * @example
     * ```typescript
     * secretKey: process.env.VOLTOPS_SECRET_KEY
     * ```
     *
     *
     * @obtain Get your API keys from: https://console.voltagent.dev/settings/projects
     */
    secretKey?: string;
    /** Custom fetch implementation (optional) */
    fetch?: typeof fetch;
    /** Enable observability export (default: true) */
    observability?: boolean;
    /** Enable prompt management (default: true) */
    prompts?: boolean;
    /** Optional configuration for prompt caching */
    promptCache?: {
        enabled?: boolean;
        ttl?: number;
        maxSize?: number;
    };
};
/**
 * Cached prompt data for performance optimization
 */
type CachedPrompt = {
    /** Prompt content */
    content: string;
    /** When the prompt was fetched */
    fetchedAt: number;
    /** Time to live in milliseconds */
    ttl: number;
};
/**
 * API response for prompt fetch operations
 * Simplified format matching the desired response structure
 */
type PromptApiResponse = {
    /** Prompt name */
    name: string;
    /** Prompt type */
    type: "text" | "chat";
    /** Prompt content object */
    prompt: PromptContent;
    /** LLM configuration */
    config: {
        model?: string;
        temperature?: number;
        max_tokens?: number;
        top_p?: number;
        frequency_penalty?: number;
        presence_penalty?: number;
        supported_languages?: string[];
        [key: string]: any;
    };
    /** Prompt version number */
    version: number;
    /** Labels array */
    labels: string[];
    /** Tags array */
    tags: string[];
    /** Base prompt ID for tracking */
    prompt_id: string;
    /** PromptVersion ID (the actual entity ID) */
    prompt_version_id: string;
};
/**
 * API client interface for prompt operations
 */
interface PromptApiClient {
    /** Fetch a prompt by reference */
    fetchPrompt(reference: PromptReference): Promise<PromptApiResponse>;
}
/**
 * VoltOps prompt manager interface
 */
interface VoltOpsPromptManager {
    /** Get prompt content by reference */
    getPrompt(reference: PromptReference): Promise<PromptContent>;
    /** Preload prompts for better performance */
    preload(references: PromptReference[]): Promise<void>;
    /** Clear cache */
    clearCache(): void;
    /** Get cache statistics */
    getCacheStats(): {
        size: number;
        entries: string[];
    };
}
/**
 * Main VoltOps client interface
 */
interface VoltOpsClient$1 {
    /** Prompt management functionality */
    prompts?: VoltOpsPromptManager;
    /** Observability exporter (for backward compatibility) */
    observability?: VoltAgentExporter;
    /** Configuration options */
    options: VoltOpsClientOptions & {
        baseUrl: string;
    };
    /** Create a prompt helper for agent instructions */
    createPromptHelper(agentId: string, historyEntryId?: string): PromptHelper;
    /** Backward compatibility methods */
    exportHistoryEntry?: VoltAgentExporter["exportHistoryEntry"];
    exportHistoryEntryAsync?: VoltAgentExporter["exportHistoryEntryAsync"];
    exportTimelineEvent?: VoltAgentExporter["exportTimelineEvent"];
    exportTimelineEventAsync?: VoltAgentExporter["exportTimelineEventAsync"];
}
/**
 * Chat message structure compatible with BaseMessage
 */
type ChatMessage = BaseMessage;
/**
 * Content of a prompt - either text or chat messages
 */
interface PromptContent {
    type: "text" | "chat";
    text?: string;
    messages?: ChatMessage[];
    /**
     * Metadata about the prompt from VoltOps API
     * Available when prompt is fetched from VoltOps
     */
    metadata?: {
        /** Base prompt ID for tracking */
        prompt_id?: string;
        /** Specific PromptVersion ID (critical for analytics) */
        prompt_version_id?: string;
        /** Prompt name */
        name?: string;
        /** Prompt version number */
        version?: number;
        /** Labels array (e.g., 'production', 'staging', 'latest') */
        labels?: string[];
        /** Tags array for categorization */
        tags?: string[];
        /** LLM configuration from prompt */
        config?: {
            model?: string;
            temperature?: number;
            max_tokens?: number;
            top_p?: number;
            frequency_penalty?: number;
            presence_penalty?: number;
            supported_languages?: string[];
            [key: string]: any;
        };
    };
}

interface OnStartHookArgs {
    agent: Agent<any>;
    context: OperationContext;
}
interface OnEndHookArgs {
    /**
     * The conversation ID.
     */
    conversationId: string;
    /**
     * The agent that generated the output.
     */
    agent: Agent<any>;
    /** The standardized successful output object. Undefined on error. */
    output: AgentOperationOutput | undefined;
    /** The error object if the operation failed. Can be either VoltAgentError or AbortError. Undefined on success. */
    error: VoltAgentError | AbortError | undefined;
    /** The complete conversation messages including user input and assistant responses (Vercel AI SDK compatible) */
    context: OperationContext;
}
interface OnHandoffHookArgs {
    agent: Agent<any>;
    source: Agent<any>;
}
interface OnToolStartHookArgs {
    agent: Agent<any>;
    tool: AgentTool;
    context: OperationContext;
}
interface OnToolEndHookArgs {
    agent: Agent<any>;
    tool: AgentTool;
    /** The successful output from the tool. Undefined on error. */
    output: unknown | undefined;
    /** The error if the tool execution failed. Can be either VoltAgentError or AbortError. Undefined on success. */
    error: VoltAgentError | AbortError | undefined;
    context: OperationContext;
}
interface OnPrepareMessagesHookArgs {
    /**
     * The messages that will be sent to the LLM.
     * Modify and return this array to transform the messages.
     */
    messages: BaseMessage[];
    /**
     * The agent instance making the LLM call.
     */
    agent: Agent<any>;
    /**
     * The operation context containing metadata about the current operation.
     */
    context: OperationContext;
}
interface OnPrepareMessagesHookResult {
    /**
     * The transformed messages to send to the LLM.
     * If not provided, the original messages will be used.
     */
    messages?: BaseMessage[];
}
type AgentHookOnStart = (args: OnStartHookArgs) => Promise<void> | void;
type AgentHookOnEnd = (args: OnEndHookArgs) => Promise<void> | void;
type AgentHookOnHandoff = (args: OnHandoffHookArgs) => Promise<void> | void;
type AgentHookOnToolStart = (args: OnToolStartHookArgs) => Promise<void> | void;
type AgentHookOnToolEnd = (args: OnToolEndHookArgs) => Promise<void> | void;
type AgentHookOnPrepareMessages = (args: OnPrepareMessagesHookArgs) => Promise<OnPrepareMessagesHookResult> | OnPrepareMessagesHookResult;
/**
 * Type definition for agent hooks using single argument objects.
 */
type AgentHooks = {
    onStart?: AgentHookOnStart;
    onEnd?: AgentHookOnEnd;
    onHandoff?: AgentHookOnHandoff;
    onToolStart?: AgentHookOnToolStart;
    onToolEnd?: AgentHookOnToolEnd;
    onPrepareMessages?: AgentHookOnPrepareMessages;
};
/**
 * Create hooks from an object literal.
 */
declare function createHooks(hooks?: Partial<AgentHooks>): AgentHooks;

/**
 * Enhanced dynamic value for instructions that supports prompt management
 */
type InstructionsDynamicValue = string | DynamicValue<string | PromptContent>;
/**
 * Enhanced dynamic value for models that supports static or dynamic values
 */
type ModelDynamicValue<T> = T | DynamicValue<T>;
/**
 * Enhanced dynamic value for tools that supports static or dynamic values
 */
type ToolsDynamicValue = (Tool<any, any> | Toolkit)[] | DynamicValue<(Tool<any, any> | Toolkit)[]>;
/**
 * Provider options type for LLM configurations
 */
type ProviderOptions = {
    temperature?: number;
    maxTokens?: number;
    topP?: number;
    frequencyPenalty?: number;
    presencePenalty?: number;
    seed?: number;
    stopSequences?: string[];
    extraOptions?: Record<string, unknown>;
    onStepFinish?: (step: StepWithContent) => Promise<void>;
    onFinish?: (result: unknown) => Promise<void>;
    onError?: (error: unknown) => Promise<void>;
    toolExecutionContext?: ToolExecutionContext;
    [key: string]: unknown;
};
/**
 * Configuration for supervisor agents that have subagents
 */
/**
 * Configuration for forwarding events from subagents to the parent agent's stream
 */
type FullStreamEventForwardingConfig = {
    /**
     * Array of event types to forward from subagents
     * Uses StreamEventType which includes: 'text-delta', 'reasoning', 'source', 'tool-call', 'tool-result', 'finish', 'error'
     * @default ['tool-call', 'tool-result']
     * @example ['tool-call', 'tool-result', 'text-delta', 'reasoning', 'source']
     */
    types?: StreamEventType[];
    /**
     * Whether to add the subagent name as a prefix to tool names in forwarded events
     * @default true
     */
    addSubAgentPrefix?: boolean;
};
type SupervisorConfig = {
    /**
     * Complete custom system message for the supervisor agent
     * If provided, this completely replaces the default template
     * Only agents memory section will be appended if includeAgentsMemory is true
     */
    systemMessage?: string;
    /**
     * Whether to include agents memory in the supervisor system message
     * @default true
     */
    includeAgentsMemory?: boolean;
    /**
     * Additional custom guidelines for the supervisor agent
     */
    customGuidelines?: string[];
    /**
     * Configuration for forwarding events from subagents to the parent agent's full stream
     * Controls which event types are forwarded and how they are formatted
     * @default { types: ['tool-call', 'tool-result'], addSubAgentPrefix: true }
     */
    fullStreamEventForwarding?: FullStreamEventForwardingConfig;
    /**
     * Whether to throw an exception when a subagent stream encounters an error
     * If true, stream errors will cause the handoff to throw an exception
     * If false, errors will be captured and returned in the result
     * @default false
     */
    throwOnStreamError?: boolean;
    /**
     * Whether to include error message in the result when no text content was produced
     * Only applies when throwOnStreamError is false
     * If true, the error message will be included in the result field
     * If false, the result will be empty but status will still be 'error'
     * @default true
     */
    includeErrorInEmptyResponse?: boolean;
};
/**
 * Agent configuration options
 */
type AgentOptions = {
    /**
     * Unique identifier for the agent
     * If not provided, a UUID will be generated
     */
    id?: string;
    /**
     * Agent name
     */
    name: string;
    /**
     * Agent purpose. This is the purpose of the agent, that will be used to generate the system message for the supervisor agent, if not provided, the agent will use the `instructions` field to generate the system message.
     *
     * @example 'An agent for customer support'
     */
    purpose?: string;
    /**
     * Memory storage for the agent (optional)
     * Set to false to explicitly disable memory
     */
    memory?: Memory | false;
    /**
     * Memory options for the agent
     */
    memoryOptions?: MemoryOptions;
    /**
     * Memory instance for storing execution history and telemetry.
     * If not provided, defaults to LibSQLStorage.
     * Use InMemoryStorage for environments without filesystem access (e.g., AWS Lambda).
     * @since 0.1.55
     */
    historyMemory?: Memory;
    /**
     * Tools and/or Toolkits that the agent can use
     * Can be static or dynamic based on user context
     */
    tools?: ToolsDynamicValue;
    /**
     * Maximum number of steps (turns) the agent can take before stopping
     * This overrides any supervisor config maxSteps setting
     */
    maxSteps?: number;
    /**
     * Optional user-defined context to be passed around
     */
    userContext?: UserContext;
    /**
     * @deprecated Use `voltOpsClient` instead. Will be removed in a future version.
     *
     * Telemetry exporter for the agent - DEPRECATED
     *
     *  MIGRATION REQUIRED:
     *  OLD: telemetryExporter: new VoltAgentExporter({ ... })
     *  NEW: voltOpsClient: new VoltOpsClient({ publicKey: "...", secretKey: "..." })
     *
     *  Migration guide: https://voltagent.dev/docs/observability/developer-console/#migration-guide-from-telemetryexporter-to-voltopsclient
     *
     *  Benefits: Observability + prompt management + dynamic prompts from console
     */
    telemetryExporter?: VoltAgentExporter;
    /**
     * Sub-agents that this agent can delegate tasks to
     */
    subAgents?: SubAgentConfig[];
    /**
     * Configuration for supervisor behavior when subAgents are present
     */
    supervisorConfig?: SupervisorConfig;
    /**
     * Logger instance to use for this agent
     * If not provided, will use the global logger or create a default one
     */
    logger?: Logger;
} & ({
    /**
     * @deprecated Use `instructions` instead.
     * Agent description (deprecated, use instructions)
     */
    description: string;
    /**
     * Agent instructions. This is the preferred field.
     * Can be static or dynamic based on user context.
     * Enhanced to support prompt management via helper functions.
     */
    instructions?: InstructionsDynamicValue;
} | {
    /**
     * @deprecated Use `instructions` instead.
     * Agent description (deprecated, use instructions)
     */
    description?: undefined;
    /**
     * Agent instructions. This is the preferred field.
     * Required if description is not provided.
     * Can be static or dynamic based on user context.
     * Enhanced to support prompt management via helper functions.
     */
    instructions: InstructionsDynamicValue;
});
/**
 * System message response with optional prompt metadata
 */
interface SystemMessageResponse {
    systemMessages: BaseMessage | BaseMessage[];
    promptMetadata?: {
        /** Base prompt ID for tracking */
        prompt_id?: string;
        /** PromptVersion ID (the actual entity ID) */
        prompt_version_id?: string;
        name?: string;
        version?: number;
        labels?: string[];
        tags?: string[];
        config?: {
            model?: string;
            temperature?: number;
            [key: string]: any;
        };
    };
    isDynamicInstructions?: boolean;
}
/**
 * Provider instance type helper
 */
type ProviderInstance<T> = T extends {
    llm: infer P;
} ? P : never;
/**
 * Model type helper
 */
type ModelType<T> = T extends {
    llm: LLMProvider<any>;
} ? Parameters<T["llm"]["generateText"]>[0]["model"] : never;
/**
 * Infer generate text response type
 */
type InferGenerateTextResponseFromProvider<TProvider extends {
    llm: LLMProvider<any>;
}> = ProviderTextResponse<InferOriginalResponseFromProvider<TProvider, "generateText">>;
/**
 * Infer stream text response type
 */
type InferStreamTextResponseFromProvider<TProvider extends {
    llm: LLMProvider<any>;
}> = ProviderTextStreamResponse<InferOriginalResponseFromProvider<TProvider, "streamText">>;
/**
 * Infer generate object response type
 */
type InferGenerateObjectResponseFromProvider<TProvider extends {
    llm: LLMProvider<any>;
}, TSchema extends z.ZodType> = ProviderObjectResponse<InferOriginalResponseFromProvider<TProvider, "generateObject">, z.infer<TSchema>>;
/**
 * Infer stream object response type
 */
type InferStreamObjectResponseFromProvider<TProvider extends {
    llm: LLMProvider<any>;
}, TSchema extends z.ZodType> = ProviderObjectStreamResponse<InferOriginalResponseFromProvider<TProvider, "streamObject">, z.infer<TSchema>>;
/**
 * Common generate options - internal version that includes historyEntryId
 * Not exposed directly to users
 */
interface CommonGenerateOptions {
    provider?: ProviderOptions;
    conversationId?: string;
    userId?: string;
    contextLimit?: number;
    tools?: BaseTool[];
    maxSteps?: number;
    abortController?: AbortController;
    /**
     * @deprecated Use abortController instead. This field will be removed in a future version.
     * Signal for aborting the operation
     */
    signal?: AbortSignal;
    historyEntryId?: string;
    operationContext?: OperationContext;
    userContext?: UserContext;
    hooks?: AgentHooks;
}
/**
 * Public-facing generate options for external users
 * Omits internal implementation details like historyEntryId and operationContext
 */
type PublicGenerateOptions = Omit<CommonGenerateOptions, "historyEntryId" | "operationContext">;
/**
 * Agent status information
 */
type AgentStatus = "idle" | "working" | "error" | "completed" | "cancelled";
/**
 * Tool call definition
 */
type ToolCall$1 = {
    id: string;
    type: "function";
    function: {
        name: string;
        arguments: string;
    };
};
/**
 * Model tool call format
 */
type ModelToolCall = {
    type: "tool-call";
    toolCallId: string;
    toolName: string;
    args: Record<string, unknown>;
};
/**
 * Agent response format
 */
type AgentResponse = {
    /**
     * Response content
     */
    content: string;
    /**
     * Tool calls made by the model (if any)
     */
    toolCalls?: ToolCall$1[];
    /**
     * Additional metadata
     */
    metadata: {
        agentId: string;
        agentName: string;
        [key: string]: unknown;
    };
};
/**
 * Agent handoff options
 */
type AgentHandoffOptions = {
    /**
     * The task description to be handed off
     */
    task: string;
    /**
     * The target agent to hand off to
     */
    targetAgent: any;
    /**
     * The source agent that is handing off the task
     * Used for hooks and tracking the chain of delegation
     */
    sourceAgent?: any;
    /**
     * Additional context to provide to the target agent
     */
    context?: Record<string, unknown>;
    /**
     * The conversation ID to use for the handoff
     * If not provided, a new conversation ID will be generated
     */
    conversationId?: string;
    /**
     * The user ID to use for the handoff
     * This will be passed to the target agent's generateText method
     */
    userId?: string;
    /**
     * Shared context messages to pass to the target agent
     * These messages provide conversation history context
     */
    sharedContext?: BaseMessage[];
    /**
     * Parent agent ID
     */
    parentAgentId?: string;
    /**
     * Parent history entry ID
     */
    parentHistoryEntryId?: string;
    /**
     * Optional real-time event forwarder function
     * Used to forward SubAgent events to parent stream in real-time
     */
    forwardEvent?: (event: StreamEvent) => Promise<void>;
    /**
     * Parent's operation context to merge SubAgent steps into
     */
    parentOperationContext?: OperationContext;
    /**
     * AbortSignal to cancel the handoff operation
     */
    signal?: AbortSignal;
    /**
     * Maximum number of steps for the subagent (inherited from parent or API call)
     * If not provided, subagent will use its own maxSteps calculation
     */
    maxSteps?: number;
};
/**
 * Result of a handoff to another agent
 */
interface AgentHandoffResult {
    /**
     * Result text from the agent
     */
    result: string;
    /**
     * Conversation ID used for the interaction
     */
    conversationId: string;
    /**
     * Messages exchanged during the handoff
     */
    messages: BaseMessage[];
    /**
     * Status of the handoff operation
     */
    status?: "success" | "error";
    /**
     * Error information if the handoff failed
     */
    error?: Error | string;
    /**
     * Stream events captured from sub-agent for forwarding to parent
     */
    streamEvents?: Array<{
        type: string;
        data: any;
        timestamp: string;
        subAgentId: string;
        subAgentName: string;
    }>;
}
/**
 * Context for a specific agent operation (e.g., one generateText call)
 */
type OperationContext = {
    /** Unique identifier for the operation (maps to historyEntryId) */
    readonly operationId: string;
    /** User-managed context map for this specific operation */
    readonly userContext: Map<string | symbol, any>;
    /** System-managed context map for internal operation tracking */
    readonly systemContext: Map<string | symbol, any>;
    /** The history entry associated with this operation */
    historyEntry: AgentHistoryEntry;
    /** Whether this operation is still active */
    isActive: boolean;
    /** Parent agent ID if part of a delegation chain */
    parentAgentId?: string;
    /** Parent history entry ID if part of a delegation chain */
    parentHistoryEntryId?: string;
    /** The root OpenTelemetry span for this operation */
    otelSpan?: Span;
    /** Execution-scoped logger with full context (userId, conversationId, executionId) */
    logger: Logger;
    /** Map to store active OpenTelemetry spans for tool calls within this operation */
    toolSpans?: Map<string, Span>;
    /** Conversation steps for building full message history including tool calls/results */
    conversationSteps?: StepWithContent[];
    /** AbortController for cancelling the operation and accessing the signal */
    abortController?: AbortController;
    /**
     * @deprecated Use abortController.signal instead. This field will be removed in a future version.
     * AbortSignal for cancelling the operation
     */
    signal?: AbortSignal;
    /** Cancellation error to be thrown when operation is aborted */
    cancellationError?: AbortError;
};
/**
 * Tool execution context passed to tool.execute method
 * Includes operation-specific context and necessary identifiers
 * Extends base ToolExecuteOptions.
 */
type ToolExecutionContext = ToolExecuteOptions & {
    /** ID of the agent executing the tool */
    agentId: string;
    /** History ID associated with the current operation */
    historyEntryId: string;
};
/**
 * Specific information related to a tool execution error.
 */
interface ToolErrorInfo {
    /** The unique identifier of the tool call. */
    toolCallId: string;
    /** The name of the tool that was executed. */
    toolName: string;
    /** The original error thrown directly by the tool during execution (if available). */
    toolExecutionError?: unknown;
    /** The arguments passed to the tool when the error occurred (for debugging). */
    toolArguments?: unknown;
}
/**
 * Standardized error structure for Voltagent agent operations.
 * Providers should wrap their specific errors in this structure before
 * passing them to onError callbacks.
 */
interface VoltAgentError {
    /** A clear, human-readable error message. This could be a general message or derived from toolError info. */
    message: string;
    /** The original error object thrown by the provider or underlying system (if available). */
    originalError?: unknown;
    /** Optional error code or identifier from the provider. */
    code?: string | number;
    /** Additional metadata related to the error (e.g., retry info, request ID). */
    metadata?: Record<string, any>;
    /** Information about the step or stage where the error occurred (optional, e.g., 'llm_request', 'tool_execution', 'response_parsing'). */
    stage?: string;
    /** If the error occurred during tool execution, this field contains the relevant details. Otherwise, it's undefined. */
    toolError?: ToolErrorInfo;
}
/**
 * Error thrown when an operation is aborted via AbortController
 */
interface AbortError extends Error {
    name: "AbortError";
    /** The reason passed to abort() method */
    reason?: unknown;
}
/**
 * Type guard to check if an error is an AbortError
 */
declare function isAbortError(error: unknown): error is AbortError;
/**
 * Type guard to check if an error is a VoltAgentError
 */
declare function isVoltAgentError(error: unknown): error is VoltAgentError;
/**
 * Type for onError callbacks in streaming operations.
 * Providers must pass an error conforming to the VoltAgentError structure.
 */
type StreamOnErrorCallback = (error: VoltAgentError) => Promise<void> | void;
type UserContext = Map<string | symbol, unknown>;
/**
 * Standardized object structure passed to the onFinish callback
 * when streamText completes successfully.
 */
interface StreamTextFinishResult {
    /** The final, consolidated text output from the stream. */
    text: string;
    /** Token usage information (if available). */
    usage?: UsageInfo;
    /** The reason the stream finished (if available, e.g., 'stop', 'length', 'tool-calls'). */
    finishReason?: string;
    /** The original completion response object from the provider (if available). */
    providerResponse?: unknown;
    /** Any warnings generated during the completion (if available). */
    warnings?: unknown[];
    /** User context containing any custom metadata from the operation. */
    userContext?: UserContext;
}
/**
 * Type for the onFinish callback function for streamText.
 */
type StreamTextOnFinishCallback = (result: StreamTextFinishResult) => Promise<void> | void;
/**
 * Standardized object structure passed to the onFinish callback
 * when streamObject completes successfully.
 * @template TObject The expected type of the fully formed object.
 */
interface StreamObjectFinishResult<TObject> {
    /** The final, fully formed object from the stream. */
    object: TObject;
    /** Token usage information (if available). */
    usage?: UsageInfo;
    /** The original completion response object from the provider (if available). */
    providerResponse?: unknown;
    /** Any warnings generated during the completion (if available). */
    warnings?: unknown[];
    /** The reason the stream finished (if available). Although less common for object streams. */
    finishReason?: string;
    /** User context containing any custom metadata from the operation. */
    userContext?: UserContext;
}
/**
 * Type for the onFinish callback function for streamObject.
 * @template TObject The expected type of the fully formed object.
 */
type StreamObjectOnFinishCallback<TObject> = (result: StreamObjectFinishResult<TObject>) => Promise<void> | void;
/**
 * Standardized success result structure for generateText.
 */
interface StandardizedTextResult {
    /** The generated text. */
    text: string;
    /** Token usage information (if available). */
    usage?: UsageInfo;
    /** Original provider response (if needed). */
    providerResponse?: unknown;
    /** Finish reason (if available from provider). */
    finishReason?: string;
    /** Warnings (if available from provider). */
    warnings?: unknown[];
    /** User context containing any custom metadata from the operation. */
    userContext?: UserContext;
}
/**
 * Standardized success result structure for generateObject.
 * @template TObject The expected type of the generated object.
 */
interface StandardizedObjectResult<TObject> {
    /** The generated object. */
    object: TObject;
    /** Token usage information (if available). */
    usage?: UsageInfo;
    /** Original provider response (if needed). */
    providerResponse?: unknown;
    /** Finish reason (if available from provider). */
    finishReason?: string;
    /** Warnings (if available from provider). */
    warnings?: unknown[];
    /** User context containing any custom metadata from the operation. */
    userContext?: UserContext;
}
/**
 * Unified output type for the onEnd hook, representing the successful result
 * of any core agent operation. Use 'type guarding' or check specific fields
 * within the hook implementation to determine the concrete type.
 * Object types are generalized to 'unknown' here for the union.
 */
type AgentOperationOutput = StandardizedTextResult | StreamTextFinishResult | StandardizedObjectResult<unknown> | StreamObjectFinishResult<unknown>;
type InferResponseFromProvider<TProvider extends {
    llm: LLMProvider<any>;
}, TMethod extends "generateText" | "streamText" | "generateObject" | "streamObject"> = Awaited<ReturnType<TProvider["llm"][TMethod]>>;
type InferOriginalResponseFromProvider<TProvider extends {
    llm: LLMProvider<any>;
}, TMethod extends "generateText" | "streamText" | "generateObject" | "streamObject"> = InferResponseFromProvider<TProvider, TMethod>["provider"];
type GenerateTextResponse<TProvider extends {
    llm: LLMProvider<any>;
}> = InferGenerateTextResponseFromProvider<TProvider> & {
    userContext: Map<string | symbol, unknown>;
};
type StreamTextResponse<TProvider extends {
    llm: LLMProvider<any>;
}> = InferStreamTextResponseFromProvider<TProvider> & {
    userContext?: UserContext;
};
type GenerateObjectResponse<TProvider extends {
    llm: LLMProvider<any>;
}, TSchema extends z.ZodType> = InferGenerateObjectResponseFromProvider<TProvider, TSchema> & {
    userContext: Map<string | symbol, unknown>;
};
type StreamObjectResponse<TProvider extends {
    llm: LLMProvider<any>;
}, TSchema extends z.ZodType> = InferStreamObjectResponseFromProvider<TProvider, TSchema> & {
    userContext?: UserContext;
};

/**
 * Token usage information
 */
type UsageInfo = {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    cachedInputTokens?: number;
    reasoningTokens?: number;
};
/**
 * Base provider response type
 */
type ProviderResponse<TOriginalResponse> = {
    /**
     * Original response from the provider
     */
    provider: TOriginalResponse;
};
/**
 * Response type for text generation operations
 */
type ProviderTextResponse<TOriginalResponse> = {
    /**
     * Original response from the provider
     */
    provider: TOriginalResponse;
    /**
     * Text response content
     */
    text: string;
    /**
     * Token usage information
     */
    usage?: UsageInfo;
    /**
     * Tool calls in the response (if applicable)
     */
    toolCalls?: any[];
    /**
     * Tool results in the response (if applicable)
     */
    toolResults?: any[];
    /**
     * Finish reason (if applicable)
     */
    finishReason?: string;
    /**
     * Reasoning text from the model (if applicable)
     */
    reasoning?: string;
    /**
     * Warnings from the model provider (if applicable)
     */
    warnings?: any[];
};
type TextDeltaStreamPart = {
    type: "text-delta";
    textDelta: string;
    subAgentId?: string;
    subAgentName?: string;
};
type ReasoningStreamPart = {
    type: "reasoning";
    reasoning: string;
    subAgentId?: string;
    subAgentName?: string;
};
type SourceStreamPart = {
    type: "source";
    source: string;
    subAgentId?: string;
    subAgentName?: string;
};
type ToolCallStreamPart = {
    type: "tool-call";
    toolCallId: string;
    toolName: string;
    args: Record<string, any>;
    subAgentId?: string;
    subAgentName?: string;
};
type ToolResultStreamPart = {
    type: "tool-result";
    toolCallId: string;
    toolName: string;
    result: any;
    subAgentId?: string;
    subAgentName?: string;
};
type FinishStreamPart = {
    type: "finish";
    finishReason?: string;
    usage?: UsageInfo;
    subAgentId?: string;
    subAgentName?: string;
};
type ErrorStreamPart = {
    type: "error";
    error: Error;
    subAgentId?: string;
    subAgentName?: string;
};
type StreamPart = TextDeltaStreamPart | ReasoningStreamPart | SourceStreamPart | ToolCallStreamPart | ToolResultStreamPart | FinishStreamPart | ErrorStreamPart;
/**
 * Response type for text streaming operations
 */
type ProviderTextStreamResponse<TOriginalResponse> = {
    /**
     * Original response from the provider
     */
    provider: TOriginalResponse;
    /**
     * Text stream for consuming the response
     */
    textStream: AsyncIterableStream<string>;
    /**
     * Full stream for consuming all events (text, tool calls, reasoning, etc.)
     * This provides access to the complete stream of events from the provider
     * Optional - only available in providers that support it
     */
    fullStream?: AsyncIterable<StreamPart>;
    /**
     * The full generated text.
     * Resolved when the response is finished.
     * Optional - only available in providers that support it.
     */
    text?: Promise<string>;
    /**
     * The reason why generation stopped.
     * Resolved when the response is finished.
     * Optional - only available in providers that support it.
     */
    finishReason?: Promise<string>;
    /**
     * Token usage information.
     * Resolved when the response is finished.
     * Optional - only available in providers that support it.
     */
    usage?: Promise<UsageInfo>;
    /**
     * Model's reasoning text (if available).
     * Resolved when the response is finished.
     * Optional - only available in providers that support it.
     */
    reasoning?: Promise<string | undefined>;
};
/**
 * Response type for object generation operations
 */
type ProviderObjectResponse<TOriginalResponse, TObject> = {
    /**
     * Original response from the provider
     */
    provider: TOriginalResponse;
    /**
     * Generated object
     */
    object: TObject;
    /**
     * Token usage information
     */
    usage?: UsageInfo;
    /**
     * Finish reason (if applicable)
     */
    finishReason?: string;
    /**
     * Warnings from the model provider (if applicable)
     */
    warnings?: any[];
};
/**
 * Response type for object streaming operations
 */
type ProviderObjectStreamResponse<TOriginalResponse, TObject> = {
    /**
     * Original response from the provider
     */
    provider: TOriginalResponse;
    /**
     * Object stream for consuming partial objects
     */
    objectStream: AsyncIterableStream<Partial<TObject>>;
    /**
     * The generated object (typed according to the schema).
     * Resolved when the response is finished.
     * Optional - only available in providers that support it.
     */
    object?: Promise<TObject>;
    /**
     * Token usage information.
     * Resolved when the response is finished.
     * Optional - only available in providers that support it.
     */
    usage?: Promise<UsageInfo>;
    /**
     * Warnings from the model provider.
     * Resolved when the response is finished.
     * Optional - only available in providers that support it.
     */
    warnings?: Promise<any[] | undefined>;
};
/**
 * Data content type for binary data
 */
type DataContent = string | Uint8Array | ArrayBuffer | Buffer;
/**
 * Text part of a message
 */
type TextPart = {
    type: "text";
    /**
     * The text content
     */
    text: string;
};
/**
 * Image part of a message
 */
type ImagePart = {
    type: "image";
    /**
     * Image data. Can either be:
     * - data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer
     * - URL: a URL that points to the image
     */
    image: DataContent | URL;
    /**
     * Optional mime type of the image
     */
    mimeType?: string;
};
/**
 * File part of a message
 */
type FilePart = {
    type: "file";
    /**
     * File data. Can either be:
     * - data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer
     * - URL: a URL that points to the file
     */
    data: DataContent | URL;
    /**
     * Optional filename of the file
     */
    filename?: string;
    /**
     * Mime type of the file
     */
    mimeType: string;
};
/**
 * Message content can be either a string or an array of parts
 */
type MessageContent = string | Array<TextPart | ImagePart | FilePart>;
/**
 * Message role types
 */
type MessageRole = "user" | "assistant" | "system" | "tool";
/**
 * Base message type
 */
type BaseMessage = {
    role: MessageRole;
    content: MessageContent;
};
type ToolSchema = z.ZodType;
type ToolExecuteOptions = {
    /**
     * Optional AbortController for cancelling the execution and accessing the signal
     */
    abortController?: AbortController;
    /**
     * @deprecated Use abortController.signal instead. This field will be removed in a future version.
     * Optional AbortSignal to abort the execution
     */
    signal?: AbortSignal;
    /**
     * The operation context associated with the agent invocation triggering this tool execution.
     * Provides access to operation-specific state like userContext.
     * The context includes a logger with full execution context (userId, conversationId, executionId).
     */
    operationContext?: OperationContext;
    /**
     * Additional options can be added in the future
     */
    [key: string]: any;
};
type BaseTool = Tool<any, any>;
type BaseToolCall = {
    name: string;
    arguments: Record<string, any>;
};
type ProviderParams<T> = T extends {
    doGenerate: (options: infer P) => any;
} ? P extends {
    messages: any;
    model: any;
} ? Omit<P, "messages" | "model" | "tools" | "maxSteps" | "schema"> : Record<string, never> : Record<string, never>;
type BaseLLMOptions<TModel, TProvider> = {
    messages: BaseMessage[];
    model: TModel;
    provider?: ProviderParams<TProvider>;
};
interface StepWithContent {
    id: string;
    type: "text" | "tool_call" | "tool_result";
    content: string;
    role: MessageRole;
    name?: string;
    arguments?: Record<string, any>;
    result?: any;
    usage?: UsageInfo;
    subAgentId?: string;
    subAgentName?: string;
}
type StepFinishCallback = (step: StepWithContent) => void | Promise<void>;
type StepChunkCallback = (chunk: any) => void | Promise<void>;
interface GenerateTextOptions<TModel> {
    messages: BaseMessage[];
    model: TModel;
    tools?: BaseTool[];
    maxSteps?: number;
    provider?: ProviderOptions;
    onStepFinish?: StepFinishCallback;
    signal?: AbortSignal;
    toolExecutionContext?: ToolExecutionContext;
}
interface StreamTextOptions<TModel> {
    messages: BaseMessage[];
    model: TModel;
    tools?: BaseTool[];
    maxSteps?: number;
    provider?: ProviderOptions;
    onStepFinish?: StepFinishCallback;
    onChunk?: StepChunkCallback;
    onFinish?: StreamTextOnFinishCallback;
    onError?: StreamOnErrorCallback;
    signal?: AbortSignal;
    toolExecutionContext?: ToolExecutionContext;
}
interface GenerateObjectOptions<TModel, TSchema extends z.ZodType> {
    messages: BaseMessage[];
    model: TModel;
    schema: TSchema;
    provider?: ProviderOptions;
    onStepFinish?: StepFinishCallback;
    signal?: AbortSignal;
    toolExecutionContext?: ToolExecutionContext;
}
interface StreamObjectOptions<TModel, TSchema extends z.ZodType> {
    messages: BaseMessage[];
    model: TModel;
    schema: TSchema;
    provider?: ProviderOptions;
    onStepFinish?: StepFinishCallback;
    onFinish?: StreamObjectOnFinishCallback<z.infer<TSchema>>;
    onError?: StreamOnErrorCallback;
    signal?: AbortSignal;
    toolExecutionContext?: ToolExecutionContext;
}
type InferStreamResponse<T> = T extends {
    streamText: (...args: any[]) => Promise<infer R>;
} ? R : unknown;
type InferMessage<T> = T extends {
    toMessage: (message: BaseMessage) => infer R;
} ? R : unknown;
type InferTool<T> = T extends {
    toTool?: (tool: BaseTool) => infer R;
} ? R : unknown;
type InferModel<T> = T extends {
    model: infer R;
} ? R : unknown;
type InferGenerateTextResponse<T> = T extends {
    generateText: (...args: any[]) => Promise<infer R>;
} ? R : unknown;
type InferGenerateObjectResponse<T> = T extends {
    generateObject: (...args: any[]) => Promise<infer R>;
} ? R : unknown;
type InferProviderParams<T> = T extends {
    generateText: (options: infer P) => any;
} ? P extends {
    messages: any;
    model: any;
    tools?: any;
    maxSteps?: any;
    schema?: any;
} ? Omit<P, "messages" | "model" | "tools" | "maxSteps" | "schema"> : Record<string, never> : Record<string, never>;
type LLMProvider<TProvider> = {
    /**
     * Generates a text response based on the provided options.
     * Implementers should catch underlying SDK/API errors and throw a VoltAgentError.
     * @throws {VoltAgentError} If an error occurs during generation.
     */
    generateText(options: GenerateTextOptions<InferModel<TProvider>>): Promise<ProviderTextResponse<InferGenerateTextResponse<TProvider>>>;
    /**
     * Streams a text response based on the provided options.
     * Implementers should catch underlying SDK/API errors and throw a VoltAgentError.
     * @throws {VoltAgentError} If an error occurs during streaming.
     */
    streamText(options: StreamTextOptions<InferModel<TProvider>>): Promise<ProviderTextStreamResponse<InferStreamResponse<TProvider>>>;
    /**
     * Generates a structured object response based on the provided options and schema.
     * Implementers should catch underlying SDK/API errors and throw a VoltAgentError.
     * @throws {VoltAgentError} If an error occurs during generation.
     */
    generateObject<TSchema extends z.ZodType>(options: GenerateObjectOptions<InferModel<TProvider>, TSchema>): Promise<ProviderObjectResponse<InferGenerateObjectResponse<TProvider>, z.infer<TSchema>>>;
    /**
     * Streams a structured object response based on the provided options and schema.
     * Implementers should catch underlying SDK/API errors and throw a VoltAgentError.
     * @throws {VoltAgentError} If an error occurs during streaming.
     */
    streamObject<TSchema extends z.ZodType>(options: StreamObjectOptions<InferModel<TProvider>, TSchema>): Promise<ProviderObjectStreamResponse<InferStreamResponse<TProvider>, z.infer<TSchema>>>;
    /**
     * Converts a base message to a provider-specific message.
     * @param message The base message to convert.
     * @returns The provider-specific message.
     */
    toMessage(message: BaseMessage): InferMessage<TProvider>;
    /**
     * Optional tool conversion method.
     */
    toTool?: (tool: BaseTool) => InferTool<TProvider>;
    /**
     * Returns a string representation of the model identifier.
     * @param model The model object/identifier specific to this provider.
     * @returns The string name of the model.
     */
    getModelIdentifier(model: InferModel<TProvider>): string;
};

/**
 * Event statuses
 */
type EventStatus = "idle" | "working" | "completed" | "error";
/**
 * Standard event data interface
 */
interface StandardEventData {
    status: EventStatus;
    timestamp: string;
    input?: unknown;
    output?: unknown;
    error?: unknown;
    errorMessage?: string;
    metadata?: Record<string, unknown>;
    sourceAgentId?: string;
    userContext?: Record<string, unknown>;
}
/**
 * Standard timeline event
 */
interface StandardTimelineEvent {
    id: string;
    timestamp: Date;
    name: string;
    data: StandardEventData;
    agentId: string;
    historyId: string;
}
/**
 * Defines the main category of a TimelineEvent.
 */
type TimelineEventCoreType = "agent" | "tool" | "memory" | "retriever" | "workflow" | "workflow-step";
/**
 * Defines the operational status of a TimelineEvent.
 * 'idle' is added for consistency with frontend initial states.
 * 'suspended' is added for workflow suspension state.
 */
type TimelineEventCoreStatus = "idle" | "running" | "completed" | "error" | "suspended";
/**
 * Defines the severity level of a TimelineEvent.
 */
type TimelineEventCoreLevel = "DEBUG" | "INFO" | "WARNING" | "ERROR" | "CRITICAL";
/**
 * Usage information for tracking resource consumption
 */
interface Usage {
    promptTokens?: number;
    completionTokens?: number;
    totalTokens?: number;
    input?: number;
    output?: number;
    total?: number;
    unit?: "TOKENS" | "CHARACTERS" | "MILLISECONDS" | "SECONDS" | "IMAGES";
    inputCost?: number;
    outputCost?: number;
    totalCost?: number;
    [key: string]: unknown;
}
/**
 * Base metadata interface with common fields for all timeline events
 */
interface BaseEventMetadata {
    displayName?: string;
    id: string;
    agentId?: string;
    userContext?: Record<string, unknown>;
}
type AgentStartEventMetadata = {
    instructions?: string;
    modelParameters?: {
        model?: string;
        temperature?: number;
        maxTokens?: number;
        topP?: number;
        frequencyPenalty?: number;
        presencePenalty?: number;
        stop?: string[];
        system?: string;
        toolChoice?: string;
        maxSteps?: number;
    };
    systemPrompt?: string | BaseMessage | BaseMessage[];
    messages?: BaseMessage[];
} & Record<string, unknown>;
interface AgentSuccessEventMetadata extends BaseEventMetadata {
    usage?: Usage;
    modelParameters?: {
        model?: string;
        temperature?: number;
        maxTokens?: number;
        topP?: number;
        frequencyPenalty?: number;
        presencePenalty?: number;
        stop?: string[];
        system?: string;
        toolChoice?: string;
        maxSteps?: number;
    };
}
interface MemoryEventMetadata extends BaseEventMetadata {
    type?: string;
}
interface WorkflowEventMetadata extends BaseEventMetadata {
    workflowId: string;
    workflowName: string;
    executionId: string;
    currentStep?: number;
    totalSteps: number;
    eventSequence?: number;
}
interface WorkflowStepEventMetadata extends BaseEventMetadata {
    workflowId: string;
    workflowName: string;
    executionId: string;
    stepIndex: number;
    stepType: "agent" | "func" | "conditional-when" | "parallel-all" | "parallel-race";
    stepName: string;
    agentId?: string;
    agentName?: string;
    parallelIndex?: number;
    parallelParentEventId?: string;
    isSkipped?: boolean;
    eventSequence?: number;
    stepFunction?: string;
    taskString?: string;
}
/**
 * Base interface for all Timeline Events.
 * The `metadata` field will be typed more specifically using a discriminated union based on `type` and `name`.
 */
interface BaseTimelineEvent<M = BaseEventMetadata | null> {
    id: string;
    name: string;
    type: TimelineEventCoreType;
    startTime: string;
    endTime?: string | null;
    status?: TimelineEventCoreStatus;
    statusMessage?: {
        message: string;
        stack?: string;
        code?: string | number;
        [key: string]: unknown;
    };
    level?: TimelineEventCoreLevel;
    input?: Record<string, unknown> | null;
    output?: Record<string, unknown> | null;
    metadata: M;
    version?: string | null;
    parentEventId?: string | null;
    traceId: string;
    tags?: string[] | null;
}
type ToolStartEvent = BaseTimelineEvent<BaseEventMetadata> & {
    name: "tool:start";
    type: "tool";
};
type ToolSuccessEvent = BaseTimelineEvent<BaseEventMetadata> & {
    name: "tool:success";
    type: "tool";
};
type ToolErrorEvent = BaseTimelineEvent<BaseEventMetadata> & {
    name: "tool:error";
    type: "tool";
    status: "error";
    level: "ERROR" | "CRITICAL";
};
type AgentStartEvent = BaseTimelineEvent<AgentStartEventMetadata & BaseEventMetadata> & {
    name: "agent:start";
    type: "agent";
    input: {
        input: string | BaseMessage[];
    };
};
type AgentSuccessEvent = BaseTimelineEvent<AgentSuccessEventMetadata> & {
    name: "agent:success";
    type: "agent";
    status: "completed";
};
type AgentErrorEvent = BaseTimelineEvent<BaseEventMetadata> & {
    name: "agent:error";
    type: "agent";
    status: "error";
    level: "ERROR" | "CRITICAL";
};
type MemoryReadStartEvent = BaseTimelineEvent<MemoryEventMetadata> & {
    name: "memory:read_start";
    type: "memory";
};
type MemoryReadSuccessEvent = BaseTimelineEvent<MemoryEventMetadata> & {
    name: "memory:read_success";
    type: "memory";
    status: "completed";
};
type MemoryReadErrorEvent = BaseTimelineEvent<MemoryEventMetadata> & {
    name: "memory:read_error";
    type: "memory";
    status: "error";
    level: "ERROR" | "CRITICAL";
};
type MemoryWriteStartEvent = BaseTimelineEvent<MemoryEventMetadata> & {
    name: "memory:write_start";
    type: "memory";
};
type MemoryWriteSuccessEvent = BaseTimelineEvent<MemoryEventMetadata> & {
    name: "memory:write_success";
    type: "memory";
    status: "completed";
};
type MemoryWriteErrorEvent = BaseTimelineEvent<MemoryEventMetadata> & {
    name: "memory:write_error";
    type: "memory";
    status: "error";
    level: "ERROR" | "CRITICAL";
};
type RetrieverStartEvent = BaseTimelineEvent<BaseEventMetadata> & {
    name: "retriever:start";
    type: "retriever";
};
type RetrieverSuccessEvent = BaseTimelineEvent<BaseEventMetadata> & {
    name: "retriever:success";
    type: "retriever";
    status: "completed";
};
type RetrieverErrorEvent = BaseTimelineEvent<BaseEventMetadata> & {
    name: "retriever:error";
    type: "retriever";
    status: "error";
    level: "ERROR" | "CRITICAL";
};
type WorkflowStartEvent = BaseTimelineEvent<WorkflowEventMetadata> & {
    name: "workflow:start";
    type: "workflow";
    status: "running";
};
type WorkflowSuccessEvent = BaseTimelineEvent<WorkflowEventMetadata> & {
    name: "workflow:success";
    type: "workflow";
    status: "completed";
};
type WorkflowErrorEvent = BaseTimelineEvent<WorkflowEventMetadata> & {
    name: "workflow:error";
    type: "workflow";
    status: "error";
    level: "ERROR" | "CRITICAL";
};
type WorkflowSuspendEvent = BaseTimelineEvent<WorkflowEventMetadata> & {
    name: "workflow:suspend";
    type: "workflow";
    status: "suspended";
    statusMessage?: {
        reason?: string;
        suspendedAt: string;
        suspendedStepIndex: number;
    };
};
type WorkflowStepStartEvent = BaseTimelineEvent<WorkflowStepEventMetadata> & {
    name: "workflow-step:start";
    type: "workflow-step";
    status: "running";
};
type WorkflowStepSuccessEvent = BaseTimelineEvent<WorkflowStepEventMetadata> & {
    name: "workflow-step:success";
    type: "workflow-step";
    status: "completed";
};
type WorkflowStepErrorEvent = BaseTimelineEvent<WorkflowStepEventMetadata> & {
    name: "workflow-step:error";
    type: "workflow-step";
    status: "error";
    level: "ERROR" | "CRITICAL";
};
type WorkflowStepSuspendEvent = BaseTimelineEvent<WorkflowStepEventMetadata> & {
    name: "workflow-step:suspend";
    type: "workflow-step";
    status: "suspended";
    statusMessage?: {
        reason?: string;
        suspendedAt: string;
    };
};
type AgentTimelineEvent = ToolStartEvent | ToolSuccessEvent | ToolErrorEvent | AgentStartEvent | AgentSuccessEvent | AgentErrorEvent | MemoryReadStartEvent | MemoryReadSuccessEvent | MemoryReadErrorEvent | MemoryWriteStartEvent | MemoryWriteSuccessEvent | MemoryWriteErrorEvent | RetrieverStartEvent | RetrieverSuccessEvent | RetrieverErrorEvent;
type WorkflowTimelineEvent = WorkflowStartEvent | WorkflowSuccessEvent | WorkflowErrorEvent | WorkflowSuspendEvent | WorkflowStepStartEvent | WorkflowStepSuccessEvent | WorkflowStepErrorEvent | WorkflowStepSuspendEvent;
type NewTimelineEvent = AgentTimelineEvent | WorkflowTimelineEvent;

/**
 * Options for configuring the InMemoryStorage
 */
interface InMemoryStorageOptions extends MemoryOptions {
    /**
     * Whether to enable debug logging
     * @default false
     */
    debug?: boolean;
}
/**
 * A simple in-memory implementation of the Memory and WorkflowMemory interfaces
 * Stores messages in memory, organized by user and conversation
 * Also provides workflow history, steps, and timeline events storage
 */
declare class InMemoryStorage implements Memory {
    private storage;
    private conversations;
    private historyEntries;
    private historySteps;
    private timelineEvents;
    private agentHistory;
    private workflowHistories;
    private workflowSteps;
    private workflowTimelineEvents;
    private workflowHistoryIndex;
    private options;
    private logger;
    /**
     * Create a new in-memory storage
     * @param options Configuration options
     */
    constructor(options?: InMemoryStorageOptions);
    /**
     * Add a timeline event
     * @param key Event ID (UUID)
     * @param value Timeline event data
     * @param historyId Related history entry ID
     * @param agentId Agent ID for filtering
     */
    addTimelineEvent(key: string, value: NewTimelineEvent, historyId: string, agentId: string): Promise<void>;
    /**
     * Get a history entry by ID
     */
    getHistoryEntry(key: string): Promise<any | undefined>;
    /**
     * Get a history step by ID
     */
    getHistoryStep(key: string): Promise<any | undefined>;
    /**
     * Add a history entry
     */
    addHistoryEntry(key: string, value: any, agentId: string): Promise<void>;
    /**
     * Update a history entry
     */
    updateHistoryEntry(key: string, value: any, agentId?: string): Promise<void>;
    /**
     * Add a history step
     */
    addHistoryStep(key: string, value: any, historyId: string, agentId: string): Promise<void>;
    /**
     * Update a history step
     */
    updateHistoryStep(key: string, value: any, historyId: string, agentId: string): Promise<void>;
    /**
     * Get all history entries for an agent with pagination
     */
    getAllHistoryEntriesByAgent(agentId: string, page: number, limit: number): Promise<{
        entries: any[];
        total: number;
    }>;
    /**
     * Log a debug message if debug is enabled
     * @param message Message to log
     * @param data Additional data to log
     */
    private debug;
    /**
     * Get messages with filtering options
     * @param options Filtering options
     * @returns Filtered messages
     */
    getMessages(options?: MessageFilterOptions): Promise<MemoryMessage[]>;
    /**
     * Add a message to the conversation history
     * @param message Message to add
     * @param conversationId Conversation identifier (optional, defaults to "default")
     */
    addMessage(message: MemoryMessage, conversationId?: string): Promise<void>;
    /**
     * Clear all messages for a user and optionally a specific conversation
     * @param options Options specifying which messages to clear
     */
    clearMessages(options: {
        userId: string;
        conversationId?: string;
    }): Promise<void>;
    /**
     * Create a new conversation
     * @param conversation Conversation to create
     * @returns Created conversation
     */
    createConversation(conversation: CreateConversationInput): Promise<Conversation>;
    /**
     * Get a conversation by ID
     * @param id Conversation ID
     * @returns Conversation or null if not found
     */
    getConversation(id: string): Promise<Conversation | null>;
    /**
     * Get all conversations for a resource
     * @param resourceId Resource ID
     * @returns Array of conversations
     */
    getConversations(resourceId: string): Promise<Conversation[]>;
    /**
     * Get conversations by user ID with query options
     * @param userId User ID
     * @param options Query options
     * @returns Array of conversations
     */
    getConversationsByUserId(userId: string, options?: Omit<ConversationQueryOptions, "userId">): Promise<Conversation[]>;
    /**
     * Query conversations with flexible filtering and pagination options
     *
     * This method provides a powerful way to search and filter conversations
     * with support for user-based filtering, resource filtering, pagination,
     * and custom sorting.
     *
     * @param options Query options for filtering and pagination
     * @param options.userId Optional user ID to filter conversations by specific user
     * @param options.resourceId Optional resource ID to filter conversations by specific resource
     * @param options.limit Maximum number of conversations to return (default: 50)
     * @param options.offset Number of conversations to skip for pagination (default: 0)
     * @param options.orderBy Field to sort by: 'created_at', 'updated_at', or 'title' (default: 'updated_at')
     * @param options.orderDirection Sort direction: 'ASC' or 'DESC' (default: 'DESC')
     *
     * @returns Promise that resolves to an array of conversations matching the criteria
     *
     * @example
     * ```typescript
     * // Get all conversations for a specific user
     * const userConversations = await storage.queryConversations({
     *   userId: 'user123',
     *   limit: 20
     * });
     *
     * // Get conversations for a resource with pagination
     * const resourceConversations = await storage.queryConversations({
     *   resourceId: 'chatbot-v1',
     *   limit: 10,
     *   offset: 20,
     *   orderBy: 'created_at',
     *   orderDirection: 'ASC'
     * });
     *
     * // Get all conversations (admin view)
     * const allConversations = await storage.queryConversations({
     *   limit: 100,
     *   orderBy: 'updated_at'
     * });
     * ```
     */
    queryConversations(options: ConversationQueryOptions): Promise<Conversation[]>;
    /**
     * Get messages for a specific conversation with pagination support
     *
     * This method retrieves all messages within a conversation, ordered chronologically
     * from oldest to newest. It supports pagination to handle large conversations
     * efficiently and avoid memory issues.
     *
     * @param conversationId The unique identifier of the conversation to retrieve messages from
     * @param options Optional pagination and filtering options
     * @param options.limit Maximum number of messages to return (default: 100)
     * @param options.offset Number of messages to skip for pagination (default: 0)
     *
     * @returns Promise that resolves to an array of messages in chronological order (oldest first)
     *
     * @example
     * ```typescript
     * // Get the first 50 messages in a conversation
     * const messages = await storage.getConversationMessages('conv-123', {
     *   limit: 50
     * });
     *
     * // Get messages with pagination (skip first 20, get next 30)
     * const olderMessages = await storage.getConversationMessages('conv-123', {
     *   limit: 30,
     *   offset: 20
     * });
     *
     * // Get all messages (use with caution for large conversations)
     * const allMessages = await storage.getConversationMessages('conv-123');
     *
     * // Process messages in batches
     * const batchSize = 100;
     * let offset = 0;
     * let hasMore = true;
     *
     * while (hasMore) {
     *   const batch = await storage.getConversationMessages('conv-123', {
     *     limit: batchSize,
     *     offset: offset
     *   });
     *
     *   // Process batch
     *   processBatch(batch);
     *
     *   hasMore = batch.length === batchSize;
     *   offset += batchSize;
     * }
     * ```
     *
     * @throws {Error} If the conversation ID is invalid or operation fails
     */
    getConversationMessages(conversationId: string, options?: {
        limit?: number;
        offset?: number;
    }): Promise<MemoryMessage[]>;
    /**
     * Update a conversation
     * @param id Conversation ID
     * @param updates Updates to apply
     * @returns Updated conversation
     */
    updateConversation(id: string, updates: Partial<Omit<Conversation, "id" | "createdAt" | "updatedAt">>): Promise<Conversation>;
    /**
     * Delete a conversation by ID
     * @param id Conversation ID
     */
    deleteConversation(id: string): Promise<void>;
    /**
     * Store workflow history entry
     */
    storeWorkflowHistory(entry: WorkflowHistoryEntry): Promise<void>;
    /**
     * Get a workflow history entry by ID
     */
    getWorkflowHistory(id: string): Promise<WorkflowHistoryEntry | null>;
    /**
     * Get all workflow history entries for a specific workflow ID
     */
    getWorkflowHistoryByWorkflowId(workflowId: string): Promise<WorkflowHistoryEntry[]>;
    /**
     * Update a workflow history entry
     */
    updateWorkflowHistory(id: string, updates: Partial<WorkflowHistoryEntry>): Promise<void>;
    /**
     * Delete a workflow history entry
     */
    deleteWorkflowHistory(id: string): Promise<void>;
    /**
     * Store a workflow step entry
     */
    storeWorkflowStep(step: WorkflowStepHistoryEntry): Promise<void>;
    /**
     * Get a workflow step by ID
     */
    getWorkflowStep(id: string): Promise<WorkflowStepHistoryEntry | null>;
    /**
     * Get all workflow steps for a workflow history entry
     */
    getWorkflowSteps(workflowHistoryId: string): Promise<WorkflowStepHistoryEntry[]>;
    /**
     * Update a workflow step entry
     */
    updateWorkflowStep(id: string, updates: Partial<WorkflowStepHistoryEntry>): Promise<void>;
    /**
     * Delete a workflow step entry
     */
    deleteWorkflowStep(id: string): Promise<void>;
    /**
     * Store a workflow timeline event
     */
    storeWorkflowTimelineEvent(event: WorkflowTimelineEvent$1): Promise<void>;
    /**
     * Get a workflow timeline event by ID
     */
    getWorkflowTimelineEvent(id: string): Promise<WorkflowTimelineEvent$1 | null>;
    /**
     * Get all workflow timeline events for a workflow history entry
     */
    getWorkflowTimelineEvents(workflowHistoryId: string): Promise<WorkflowTimelineEvent$1[]>;
    /**
     * Delete a workflow timeline event
     */
    deleteWorkflowTimelineEvent(id: string): Promise<void>;
    /**
     * Get all workflow IDs that have history entries
     */
    getAllWorkflowIds(): Promise<string[]>;
    /**
     * Get workflow statistics for a specific workflow
     */
    getWorkflowStats(workflowId: string): Promise<WorkflowStats>;
    /**
     * Get workflow history with steps and events in a single call
     */
    getWorkflowHistoryWithStepsAndEvents(id: string): Promise<WorkflowHistoryEntry | null>;
    /**
     * Delete workflow history with all related steps and events
     */
    deleteWorkflowHistoryWithRelated(id: string): Promise<void>;
    /**
     * Cleanup old workflow histories beyond the specified limit
     */
    cleanupOldWorkflowHistories(workflowId: string, maxEntries: number): Promise<number>;
}

/**
 * LibSQL extension for workflow memory operations
 * This class provides workflow-specific storage operations for LibSQL
 */
declare class LibSQLWorkflowExtension {
    private client;
    private _tablePrefix;
    private logger;
    constructor(client: Client, _tablePrefix?: string);
    /**
     * Store a workflow history entry
     */
    storeWorkflowHistory(entry: WorkflowHistoryEntry): Promise<void>;
    /**
     * Get a workflow history entry by ID
     */
    getWorkflowHistory(id: string): Promise<WorkflowHistoryEntry | null>;
    /**
     * Get all workflow history entries for a specific workflow
     */
    getWorkflowHistoryByWorkflowId(workflowId: string): Promise<WorkflowHistoryEntry[]>;
    /**
     * Update a workflow history entry
     */
    updateWorkflowHistory(id: string, updates: Partial<WorkflowHistoryEntry>): Promise<void>;
    /**
     * Delete a workflow history entry
     */
    deleteWorkflowHistory(id: string): Promise<void>;
    /**
     * Store a workflow step entry
     */
    storeWorkflowStep(step: WorkflowStepHistoryEntry): Promise<void>;
    /**
     * Get a workflow step by ID
     */
    getWorkflowStep(id: string): Promise<WorkflowStepHistoryEntry | null>;
    /**
     * Get all workflow steps for a specific workflow history
     */
    getWorkflowSteps(workflowHistoryId: string): Promise<WorkflowStepHistoryEntry[]>;
    /**
     * Update a workflow step
     */
    updateWorkflowStep(id: string, updates: Partial<WorkflowStepHistoryEntry>): Promise<void>;
    /**
     * Delete a workflow step
     */
    deleteWorkflowStep(id: string): Promise<void>;
    /**
     * Store a workflow timeline event
     */
    storeWorkflowTimelineEvent(event: WorkflowTimelineEvent$1): Promise<void>;
    /**
     * Get a workflow timeline event by ID
     */
    getWorkflowTimelineEvent(id: string): Promise<WorkflowTimelineEvent$1 | null>;
    /**
     * Get all workflow timeline events for a specific workflow history
     */
    getWorkflowTimelineEvents(workflowHistoryId: string): Promise<WorkflowTimelineEvent$1[]>;
    /**
     * Delete a workflow timeline event
     */
    deleteWorkflowTimelineEvent(id: string): Promise<void>;
    /**
     * Get all workflow IDs
     */
    getAllWorkflowIds(): Promise<string[]>;
    /**
     * Get workflow statistics
     */
    getWorkflowStats(workflowId: string): Promise<WorkflowStats>;
    /**
     * Get workflow history with all related data (steps and events)
     */
    getWorkflowHistoryWithStepsAndEvents(id: string): Promise<WorkflowHistoryEntry | null>;
    /**
     * Delete workflow history and all related data
     */
    deleteWorkflowHistoryWithRelated(id: string): Promise<void>;
    /**
     * Clean up old workflow histories
     */
    cleanupOldWorkflowHistories(workflowId: string, maxEntries: number): Promise<number>;
    /**
     * Parse workflow history row from database
     */
    private parseWorkflowHistoryRow;
    /**
     * Parse workflow step row from database
     */
    private parseWorkflowStepRow;
    /**
     * Parse workflow timeline event row from database
     */
    private parseWorkflowTimelineEventRow;
}

/**
 * Options for configuring the LibSQLStorage
 */
interface LibSQLStorageOptions extends MemoryOptions {
    /**
     * LibSQL connection URL
     * Can be either a remote Turso URL or a local file path
     * @example "libsql://your-database.turso.io" for remote Turso
     * @example "file:memory.db" for local SQLite in current directory
     * @example "file:.voltagent/memory.db" for local SQLite in .voltagent folder
     */
    url: string;
    /**
     * Auth token for LibSQL/Turso
     * Not needed for local SQLite
     */
    authToken?: string;
    /**
     * Prefix for table names
     * @default "voltagent_memory"
     */
    tablePrefix?: string;
    /**
     * Whether to enable debug logging
     * @default false
     */
    debug?: boolean;
    /**
     * Storage limit for the LibSQLStorage
     * @default 100
     */
    storageLimit?: number;
    /**
     * Number of retry attempts for database operations when encountering busy/locked errors
     * @default 3
     */
    retryAttempts?: number;
    /**
     * Base delay in milliseconds before retrying a failed operation
     * Uses a jittered exponential backoff strategy for better load distribution
     * @default 50
     */
    baseDelayMs?: number;
}
/**
 * A LibSQL storage implementation of the Memory and WorkflowMemory interfaces
 * Uses libsql/Turso to store and retrieve conversation history and workflow data
 *
 * This implementation automatically handles both:
 * - Remote Turso databases (with libsql:// URLs)
 * - Local SQLite databases (with file: URLs)
 */
declare class LibSQLStorage implements Memory {
    private client;
    private options;
    private initialized;
    private workflowExtension;
    private logger;
    private retryAttempts;
    private baseDelayMs;
    /**
     * Create a new LibSQL storage
     * @param options Configuration options
     */
    constructor(options: LibSQLStorageOptions);
    /**
     * Normalize the URL for SQLite database
     * - Ensures local files exist in the correct directory
     * - Creates the .voltagent directory if needed for default storage
     */
    private normalizeUrl;
    /**
     * Log a debug message if debug is enabled
     * @param message Message to log
     * @param data Additional data to log
     */
    private debug;
    /**
     * Calculate delay with jitter for better load distribution
     * @param attempt Current retry attempt number
     * @returns Delay in milliseconds
     */
    private calculateRetryDelay;
    /**
     * Execute a database operation with retry strategy
     * Implements jittered exponential backoff
     * @param operationFn The operation function to execute
     * @param operationName Operation name for logging
     * @returns The result of the operation
     */
    private executeWithRetryStrategy;
    /**
     * Initialize workflow tables
     */
    private initializeWorkflowTables;
    /**
     * Initialize the database tables
     * @returns Promise that resolves when initialization is complete
     */
    private initializeDatabase;
    /**
     * Generate a unique ID for a message
     * @returns Unique ID
     */
    private generateId;
    /**
     * Get messages with filtering options
     * @param options Filtering options
     * @returns Filtered messages
     */
    getMessages(options?: MessageFilterOptions): Promise<MemoryMessage[]>;
    /**
     * Add a message to the conversation history
     * @param message Message to add
     * @param userId User identifier (optional, defaults to "default")
     * @param conversationId Conversation identifier (optional, defaults to "default")
     */
    addMessage(message: MemoryMessage, conversationId?: string): Promise<void>;
    /**
     * Prune old messages to respect storage limit
     * @param conversationId Conversation ID to prune messages for
     */
    private pruneOldMessages;
    /**
     * Clear messages from memory
     */
    clearMessages(options: {
        userId: string;
        conversationId?: string;
    }): Promise<void>;
    /**
     * Close the database connection
     */
    close(): Promise<void>;
    /**
     * Add or update a history entry
     * @param key Entry ID
     * @param value Entry data
     * @param agentId Agent ID for filtering
     */
    addHistoryEntry(key: string, value: any, agentId: string): Promise<void>;
    /**
     * Update an existing history entry
     * @param key Entry ID
     * @param value Updated entry data
     * @param agentId Agent ID for filtering
     */
    updateHistoryEntry(key: string, value: any, agentId: string): Promise<void>;
    /**
     * Add a history step
     * @param key Step ID
     * @param value Step data
     * @param historyId Related history entry ID
     * @param agentId Agent ID for filtering
     */
    addHistoryStep(key: string, value: any, historyId: string, agentId: string): Promise<void>;
    /**
     * Update a history step
     * @param key Step ID
     * @param value Updated step data
     * @param historyId Related history entry ID
     * @param agentId Agent ID for filtering
     */
    updateHistoryStep(key: string, value: any, historyId: string, agentId: string): Promise<void>;
    /**
     * Add a timeline event
     * @param key Event ID (UUID)
     * @param value Timeline event data
     * @param historyId Related history entry ID
     * @param agentId Agent ID for filtering
     */
    addTimelineEvent(key: string, value: NewTimelineEvent, historyId: string, agentId: string): Promise<void>;
    /**
     * Get a history entry by ID
     * @param key Entry ID
     * @returns The history entry or undefined if not found
     */
    getHistoryEntry(key: string): Promise<any | undefined>;
    /**
     * Get a history step by ID
     * @param key Step ID
     * @returns The history step or undefined if not found
     */
    getHistoryStep(key: string): Promise<any | undefined>;
    createConversation(conversation: CreateConversationInput): Promise<Conversation>;
    getConversation(id: string): Promise<Conversation | null>;
    getConversations(resourceId: string): Promise<Conversation[]>;
    getConversationsByUserId(userId: string, options?: Omit<ConversationQueryOptions, "userId">): Promise<Conversation[]>;
    /**
     * Query conversations with filtering and pagination options
     *
     * @param options Query options for filtering and pagination
     * @returns Promise that resolves to an array of conversations matching the criteria
     * @see {@link https://voltagent.dev/docs/agents/memory/libsql#querying-conversations | Querying Conversations}
     */
    queryConversations(options: ConversationQueryOptions): Promise<Conversation[]>;
    /**
     * Get messages for a specific conversation with pagination support
     *
     * @param conversationId The unique identifier of the conversation to retrieve messages from
     * @param options Optional pagination and filtering options
     * @returns Promise that resolves to an array of messages in chronological order (oldest first)
     * @see {@link https://voltagent.dev/docs/agents/memory/libsql#conversation-messages | Getting Conversation Messages}
     */
    getConversationMessages(conversationId: string, options?: {
        limit?: number;
        offset?: number;
    }): Promise<MemoryMessage[]>;
    updateConversation(id: string, updates: Partial<Omit<Conversation, "id" | "createdAt" | "updatedAt">>): Promise<Conversation>;
    deleteConversation(id: string): Promise<void>;
    /**
     * Get all history entries for an agent with pagination
     * @param agentId Agent ID
     * @param page Page number (0-based)
     * @param limit Number of entries per page
     * @returns Object with entries array and total count
     */
    getAllHistoryEntriesByAgent(agentId: string, page: number, limit: number): Promise<{
        entries: any[];
        total: number;
    }>;
    /**
     * Migrates agent history data from old structure to new structure.
     * If migration fails, it can be rolled back using the backup mechanism.
     *
     * Old database structure:
     * CREATE TABLE voltagent_memory_agent_history (
     *   key TEXT PRIMARY KEY,
     *   value TEXT NOT NULL,
     *   agent_id TEXT
     * );
     */
    migrateAgentHistoryData(options?: {
        createBackup?: boolean;
        restoreFromBackup?: boolean;
        deleteBackupAfterSuccess?: boolean;
    }): Promise<{
        success: boolean;
        migratedCount?: number;
        error?: Error;
        backupCreated?: boolean;
    }>;
    /**
     * Migrate conversation schema to add user_id and update messages table
     *
     *   **CRITICAL WARNING: DESTRUCTIVE OPERATION** 
     *
     * This method performs a DESTRUCTIVE schema migration that:
     * - DROPS and recreates existing tables
     * - Creates temporary tables during migration
     * - Modifies the primary key structure of the messages table
     * - Can cause DATA LOSS if interrupted or if errors occur
     *
     * **IMPORTANT SAFETY REQUIREMENTS:**
     * -  STOP all application instances before running this migration
     * -  Ensure NO concurrent database operations are running
     * -  Take a full database backup before running (independent of built-in backup)
     * -  Test the migration on a copy of production data first
     * -  Plan for downtime during migration execution
     *
     * **What this migration does:**
     * 1. Creates backup tables (if createBackup=true)
     * 2. Creates temporary tables with new schema
     * 3. Migrates data from old tables to new schema
     * 4. DROPS original tables
     * 5. Renames temporary tables to original names
     * 6. All operations are wrapped in a transaction for atomicity
     *
     * @param options Migration configuration options
     * @param options.createBackup Whether to create backup tables before migration (default: true, HIGHLY RECOMMENDED)
     * @param options.restoreFromBackup Whether to restore from existing backup instead of migrating (default: false)
     * @param options.deleteBackupAfterSuccess Whether to delete backup tables after successful migration (default: false)
     *
     * @returns Promise resolving to migration result with success status, migrated count, and backup info
     *
     * @example
     * ```typescript
     * // RECOMMENDED: Run with backup creation (default)
     * const result = await storage.migrateConversationSchema({
     *   createBackup: true,
     *   deleteBackupAfterSuccess: false // Keep backup for safety
     * });
     *
     * if (result.success) {
     *   console.log(`Migrated ${result.migratedCount} conversations successfully`);
     * } else {
     *   console.error('Migration failed:', result.error);
     *   // Consider restoring from backup
     * }
     *
     * // If migration fails, restore from backup:
     * const restoreResult = await storage.migrateConversationSchema({
     *   restoreFromBackup: true
     * });
     * ```
     *
     * @throws {Error} If migration fails and transaction is rolled back
     *
     * @since This migration is typically only needed when upgrading from older schema versions
     */
    private migrateConversationSchema;
    /**
     * Get conversations for a user with a fluent query builder interface
     * @param userId User ID to filter by
     * @returns Query builder object
     */
    getUserConversations(userId: string): {
        /**
         * Limit the number of results
         * @param count Number of conversations to return
         * @returns Query builder
         */
        limit: (count: number) => {
            /**
             * Order results by a specific field
             * @param field Field to order by
             * @param direction Sort direction
             * @returns Query builder
             */
            orderBy: (field?: "created_at" | "updated_at" | "title", direction?: "ASC" | "DESC") => {
                /**
                 * Execute the query and return results
                 * @returns Promise of conversations
                 */
                execute: () => Promise<Conversation[]>;
            };
            /**
             * Execute the query with default ordering
             * @returns Promise of conversations
             */
            execute: () => Promise<Conversation[]>;
        };
        /**
         * Order results by a specific field
         * @param field Field to order by
         * @param direction Sort direction
         * @returns Query builder
         */
        orderBy: (field?: "created_at" | "updated_at" | "title", direction?: "ASC" | "DESC") => {
            /**
             * Limit the number of results
             * @param count Number of conversations to return
             * @returns Query builder
             */
            limit: (count: number) => {
                /**
                 * Execute the query and return results
                 * @returns Promise of conversations
                 */
                execute: () => Promise<Conversation[]>;
            };
            /**
             * Execute the query without limit
             * @returns Promise of conversations
             */
            execute: () => Promise<Conversation[]>;
        };
        /**
         * Execute the query with default options
         * @returns Promise of conversations
         */
        execute: () => Promise<Conversation[]>;
    };
    /**
     * Get conversation by ID and ensure it belongs to the specified user
     * @param conversationId Conversation ID
     * @param userId User ID to validate ownership
     * @returns Conversation or null
     */
    getUserConversation(conversationId: string, userId: string): Promise<Conversation | null>;
    /**
     * Get paginated conversations for a user
     * @param userId User ID
     * @param page Page number (1-based)
     * @param pageSize Number of items per page
     * @returns Object with conversations and pagination info
     */
    getPaginatedUserConversations(userId: string, page?: number, pageSize?: number): Promise<{
        conversations: Conversation[];
        page: number;
        pageSize: number;
        hasMore: boolean;
    }>;
    /**
     * Check and create migration flag table, return if migration already completed
     * @param migrationType Type of migration to check
     * @returns Object with completion status and details
     */
    private checkMigrationFlag;
    /**
     * Set migration flag after successful completion
     * @param migrationType Type of migration completed
     * @param migratedCount Number of records migrated
     */
    private setMigrationFlag;
    /**
     * Migrate agent history schema to add userId and conversationId columns
     */
    private migrateAgentHistorySchema;
    storeWorkflowHistory(entry: any): Promise<void>;
    getWorkflowHistory(id: string): Promise<any>;
    getWorkflowHistoryByWorkflowId(workflowId: string): Promise<any[]>;
    updateWorkflowHistory(id: string, updates: any): Promise<void>;
    deleteWorkflowHistory(id: string): Promise<void>;
    storeWorkflowStep(step: any): Promise<void>;
    getWorkflowStep(id: string): Promise<any>;
    getWorkflowSteps(workflowHistoryId: string): Promise<any[]>;
    updateWorkflowStep(id: string, updates: any): Promise<void>;
    deleteWorkflowStep(id: string): Promise<void>;
    storeWorkflowTimelineEvent(event: any): Promise<void>;
    getWorkflowTimelineEvent(id: string): Promise<any>;
    getWorkflowTimelineEvents(workflowHistoryId: string): Promise<any[]>;
    deleteWorkflowTimelineEvent(id: string): Promise<void>;
    getAllWorkflowIds(): Promise<string[]>;
    getWorkflowStats(workflowId: string): Promise<any>;
    getWorkflowHistoryWithStepsAndEvents(id: string): Promise<any>;
    deleteWorkflowHistoryWithRelated(id: string): Promise<void>;
    cleanupOldWorkflowHistories(workflowId: string, maxEntries: number): Promise<number>;
    /**
     * Get the workflow extension for advanced workflow operations
     */
    getWorkflowExtension(): LibSQLWorkflowExtension;
}

/**
 * Manager class to handle all memory-related operations
 */
declare class MemoryManager {
    /**
     * The memory storage instance for conversations
     */
    private conversationMemory;
    /**
     * The memory storage instance for history (always available)
     */
    private historyMemory;
    /**
     * Memory configuration options
     */
    private options;
    /**
     * The ID of the resource (agent) that owns this memory manager
     */
    private resourceId;
    /**
     * Logger instance
     */
    private logger;
    /**
     * Background queue for memory operations
     */
    private backgroundQueue;
    /**
     * Creates a new MemoryManager
     */
    constructor(resourceId: string, memory?: Memory | false, options?: MemoryOptions, historyMemory?: Memory, logger?: Logger);
    /**
     * Create and publish a timeline event for memory operations using the queue
     *
     * @param context - Operation context with history entry info
     * @param event - Timeline event to publish
     */
    private publishTimelineEvent;
    /**
     * Save a message to memory
     */
    saveMessage(context: OperationContext, message: BaseMessage, userId?: string, conversationId?: string, type?: "text" | "tool-call" | "tool-result"): Promise<void>;
    /**
     * Create a step finish handler to save messages during generation
     */
    createStepFinishHandler(context: OperationContext, userId?: string, conversationId?: string): (() => void) | ((step: StepWithContent) => Promise<void>);
    /**
     * Prepare conversation context for message generation (CONTEXT-FIRST OPTIMIZED)
     * Ensures context is always loaded, optimizes non-critical operations in background
     */
    prepareConversationContext(context: OperationContext, input: string | BaseMessage[], userId?: string, conversationIdParam?: string, contextLimit?: number): Promise<{
        messages: BaseMessage[];
        conversationId: string;
    }>;
    /**
     * Handle sequential background operations using the queue
     * Setup conversation and save input in a single atomic operation
     */
    private handleSequentialBackgroundOperations;
    /**
     * Ensure conversation exists (background task)
     */
    private ensureConversationExists;
    /**
     * Save current input (background task)
     */
    private saveCurrentInput;
    /**
     * Get the conversation memory instance
     */
    getMemory(): Memory | undefined;
    /**
     * Get the history memory instance
     */
    getHistoryMemory(): Memory;
    /**
     * Get the memory options
     */
    getOptions(): MemoryOptions;
    /**
     * Get memory state for display in UI
     */
    getMemoryState(): Record<string, any>;
    /**
     * Store a history entry in memory storage
     *
     * @param agentId - The ID of the agent
     * @param entry - The history entry to store
     * @returns A promise that resolves when the entry is stored
     */
    storeHistoryEntry(agentId: string, entry: any): Promise<void>;
    /**
     * Get a history entry by ID with related events and steps
     *
     * @param agentId - The ID of the agent
     * @param entryId - The ID of the entry to retrieve
     * @returns A promise that resolves to the entry or undefined
     */
    getHistoryEntryById(agentId: string, entryId: string): Promise<any | undefined>;
    /**
     * Get all history entries for an agent with optional pagination
     *
     * @param agentId - The ID of the agent
     * @param options - Pagination options
     * @returns A promise that resolves to entries and pagination info
     */
    getAllHistoryEntries(agentId: string, options?: {
        page?: number;
        limit?: number;
    }): Promise<{
        entries: any[];
        pagination: {
            page: number;
            limit: number;
            total: number;
            totalPages: number;
        };
    }>;
    /**
     * Update a history entry
     *
     * @param agentId - The ID of the agent
     * @param entryId - The ID of the entry to update
     * @param updates - Partial entry with fields to update
     * @returns A promise that resolves to the updated entry or undefined
     */
    updateHistoryEntry(agentId: string, entryId: string, updates: any): Promise<any | undefined>;
    /**
     * Add steps to a history entry
     *
     * @param agentId - The ID of the agent
     * @param entryId - The ID of the entry to update
     * @param steps - Steps to add
     * @returns A promise that resolves to the updated entry or undefined
     */
    addStepsToHistoryEntry(agentId: string, entryId: string, steps: any[]): Promise<any | undefined>;
    /**
     * Add a timeline event to a history entry
     * This method is part of the new immutable event system
     *
     * @param agentId - The ID of the agent
     * @param historyId - The ID of the history entry
     * @param eventId - The ID of the timeline event
     * @param event - The NewTimelineEvent object
     * @returns A promise that resolves to the updated entry or undefined
     */
    addTimelineEvent(agentId: string, historyId: string, eventId: string, event: NewTimelineEvent): Promise<any | undefined>;
}

declare enum ActionType {
    START = "start",
    COMPLETE = "complete",
    ERROR = "error",
    GENERATION_START = "generationStart",
    GENERATION_COMPLETE = "generationComplete",
    STREAM_START = "streamStart",
    STREAM_COMPLETE = "streamComplete",
    STREAM_STEP = "streamStep",
    STREAMING = "streaming",
    OBJECT_GENERATION_START = "objectGenerationStart",
    OBJECT_GENERATION_COMPLETE = "objectGenerationComplete",
    STREAM_OBJECT_START = "streamObjectStart",
    STREAM_OBJECT_COMPLETE = "streamObjectComplete",
    TOOL_CALL = "toolCall",
    TOOL_ERROR = "toolError",
    DELEGATE = "delegate",
    EXECUTE = "execute",
    VALIDATE = "validate",
    STEP_START = "stepStart",
    STEP_COMPLETE = "stepComplete",
    SUSPEND = "suspend",
    RESUME = "resume",
    ACCESS = "access",
    STORE = "store",
    RETRIEVE = "retrieve"
}
/**
 * Helper to format retriever log messages
 */
declare function buildRetrieverLogMessage(retrieverName: string, action: ActionType | string, description: string): string;

/**
 * Options for configuring the Retriever
 */
type RetrieverOptions = {
    /**
     * Name for the default tool created from this retriever
     * This is used for the pre-created 'tool' property
     * @default "search_knowledge"
     */
    toolName?: string;
    /**
     * Description for the default tool created from this retriever
     * This is used for the pre-created 'tool' property
     * @default "Searches for relevant information in the knowledge base based on the query."
     */
    toolDescription?: string;
    /**
     * Optional logger instance for the retriever
     * If not provided, a default logger will be created
     */
    logger?: Logger;
    /**
     * Additional configuration specific to concrete retriever implementations
     */
    [key: string]: any;
};
/**
 * Options passed to retrieve method
 */
interface RetrieveOptions {
    /**
     * User-managed context map for this specific retrieval operation
     * Can be used to store metadata, results, or any custom data
     */
    userContext?: Map<string | symbol, unknown>;
    /**
     * Optional logger instance for this retrieval operation.
     * Provides execution-scoped logging with full context.
     * Available when retriever is called from an agent or workflow context.
     */
    logger?: Logger;
}
/**
 * Retriever interface for retrieving relevant information
 */
type Retriever = {
    /**
     * Retrieve relevant documents based on input text
     * @param text The text to use for retrieval
     * @param options Configuration and context for the retrieval
     * @returns Promise resolving to a string with the retrieved content
     */
    retrieve(text: string, options: RetrieveOptions): Promise<string>;
    /**
     * Configuration options for the retriever
     * This is optional and may not be present in all implementations
     */
    options?: RetrieverOptions;
    /**
     * Pre-created tool for easy destructuring
     * This is optional and may not be present in all implementations
     */
    tool?: any;
};

/**
 * Abstract base class for Retriever implementations.
 * This class provides a common structure for different types of retrievers.
 */
declare abstract class BaseRetriever {
    /**
     * Options that configure the retriever's behavior
     */
    protected options: RetrieverOptions;
    /**
     * Logger instance for the retriever
     */
    protected logger: Logger;
    /**
     * Ready-to-use tool property for direct destructuring
     * This can be used with object destructuring syntax
     *
     * @example
     * ```typescript
     * //  You can use destructuring with the tool property
     * const { tool } = new SimpleRetriever();
     *
     * // And use it directly in an agent
     * const agent = new Agent({
     *   name: "RAG Agent",
     *   model: "gpt-4",
     *   provider,
     *   tools: [tool],
     * });
     * ```
     */
    readonly tool: AgentTool;
    /**
     * Constructor for the BaseRetriever class.
     * @param options - Configuration options for the retriever.
     */
    constructor(options?: RetrieverOptions);
    /**
     * Abstract method that must be implemented by concrete retriever classes.
     * Retrieves relevant information based on the input text or messages.
     *
     * @param input - The input to use for retrieval (string or BaseMessage array)
     * @param options - Configuration and context for the retrieval
     * @returns Promise resolving to a string with the retrieved content
     */
    abstract retrieve(input: string | BaseMessage[], options: RetrieveOptions): Promise<string>;
}

/**
 * ReadableStream type for voice responses
 */
type ReadableStreamType = ReadableStream | NodeJS.ReadableStream | any;
/**
 * Voice provider options
 */
type VoiceOptions = {
    /**
     * API key for the voice provider
     */
    apiKey?: string;
    /**
     * Model to use for speech recognition
     */
    speechModel?: string;
    /**
     * Model to use for text-to-speech
     */
    ttsModel?: string;
    /**
     * Voice ID to use for text-to-speech
     */
    voice?: string;
    /**
     * Additional provider-specific options
     */
    options?: Record<string, unknown>;
};
/**
 * Voice event types
 */
type VoiceEventType = "speaking" | "listening" | "error" | "connected" | "disconnected";
/**
 * Voice event data types
 */
type VoiceEventData = {
    speaking: {
        text: string;
        audio?: NodeJS.ReadableStream;
    };
    listening: {
        audio: NodeJS.ReadableStream;
    };
    error: {
        message: string;
        code?: string;
        details?: unknown;
    };
    connected: undefined;
    disconnected: undefined;
};
/**
 * Voice metadata
 */
type VoiceMetadata = {
    id: string;
    name: string;
    language: string;
    gender?: "male" | "female" | "neutral";
    metadata?: Record<string, unknown>;
};
/**
 * Base interface for voice providers
 */
type Voice = {
    /**
     * Convert text to speech
     */
    speak(text: string | NodeJS.ReadableStream, options?: {
        voice?: string;
        speed?: number;
        pitch?: number;
    }): Promise<NodeJS.ReadableStream>;
    /**
     * Convert speech to text
     */
    listen(audio: NodeJS.ReadableStream, options?: {
        language?: string;
        model?: string;
        stream?: boolean;
    }): Promise<string | ReadableStreamType>;
    /**
     * Connect to real-time voice service
     */
    connect(options?: Record<string, unknown>): Promise<void>;
    /**
     * Disconnect from real-time voice service
     */
    disconnect(): void;
    /**
     * Send audio data to real-time service
     */
    send(audioData: NodeJS.ReadableStream | Int16Array): Promise<void>;
    /**
     * Register event listener
     */
    on<E extends VoiceEventType>(event: E, callback: (data: VoiceEventData[E]) => void): void;
    /**
     * Remove event listener
     */
    off<E extends VoiceEventType>(event: E, callback: (data: VoiceEventData[E]) => void): void;
    /**
     * Get available voices
     */
    getVoices(): Promise<VoiceMetadata[]>;
};

/**
 * Main VoltOps client class that provides unified access to both
 * telemetry export and prompt management functionality.
 */
declare class VoltOpsClient implements VoltOpsClient$1 {
    readonly options: VoltOpsClientOptions & {
        baseUrl: string;
    };
    readonly observability?: VoltAgentExporter;
    readonly prompts?: VoltOpsPromptManager;
    private readonly logger;
    constructor(options: VoltOpsClientOptions);
    /**
     * Create a prompt helper for agent instructions
     */
    createPromptHelper(_agentId: string): PromptHelper;
    get exportHistoryEntry(): ((historyEntryData: ExportAgentHistoryPayload) => Promise<{
        historyEntryId: string;
    }>) | undefined;
    get exportHistoryEntryAsync(): ((historyEntryData: ExportAgentHistoryPayload) => void) | undefined;
    get exportTimelineEvent(): ((timelineEventData: ExportTimelineEventPayload) => Promise<{
        timelineEventId: string;
    }>) | undefined;
    get exportTimelineEventAsync(): ((timelineEventData: ExportTimelineEventPayload) => void) | undefined;
    /**
     * Check if observability is enabled and configured
     */
    isObservabilityEnabled(): boolean;
    /**
     * Check if the client has valid API keys
     */
    hasValidKeys(): boolean;
    /**
     * Check if prompt management is enabled and configured
     */
    isPromptManagementEnabled(): boolean;
    /**
     * Get observability exporter for backward compatibility
     * @deprecated Use observability property directly
     */
    getObservabilityExporter(): VoltAgentExporter | undefined;
    /**
     * Get prompt manager for direct access
     */
    getPromptManager(): VoltOpsPromptManager | undefined;
    /**
     * Static method to create prompt helper with priority-based fallback
     * Priority: Agent VoltOpsClient > Global VoltOpsClient > Fallback instructions
     */
    static createPromptHelperWithFallback(agentId: string, agentName: string, fallbackInstructions: string, agentVoltOpsClient?: VoltOpsClient): PromptHelper;
    /**
     * Cleanup resources when client is no longer needed
     */
    dispose(): Promise<void>;
}
/**
 * Factory function to create VoltOps client
 */
declare const createVoltOpsClient: (options: VoltOpsClientOptions) => VoltOpsClient;

/**
 * SubAgentManager - Manages sub-agents and delegation functionality for an Agent
 */
declare class SubAgentManager {
    /**
     * The name of the agent that owns this sub-agent manager
     */
    private agentName;
    /**
     * Sub-agent configurations that the parent agent can delegate tasks to
     * Can be either direct Agent instances or SubAgentConfigObject instances
     */
    private subAgentConfigs;
    /**
     * Supervisor configuration including event forwarding settings
     */
    private supervisorConfig?;
    /**
     * Creates a new SubAgentManager instance
     *
     * @param agentName - The name of the agent that owns this sub-agent manager
     * @param subAgents - Initial sub-agent configurations to add
     * @param supervisorConfig - Optional supervisor configuration including event forwarding
     */
    constructor(agentName: string, subAgents?: SubAgentConfig[], supervisorConfig?: SupervisorConfig);
    /**
     * Add a sub-agent that the parent agent can delegate tasks to
     */
    addSubAgent(agentConfig: SubAgentConfig): void;
    /**
     * Remove a sub-agent
     */
    removeSubAgent(agentId: string): void;
    /**
     * Unregister all sub-agents when parent agent is destroyed
     */
    unregisterAllSubAgents(): void;
    /**
     * Helper method to extract agent ID from SubAgentConfig
     */
    private extractAgentId;
    /**
     * Helper method to extract agent instance from SubAgentConfig
     */
    private extractAgent;
    /**
     * Helper method to extract agent name from SubAgentConfig
     */
    private extractAgentName;
    /**
     * Helper method to extract agent purpose/instructions from SubAgentConfig
     */
    private extractAgentPurpose;
    /**
     * Type guard to check if a SubAgentConfig is a SubAgentConfigObject
     */
    private isSubAgentConfigObject;
    /**
     * Get all sub-agents
     */
    getSubAgents(): SubAgentConfig[];
    /**
     * Calculate maximum number of steps based on sub-agents
     * More sub-agents means more potential steps
     */
    calculateMaxSteps(agentMaxSteps?: number): number;
    /**
     * Generate enhanced system message for supervisor role
     * @param baseInstructions - The base instructions of the agent
     * @param agentsMemory - Optional string containing formatted memory from previous agent interactions
     * @param config - Optional supervisor configuration to customize the system message
     */
    generateSupervisorSystemMessage(baseInstructions: string, agentsMemory?: string, config?: SupervisorConfig): string;
    /**
     * Check if the agent has sub-agents
     */
    hasSubAgents(): boolean;
    /**
     * Hand off a task to another agent
     */
    handoffTask(options: AgentHandoffOptions): Promise<AgentHandoffResult>;
    /**
     * Hand off a task to multiple agents in parallel
     */
    handoffToMultiple(options: Omit<AgentHandoffOptions, "targetAgent"> & {
        targetAgents: SubAgentConfig[];
    }): Promise<AgentHandoffResult[]>;
    /**
     * Creates a tool that allows the supervisor agent to delegate a
     * task to one or more specialized agents
     */
    createDelegateTool(options: MergeDeep<{
        sourceAgent: Agent<any>;
        currentHistoryEntryId?: string;
        operationContext?: OperationContext;
        forwardEvent?: (event: StreamEvent) => Promise<void>;
        maxSteps?: number;
    }, Record<string, any>>): BaseTool;
    /**
     * Get sub-agent details for API exposure
     */
    getSubAgentDetails(): Array<Record<string, any>>;
}

/**
 * Agent class for interacting with AI models
 */
declare class Agent<TProvider extends {
    llm: LLMProvider<unknown>;
}> {
    /**
     * Unique identifier for the agent
     */
    readonly id: string;
    /**
     * Agent name
     */
    readonly name: string;
    /**
     * (sub)agent purpose. This is the purpose of a (sub)agent, that will be used to generate the system message for the supervisor agent, if not provided, the agent will use the `instructions` field to generate the system message.
     *
     * @example 'An agent for customer support'
     */
    readonly purpose?: string;
    /**
     * @deprecated Use `instructions` instead. Will be removed in a future version.
     */
    readonly description: string;
    /**
     * Agent instructions. This is the preferred field over `description`.
     */
    readonly instructions: string;
    /**
     * Dynamic instructions value (internal)
     */
    private readonly dynamicInstructions?;
    /**
     * Dynamic model value (internal)
     */
    private readonly dynamicModel?;
    /**
     * Dynamic tools value (internal)
     */
    private readonly dynamicTools?;
    /**
     * The LLM provider to use
     */
    readonly llm: ProviderInstance<TProvider>;
    /**
     * The AI model to use
     */
    readonly model: ModelType<TProvider>;
    /**
     * Hooks for agent lifecycle events
     */
    hooks: AgentHooks;
    /**
     * Voice provider for the agent
     */
    readonly voice?: Voice;
    /**
     * Indicates if the agent should format responses using Markdown.
     */
    readonly markdown: boolean;
    /**
     * Maximum number of steps the agent can take before stopping
     */
    readonly maxSteps?: number;
    /**
     * Memory manager for the agent
     */
    protected memoryManager: MemoryManager;
    /**
     * Tool manager for the agent
     */
    protected toolManager: ToolManager;
    /**
     * Sub-agent manager for the agent
     */
    protected subAgentManager: SubAgentManager;
    /**
     * History manager for the agent
     */
    protected historyManager: HistoryManager;
    /**
     * Retriever for automatic RAG
     */
    private retriever?;
    /**
     * VoltOps client for this specific agent (optional)
     * Takes priority over global VoltOpsClient for prompt management
     */
    private readonly voltOpsClient?;
    /**
     * Supervisor configuration for agents with subagents
     */
    private readonly supervisorConfig?;
    /**
     * User-defined context passed at agent creation
     * Can be overridden during execution
     */
    private readonly defaultUserContext?;
    /**
     * Logger instance for this agent
     */
    readonly logger: Logger;
    /**
     * Create a new agent
     */
    constructor(options: AgentOptions & TProvider & {
        model: ModelDynamicValue<ModelType<TProvider>>;
        subAgents?: SubAgentConfig[];
        maxHistoryEntries?: number;
        hooks?: AgentHooks;
        retriever?: BaseRetriever;
        voice?: Voice;
        markdown?: boolean;
        voltOpsClient?: VoltOpsClient;
    });
    /**
     * Resolve dynamic instructions based on user context
     */
    private resolveInstructions;
    /**
     * Resolve dynamic model based on user context
     */
    private resolveModel;
    /**
     * Resolve dynamic tools based on user context
     */
    private resolveTools;
    /**
     * Generate a human-readable description for a stream step
     */
    private getStepDescription;
    /**
     * Get the system message for the agent
     */
    protected getSystemMessage({ input, historyEntryId, contextMessages, operationContext, }: {
        input?: string | BaseMessage[];
        historyEntryId: string;
        contextMessages: BaseMessage[];
        operationContext?: OperationContext;
    }): Promise<SystemMessageResponse>;
    /**
     * Prepare agents memory for the supervisor system message
     * This fetches and formats recent interactions with sub-agents
     */
    private prepareAgentsMemory;
    /**
     * Add input to messages array based on type
     */
    private formatInputMessages;
    /**
     * Calculate maximum number of steps based on sub-agents
     */
    private calculateMaxSteps;
    /**
     * Prepare common options for text generation
     */
    private prepareTextOptions;
    /**
     * Get logger with parent context if available
     */
    protected getContextualLogger(parentAgentId?: string, parentHistoryEntryId?: string): Logger;
    /**
     * Calculate delegation depth by traversing parent chain
     */
    private calculateDelegationDepth;
    /**
     * Initialize a new history entry
     * @param input User input
     * @param initialStatus Initial status
     * @param options Options including parent context
     * @returns Created operation context
     */
    private initializeHistory;
    /**
     * Get full agent state including tools status
     */
    getFullState(): {
        id: string;
        name: string;
        description: string;
        instructions: string;
        status: string;
        model: string;
        node_id: string;
        tools: {
            node_id: string;
            id: string;
            name: string;
            description: string;
            parameters: any;
            outputSchema?: any;
            execute: (args: any, options?: ToolExecuteOptions) => Promise<any>;
        }[];
        subAgents: {
            node_id: string;
        }[];
        memory: {
            node_id: string;
        };
        retriever: {
            name: string;
            description: string;
            status: string;
            node_id: string;
        } | null;
    };
    /**
     * Get agent's history with pagination
     */
    getHistory(options?: {
        page?: number;
        limit?: number;
    }): Promise<{
        entries: AgentHistoryEntry[];
        pagination: {
            page: number;
            limit: number;
            total: number;
            totalPages: number;
        };
    }>;
    /**
     * Add step to history immediately and to conversation steps
     */
    private addStepToHistory;
    /**
     * Update history entry
     */
    private updateHistoryEntry;
    /**
     * Fix delete operator usage for better performance
     */
    private addToolEvent;
    /**
     * Agent event creator (update)
     */
    private addAgentEvent;
    /**
     * Helper method to enrich and end an OpenTelemetry span associated with a tool call.
     */
    private _endOtelToolSpan;
    private publishTimelineEvent;
    /**
     * Sets up abort signal listener for cancellation handling
     */
    private setupAbortSignalListener;
    /**
     * Create an enhanced fullStream with real-time SubAgent event injection
     */
    private createEnhancedFullStream;
    /**
     * Generate a text response without streaming
     */
    generateText(input: string | BaseMessage[], options?: PublicGenerateOptions): Promise<GenerateTextResponse<TProvider>>;
    /**
     * Stream a text response
     */
    streamText(input: string | BaseMessage[], options?: PublicGenerateOptions): Promise<StreamTextResponse<TProvider>>;
    /**
     * Generate a structured object response
     */
    generateObject<TSchema extends z.ZodType>(input: string | BaseMessage[], schema: TSchema, options?: PublicGenerateOptions): Promise<GenerateObjectResponse<TProvider, TSchema>>;
    /**
     * Stream a structured object response
     */
    streamObject<TSchema extends z.ZodType>(input: string | BaseMessage[], schema: TSchema, options?: PublicGenerateOptions): Promise<StreamObjectResponse<TProvider, TSchema>>;
    /**
     * Add a sub-agent that this agent can delegate tasks to
     */
    addSubAgent(agentConfig: SubAgentConfig): void;
    /**
     * Remove a sub-agent
     */
    removeSubAgent(agentId: string): void;
    /**
     * Get agent's tools for API exposure
     */
    getToolsForApi(): {
        name: string;
        description: string;
        parameters: any;
    }[];
    /**
     * Get all tools
     */
    getTools(): BaseTool[];
    /**
     * Get agent's model name for API exposure
     */
    getModelName(): string;
    /**
     * Get all sub-agents
     */
    getSubAgents(): SubAgentConfig[];
    /**
     * Unregister this agent
     */
    unregister(): void;
    /**
     * Get agent's history manager
     * This provides access to the history manager for direct event handling
     * @returns The history manager instance
     */
    getHistoryManager(): HistoryManager;
    /**
     * Checks if telemetry (VoltAgentExporter) is configured for this agent.
     * @returns True if telemetry is configured, false otherwise.
     */
    isTelemetryConfigured(): boolean;
    /**
     * Add tools or toolkits to the agent dynamically.
     * @param tools Array of tools or toolkits to add to the agent
     * @returns Object containing added tools
     */
    addTools(tools: (Tool<any, any> | Toolkit)[]): {
        added: (Tool<any, any> | Toolkit)[];
    };
    /**
     * @deprecated Use addTools() instead. This method will be removed in a future version.
     * Add one or more tools or toolkits to the agent.
     * @returns Object containing added items
     */
    addItems(items: (Tool<any, any> | Toolkit)[]): {
        added: (Tool<any, any> | Toolkit)[];
    };
    /**
     * @internal
     * Internal method to set the VoltAgentExporter on the agent's HistoryManager.
     * This is typically called by the main VoltAgent instance after it has initialized its exporter.
     */
    _INTERNAL_setVoltAgentExporter(exporter: VoltAgentExporter): void;
    /**
     * Helper method to merge the agent's hooks with the ones passed in the options
     * @param options - The options passed to the generate method
     * @returns The merged hooks
     */
    private getMergedHooks;
    /**
     * Helper method to get retriever context with event handling
     */
    private getRetrieverContext;
}

type AgentConfig$1<SCHEMA extends z.ZodTypeAny> = PublicGenerateOptions & {
    schema: SCHEMA;
};
/**
 * Creates an agent step for a workflow
 *
 * @example
 * ```ts
 * const w = createWorkflow(
 *   andAgent(
 *     ({ data }) => `Generate a greeting for the user ${data.name}`,
 *     agent,
 *     { schema: z.object({ greeting: z.string() }) }
 *   ),
 *   andThen({
 *     id: "extract-greeting",
 *     execute: async ({ data }) => data.greeting
 *   })
 * );
 * ```
 *
 * @param task - The task (prompt) to execute for the agent, can be a string or a function that returns a string
 * @param agent - The agent to execute the task using `generateObject`
 * @param config - The config for the agent (schema) `generateObject` call
 * @returns A workflow step that executes the agent with the task
 */
declare function andAgent<INPUT, DATA, SCHEMA extends z.ZodTypeAny>(task: BaseMessage[] | string | InternalWorkflowFunc<INPUT, DATA, BaseMessage[] | string, any, any>, agent: Agent<{
    llm: DangerouslyAllowAny;
}>, config: AgentConfig$1<SCHEMA>): {
    type: "agent";
    id: string;
    name: string;
    purpose: string | null;
    agent: Agent<{
        llm: DangerouslyAllowAny;
    }>;
    execute: (context: WorkflowExecuteContext<INPUT, DATA, any, any>) => Promise<z.TypeOf<SCHEMA>>;
};

interface WorkflowStepAgent<INPUT, DATA, RESULT> extends InternalBaseWorkflowStep<INPUT, DATA, RESULT, any, any> {
    type: "agent";
    agent: Agent<{
        llm: DangerouslyAllowAny;
    }>;
}
type WorkflowStepFuncConfig<INPUT, DATA, RESULT, SUSPEND_DATA, RESUME_DATA = any> = InternalWorkflowStepConfig<{
    execute: InternalWorkflowFunc<INPUT, DATA, RESULT, SUSPEND_DATA, RESUME_DATA>;
    inputSchema?: z.ZodTypeAny;
    outputSchema?: z.ZodTypeAny;
    suspendSchema?: z.ZodTypeAny;
    resumeSchema?: z.ZodTypeAny;
}>;
interface WorkflowStepFunc<INPUT, DATA, RESULT, SUSPEND_DATA, RESUME_DATA = any> extends InternalBaseWorkflowStep<INPUT, DATA, RESULT, SUSPEND_DATA, RESUME_DATA> {
    type: "func";
}
interface WorkflowStepWorkflow<INPUT, DATA, RESULT, SUSPEND_DATA, RESUME_DATA = any> extends InternalBaseWorkflowStep<INPUT, DATA, RESULT, SUSPEND_DATA, RESUME_DATA> {
    type: "workflow";
    workflow: InternalWorkflow<INPUT, DATA, RESULT>;
}
type WorkflowStepTapConfig<INPUT, DATA, _RESULT, SUSPEND_DATA, RESUME_DATA = any> = InternalWorkflowStepConfig<{
    execute: InternalWorkflowFunc<INPUT, DATA, DangerouslyAllowAny, SUSPEND_DATA, RESUME_DATA>;
    inputSchema?: z.ZodTypeAny;
    suspendSchema?: z.ZodTypeAny;
    resumeSchema?: z.ZodTypeAny;
}>;
interface WorkflowStepTap<INPUT, DATA, _RESULT, SUSPEND_DATA, RESUME_DATA = any> extends InternalBaseWorkflowStep<INPUT, DATA, DATA, SUSPEND_DATA, RESUME_DATA> {
    type: "tap";
}
type WorkflowStepConditionalWhenConfig<INPUT, DATA, RESULT> = InternalWorkflowStepConfig<{
    condition: InternalWorkflowFunc<INPUT, DATA, boolean, any, any>;
    step: InternalAnyWorkflowStep<INPUT, DATA, RESULT>;
    inputSchema?: z.ZodTypeAny;
    outputSchema?: z.ZodTypeAny;
    suspendSchema?: z.ZodTypeAny;
    resumeSchema?: z.ZodTypeAny;
}>;
interface WorkflowStepConditionalWhen<INPUT, DATA, RESULT> extends InternalBaseWorkflowStep<INPUT, DATA, InternalExtractWorkflowInputData<DATA> | RESULT, any, any> {
    type: "conditional-when";
    condition: InternalWorkflowFunc<INPUT, DATA, boolean, any, any>;
}
type WorkflowStepParallelRaceConfig<INPUT, DATA, RESULT> = InternalWorkflowStepConfig<{
    steps: ReadonlyArray<InternalAnyWorkflowStep<INPUT, DATA, RESULT>>;
}>;
interface WorkflowStepParallelRace<INPUT, DATA, RESULT> extends InternalBaseWorkflowStep<INPUT, DATA, RESULT, any, any> {
    type: "parallel-race";
    steps: ReadonlyArray<InternalAnyWorkflowStep<INPUT, DATA, RESULT>>;
}
type WorkflowStepParallelAllConfig<INPUT, DATA, RESULT, STEPS extends ReadonlyArray<InternalAnyWorkflowStep<INPUT, DATA, RESULT>> | WorkflowStepParallelDynamicStepsFunc<INPUT, DATA, RESULT>> = InternalWorkflowStepConfig<{
    steps: STEPS;
}>;
interface WorkflowStepParallelAll<INPUT, DATA, RESULT> extends InternalBaseWorkflowStep<INPUT, DATA, RESULT, any, any> {
    type: "parallel-all";
    steps: WorkflowStepParallelSteps<INPUT, DATA, RESULT> | WorkflowStepParallelDynamicStepsFunc<INPUT, DATA, RESULT>;
}
type WorkflowStepParallelDynamicStepsFunc<INPUT, DATA, RESULT> = (context: WorkflowExecuteContext<INPUT, DATA, any, any>) => Promise<WorkflowStepParallelSteps<INPUT, DATA, RESULT>>;
type WorkflowStepParallelSteps<INPUT, DATA, RESULT> = ReadonlyArray<InternalAnyWorkflowStep<INPUT, DATA, RESULT>>;
type WorkflowStep<INPUT, DATA, RESULT, SUSPEND_DATA = any> = WorkflowStepAgent<INPUT, DATA, RESULT> | WorkflowStepFunc<INPUT, DATA, RESULT, SUSPEND_DATA> | WorkflowStepConditionalWhen<INPUT, DATA, RESULT> | WorkflowStepParallelAll<INPUT, DATA, RESULT> | WorkflowStepTap<INPUT, DATA, RESULT, SUSPEND_DATA> | WorkflowStepParallelRace<INPUT, DATA, RESULT> | WorkflowStepWorkflow<INPUT, DATA, RESULT, SUSPEND_DATA>;
/**
 * Internal type to allow overriding the run method for the workflow
 */
interface InternalWorkflow<_INPUT, DATA, RESULT> extends Omit<Workflow<DangerouslyAllowAny, DangerouslyAllowAny>, "run"> {
    run: (input: InternalExtractWorkflowInputData<DATA>, options?: InternalWorkflowRunOptions) => Promise<{
        executionId: string;
        startAt: Date;
        endAt: Date;
        status: "completed";
        result: RESULT;
    }>;
}
interface InternalWorkflowRunOptions extends WorkflowRunOptions {
}

/**
 * Creates an async function step for the workflow
 *
 * @example
 * ```ts
 * const w = createWorkflow(
 *   andThen({
 *     id: "process-data",
 *     execute: async ({ data }) => {
 *       const processed = await someAsyncOperation(data.value);
 *       return { ...data, processed };
 *     }
 *   }),
 *   andThen({
 *     id: "format-result",
 *     execute: async ({ data }) => {
 *       return { result: `Processed: ${data.processed}` };
 *     }
 *   })
 * );
 * ```
 *
 * @param config - Configuration object with execute function and metadata
 * @returns A workflow step that executes the function and returns the result
 */
declare function andThen<INPUT, DATA, RESULT, SUSPEND_DATA = DangerouslyAllowAny, RESUME_DATA = DangerouslyAllowAny>({ execute, inputSchema, outputSchema, suspendSchema, resumeSchema, ...config }: WorkflowStepFuncConfig<INPUT, DATA, RESULT, SUSPEND_DATA, RESUME_DATA>): WorkflowStepFunc<INPUT, DATA, RESULT, SUSPEND_DATA, RESUME_DATA>;

/**
 * Creates a conditional step for the workflow that executes only when a condition is met
 *
 * @example
 * ```ts
 * const w = createWorkflow(
 *   andWhen({
 *     id: "admin-permissions",
 *     condition: async ({ data }) => data.userType === "admin",
 *     execute: async ({ data }) => {
 *       return { ...data, permissions: ["read", "write", "delete"] };
 *     }
 *   }),
 *   andWhen({
 *     id: "high-value-processing",
 *     condition: async ({ data }) => data.value > 100,
 *     step: andAgent(
 *       ({ data }) => `Process high value transaction: ${data.value}`,
 *       agent,
 *       { schema: z.object({ processed: z.boolean() }) }
 *     )
 *   })
 * );
 * ```
 *
 * @param config - Configuration object with condition, step/execute function, and metadata
 * @returns A conditional workflow step that executes the step only when the condition evaluates to true
 */
declare function andWhen<INPUT, DATA, RESULT>({ condition, step, inputSchema, outputSchema, suspendSchema, resumeSchema, ...config }: WorkflowStepConditionalWhenConfig<INPUT, DATA, RESULT>): WorkflowStepConditionalWhen<INPUT, DATA, RESULT>;

/**
 * Creates a parallel execution step that runs multiple steps simultaneously and waits for all to complete
 *
 * @example
 * ```ts
 * const w = createWorkflow(
 *   andAll({
 *     id: "parallel-fetch",
 *     steps: [
 *       andThen({
 *         id: "fetch-user",
 *         execute: async ({ data }) => {
 *           const userInfo = await fetchUserInfo(data.userId);
 *           return { userInfo };
 *         }
 *       }),
 *       andThen({
 *         id: "fetch-permissions",
 *         execute: async ({ data }) => {
 *           const permissions = await fetchPermissions(data.userId);
 *           return { permissions };
 *         }
 *       }),
 *       andAgent(
 *         ({ data }) => `Generate recommendations for user ${data.userId}`,
 *         agent,
 *         { schema: z.object({ recommendations: z.array(z.string()) }) }
 *       )
 *     ]
 *   }),
 *   andThen({
 *     id: "combine-results",
 *     execute: async ({ data }) => {
 *       // data is now an array: [{ userInfo }, { permissions }, { recommendations }]
 *       return { combined: data.flat() };
 *     }
 *   })
 * );
 * ```
 *
 * @param config - Configuration object with steps array and metadata
 * @returns A workflow step that executes all steps simultaneously and returns their results as an array
 */
declare function andAll<INPUT, DATA, RESULT, STEPS extends ReadonlyArray<InternalAnyWorkflowStep<INPUT, DATA, RESULT>> | WorkflowStepParallelDynamicStepsFunc<INPUT, DATA, RESULT>>({ steps: inputSteps, ...config }: WorkflowStepParallelAllConfig<INPUT, DATA, RESULT, STEPS>): {
    type: "parallel-all";
    steps: InternalAnyWorkflowStep<INPUT, DATA, STEPS extends readonly InternalAnyWorkflowStep<INPUT, DATA, RESULT>[] ? InternalInferWorkflowStepsResult<STEPS> : STEPS extends WorkflowStepParallelDynamicStepsFunc<INPUT, DATA, RESULT> ? InternalInferWorkflowStepsResult<Awaited<ReturnType<STEPS>>> : never>[];
    execute: (context: WorkflowExecuteContext<INPUT, DATA, any, any>) => Promise<STEPS extends readonly InternalAnyWorkflowStep<INPUT, DATA, RESULT>[] ? InternalInferWorkflowStepsResult<STEPS> : STEPS extends WorkflowStepParallelDynamicStepsFunc<INPUT, DATA, RESULT> ? InternalInferWorkflowStepsResult<Awaited<ReturnType<STEPS>>> : never>;
    id: string;
    name: string;
    purpose: string;
};

/**
 * Creates a race execution step that runs multiple steps simultaneously and returns the first completed result
 *
 * @example
 * ```ts
 * const w = createWorkflow(
 *   andRace({
 *     id: "race-data-sources",
 *     steps: [
 *       andThen({
 *         id: "check-cache",
 *         execute: async ({ data }) => {
 *           // Fast operation
 *           const cacheResult = await checkCache(data.query);
 *           return { source: "cache", result: cacheResult };
 *         }
 *       }),
 *       andThen({
 *         id: "query-database",
 *         execute: async ({ data }) => {
 *           // Slower operation
 *           const dbResult = await queryDatabase(data.query);
 *           return { source: "database", result: dbResult };
 *         }
 *       }),
 *       andAgent(
 *         ({ data }) => `Generate fallback response for: ${data.query}`,
 *         agent,
 *         { schema: z.object({ source: z.literal("ai"), result: z.string() }) }
 *       )
 *     ]
 *   }),
 *   andThen({
 *     id: "process-result",
 *     execute: async ({ data }) => {
 *       // data is the result from whichever step completed first
 *       return { finalResult: data.result, source: data.source };
 *     }
 *   })
 * );
 * ```
 *
 * @param config - Configuration object with steps array and metadata
 * @returns A workflow step that executes all steps simultaneously and returns the result from the first step to complete
 */
declare function andRace<INPUT, DATA, RESULT, STEPS extends ReadonlyArray<InternalAnyWorkflowStep<INPUT, DATA, RESULT>>>({ steps, ...config }: InternalWorkflowStepConfig<{
    steps: STEPS;
}>): {
    type: "parallel-race";
    steps: InternalAnyWorkflowStep<INPUT, DATA, InternalInferWorkflowStepsResult<STEPS>[number]>[];
    execute: (context: WorkflowExecuteContext<INPUT, DATA, any, any>) => Promise<InternalInferWorkflowStepsResult<STEPS>[number]>;
    id: string;
    name: string;
    purpose: string;
};

/**
 * A safe way to tap into the workflow state without affecting the result.
 *
 * @example
 * ```ts
 * const w = createWorkflow(
 *   andTap({
 *     id: "log-processing",
 *     execute: async ({ data }) => {
 *       console.log("Processing data:", data);
 *     }
 *   }),
 *   andThen({
 *     id: "process-data",
 *     execute: async ({ data }) => {
 *       // data is unchanged from the tap step
 *       return { ...data, processed: true };
 *     }
 *   })
 * );
 * ```
 *
 * @param config - Configuration object with execute function and metadata
 * @returns A workflow step that executes the function
 */
declare function andTap<INPUT, DATA, RESULT, SUSPEND_DATA = DangerouslyAllowAny, RESUME_DATA = DangerouslyAllowAny>({ execute, inputSchema, suspendSchema, resumeSchema, ...config }: WorkflowStepTapConfig<INPUT, DATA, RESULT, SUSPEND_DATA, RESUME_DATA>): {
    type: "tap";
    inputSchema: zod.ZodTypeAny | undefined;
    suspendSchema: zod.ZodTypeAny | undefined;
    resumeSchema: zod.ZodTypeAny | undefined;
    execute: (context: WorkflowExecuteContext<INPUT, DATA, SUSPEND_DATA, RESUME_DATA>) => Promise<DATA>;
    id: string;
    name: string;
    purpose: string;
};

/**
 * Creates an async function step for the workflow
 *
 * EXPERIMENTAL: This step is experimental and doesn't directly hook into or support the Observability
 *
 * @example
 * ```ts
 * const nestedWorkflow = createWorkflow(
 *   andThen({
 *     id: "nested-process",
 *     execute: async ({ data }) => {
 *       const processed = await someAsyncOperation(data.value);
 *       return { ...data, processed };
 *     }
 *   })
 * );
 *
 * const w = createWorkflow(
 *   andThen({
 *     id: "main-process",
 *     execute: async ({ data }) => {
 *       const processed = await someAsyncOperation(data.value);
 *       return { ...data, processed };
 *     }
 *   }),
 *   andWorkflow(nestedWorkflow)
 * );
 * ```
 *
 * @param workflow - The workflow to execute as a step
 * @returns A workflow step that executes the function and returns the result
 */
declare function andWorkflow<INPUT, DATA, RESULT, SUSPEND_DATA = any, RESUME_DATA = any>(workflow: InternalWorkflow<INPUT, DATA, RESULT>): WorkflowStepWorkflow<INPUT, DATA, RESULT, SUSPEND_DATA, RESUME_DATA>;

/**
 * Creates a workflow from multiple and* functions
 *
 * @example
 * ```ts
 * const workflow = createWorkflow({
 *   id: "user-processing",
 *   name: "User Processing Workflow",
 *   purpose: "Process user data and generate personalized content",
 *   input: z.object({ userId: z.string(), userType: z.enum(["admin", "user"]) }),
 *   result: z.object({ processed: z.boolean(), content: z.string() }),
 *   memory: new LibSQLStorage({ url: "file:memory.db" }) // Optional workflow-specific memory
 * },
 *   andThen({
 *     id: "fetch-user",
 *     execute: async ({ data }) => {
 *       const userInfo = await fetchUserInfo(data.userId);
 *       return { ...data, userInfo };
 *     }
 *   }),
 *   andWhen({
 *     id: "admin-permissions",
 *     condition: async ({ data }) => data.userType === "admin",
 *     execute: async ({ data }) => ({ ...data, permissions: ["read", "write", "delete"] })
 *   }),
 *   andAgent(
 *     ({ data }) => `Generate personalized content for ${data.userInfo.name}`,
 *     agent,
 *     { schema: z.object({ content: z.string() }) }
 *   ),
 *   andThen({
 *     id: "finalize-result",
 *     execute: async ({ data }) => ({
 *       processed: true,
 *       content: data.content
 *     })
 *   })
 * );
 *
 * // Run with optional memory override
 * const result = await workflow.run(
 *   { userId: "123", userType: "admin" },
 *   { memory: new LibSQLStorage({ url: "file:memory.db" }) }
 * );
 * ```
 *
 * @param config - The workflow configuration
 * @param steps - Variable number of and* functions to execute
 * @returns A configured workflow instance
 */
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3, S4>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, S4>, s5: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S4, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3, S4, S5>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, S4>, s5: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S4, S5>, s6: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S5, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3, S4, S5, S6>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, S4>, s5: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S4, S5>, s6: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S5, S6>, s7: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S6, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3, S4, S5, S6, S7>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, S4>, s5: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S4, S5>, s6: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S5, S6>, s7: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S6, S7>, s8: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S7, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3, S4, S5, S6, S7, S8>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, S4>, s5: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S4, S5>, s6: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S5, S6>, s7: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S6, S7>, s8: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S7, S8>, s9: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S8, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3, S4, S5, S6, S7, S8, S9>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, S4>, s5: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S4, S5>, s6: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S5, S6>, s7: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S6, S7>, s8: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S7, S8>, s9: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S8, S9>, s10: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S9, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3, S4, S5, S6, S7, S8, S9, S10>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, S4>, s5: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S4, S5>, s6: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S5, S6>, s7: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S6, S7>, s8: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S7, S8>, s9: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S8, S9>, s10: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S9, S10>, s11: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S10, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, S4>, s5: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S4, S5>, s6: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S5, S6>, s7: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S6, S7>, s8: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S7, S8>, s9: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S8, S9>, s10: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S9, S10>, s11: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S10, S11>, s12: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S11, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11, S12>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, S4>, s5: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S4, S5>, s6: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S5, S6>, s7: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S6, S7>, s8: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S7, S8>, s9: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S8, S9>, s10: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S9, S10>, s11: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S10, S11>, s12: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S11, S12>, s13: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S12, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11, S12, S13>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, S4>, s5: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S4, S5>, s6: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S5, S6>, s7: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S6, S7>, s8: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S7, S8>, s9: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S8, S9>, s10: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S9, S10>, s11: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S10, S11>, s12: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S11, S12>, s13: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S12, S13>, s14: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S13, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11, S12, S13, S14>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, S4>, s5: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S4, S5>, s6: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S5, S6>, s7: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S6, S7>, s8: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S7, S8>, s9: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S8, S9>, s10: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S9, S10>, s11: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S10, S11>, s12: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S11, S12>, s13: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S12, S13>, s14: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S13, S14>, s15: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S14, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11, S12, S13, S14, S15>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, S4>, s5: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S4, S5>, s6: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S5, S6>, s7: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S6, S7>, s8: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S7, S8>, s9: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S8, S9>, s10: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S9, S10>, s11: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S10, S11>, s12: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S11, S12>, s13: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S12, S13>, s14: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S13, S14>, s15: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S14, S15>, s16: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S15, WorkflowResult<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11, S12, S13, S14, S15, S16>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, S4>, s5: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S4, S5>, s6: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S5, S6>, s7: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S6, S7>, s8: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S7, S8>, s9: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S8, S9>, s10: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S9, S10>, s11: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S10, S11>, s12: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S11, S12>, s13: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S12, S13>, s14: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S13, S14>, s15: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S14, S15>, s16: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S15, S16>, s17: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S16, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11, S12, S13, S14, S15, S16, S17>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, S4>, s5: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S4, S5>, s6: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S5, S6>, s7: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S6, S7>, s8: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S7, S8>, s9: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S8, S9>, s10: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S9, S10>, s11: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S10, S11>, s12: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S11, S12>, s13: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S12, S13>, s14: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S13, S14>, s15: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S14, S15>, s16: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S15, S16>, s17: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S16, S17>, s18: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S17, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11, S12, S13, S14, S15, S16, S17, S18>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, S4>, s5: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S4, S5>, s6: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S5, S6>, s7: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S6, S7>, s8: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S7, S8>, s9: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S8, S9>, s10: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S9, S10>, s11: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S10, S11>, s12: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S11, S12>, s13: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S12, S13>, s14: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S13, S14>, s15: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S14, S15>, s16: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S15, S16>, s17: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S16, S17>, s18: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S17, S18>, s19: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S18, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;
declare function createWorkflow<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11, S12, S13, S14, S15, S16, S17, S18, S19>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA>, s1: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, WorkflowInput<INPUT_SCHEMA>, S1>, s2: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S1, S2>, s3: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S2, S3>, s4: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S3, S4>, s5: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S4, S5>, s6: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S5, S6>, s7: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S6, S7>, s8: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S7, S8>, s9: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S8, S9>, s10: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S9, S10>, s11: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S10, S11>, s12: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S11, S12>, s13: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S12, S13>, s14: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S13, S14>, s15: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S14, S15>, s16: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S15, S16>, s17: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S16, S17>, s18: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S17, S18>, s19: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S18, S19>, s20: WorkflowStep<WorkflowInput<INPUT_SCHEMA>, S19, z.infer<RESULT_SCHEMA>>): Workflow<INPUT_SCHEMA, RESULT_SCHEMA>;

/**
 * Agent configuration for the chain
 */
type AgentConfig<SCHEMA extends z.ZodTypeAny> = {
    schema: SCHEMA;
};
/**
 * A workflow chain that provides a fluent API for building workflows
 *
 * @example
 * ```ts
 * const workflow = createWorkflowChain({
 *   id: "user-processing",
 *   name: "User Processing Workflow",
 *   purpose: "Process user data and generate personalized content",
 *   input: z.object({ userId: z.string(), userType: z.enum(["admin", "user"]) }),
 *   result: z.object({ processed: z.boolean(), content: z.string() }),
 *   memory: new LibSQLStorage({ url: "file:memory.db" }) // Optional workflow-specific memory
 * })
 *   .andThen({
 *     id: "fetch-user",
 *     execute: async ({ data }) => {
 *       const userInfo = await fetchUserInfo(data.userId);
 *       return { ...data, userInfo };
 *     }
 *   })
 *   .andWhen({
 *     id: "admin-permissions",
 *     condition: async ({ data }) => data.userType === "admin",
 *     execute: async ({ data }) => ({ ...data, permissions: ["read", "write", "delete"] })
 *   })
 *   .andAgent(
 *     ({ data }) => `Generate personalized content for ${data.userInfo.name}`,
 *     agent,
 *     { schema: z.object({ content: z.string() }) }
 *   )
 *   .andThen({
 *     id: "finalize-result",
 *     execute: async ({ data }) => ({
 *       processed: true,
 *       content: data.content
 *     })
 *   });
 *
 * // Run with optional memory override
 * const result = await workflow.run(
 *   { userId: "123", userType: "admin" },
 *   { memory: new LibSQLStorage({ url: "file:memory.db" }) }
 * );
 * ```
 */
declare class WorkflowChain<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, CURRENT_DATA = WorkflowInput<INPUT_SCHEMA>, SUSPEND_SCHEMA extends z.ZodTypeAny = z.ZodAny, RESUME_SCHEMA extends z.ZodTypeAny = z.ZodAny> {
    private steps;
    private config;
    constructor(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA, SUSPEND_SCHEMA, RESUME_SCHEMA>);
    /**
     * Creates an agent step for a workflow
     *
     * @example
     * ```ts
     * const w = createWorkflowChain({
     *   id: "greeting-workflow",
     *   input: z.object({ name: z.string() }),
     *   result: z.string()
     * })
     *   .andAgent(
     *     ({ data }) => `Generate a greeting for the user ${data.name}`,
     *     agent,
     *     { schema: z.object({ greeting: z.string() }) }
     *   )
     *   .andThen({
     *     id: "extract-greeting",
     *     execute: async ({ data }) => data.greeting
     *   })
     * ```
     *
     * @param task - The task (prompt) to execute for the agent, can be a string or a function that returns a string
     * @param agent - The agent to execute the task using `generateObject`
     * @param config - The config for the agent (schema) `generateObject` call
     * @returns A workflow step that executes the agent with the task
     */
    andAgent<SCHEMA extends z.ZodTypeAny>(task: string | InternalWorkflowFunc<INPUT_SCHEMA, CURRENT_DATA, string, any, any>, agent: Agent<{
        llm: DangerouslyAllowAny;
    }>, config: AgentConfig<SCHEMA>): WorkflowChain<INPUT_SCHEMA, RESULT_SCHEMA, z.infer<SCHEMA>, SUSPEND_SCHEMA, RESUME_SCHEMA>;
    /**
     * Add a function step to the workflow with both input and output schemas
     * @param config - Step configuration with schemas
     * @returns A new chain with the function step added
     */
    andThen<IS extends z.ZodTypeAny, OS extends z.ZodTypeAny, SS extends z.ZodTypeAny = z.ZodTypeAny, RS extends z.ZodTypeAny = z.ZodTypeAny>(config: {
        inputSchema: IS;
        outputSchema: OS;
        suspendSchema?: SS;
        resumeSchema?: RS;
        execute: (context: {
            data: z.infer<IS>;
            state: any;
            getStepData: (stepId: string) => {
                input: any;
                output: any;
            } | undefined;
            suspend: (reason?: string, suspendData?: SS extends z.ZodTypeAny ? z.infer<SS> : z.infer<SUSPEND_SCHEMA>) => Promise<never>;
            resumeData?: RS extends z.ZodTypeAny ? z.infer<RS> : z.infer<RESUME_SCHEMA>;
            logger: Logger;
            writer: WorkflowStreamWriter;
        }) => Promise<z.infer<OS>>;
        id: string;
        name?: string;
        purpose?: string;
    }): WorkflowChain<INPUT_SCHEMA, RESULT_SCHEMA, z.infer<OS>, SUSPEND_SCHEMA, RESUME_SCHEMA>;
    /**
     * Add a function step to the workflow with only input schema
     * @param config - Step configuration with input schema
     * @returns A new chain with the function step added
     */
    andThen<IS extends z.ZodTypeAny, NEW_DATA, SS extends z.ZodTypeAny = z.ZodTypeAny, RS extends z.ZodTypeAny = z.ZodTypeAny>(config: {
        inputSchema: IS;
        outputSchema?: never;
        suspendSchema?: SS;
        resumeSchema?: RS;
        execute: (context: {
            data: z.infer<IS>;
            state: any;
            getStepData: (stepId: string) => {
                input: any;
                output: any;
            } | undefined;
            suspend: (reason?: string, suspendData?: SS extends z.ZodTypeAny ? z.infer<SS> : z.infer<SUSPEND_SCHEMA>) => Promise<never>;
            resumeData?: RS extends z.ZodTypeAny ? z.infer<RS> : z.infer<RESUME_SCHEMA>;
            logger: Logger;
            writer: WorkflowStreamWriter;
        }) => Promise<NEW_DATA>;
        id: string;
        name?: string;
        purpose?: string;
    }): WorkflowChain<INPUT_SCHEMA, RESULT_SCHEMA, NEW_DATA, SUSPEND_SCHEMA, RESUME_SCHEMA>;
    /**
     * Add a function step to the workflow with only output schema
     * @param config - Step configuration with output schema
     * @returns A new chain with the function step added
     */
    andThen<OS extends z.ZodTypeAny, SS extends z.ZodTypeAny = z.ZodTypeAny, RS extends z.ZodTypeAny = z.ZodTypeAny>(config: {
        inputSchema?: never;
        outputSchema: OS;
        suspendSchema?: SS;
        resumeSchema?: RS;
        execute: (context: {
            data: CURRENT_DATA;
            state: any;
            getStepData: (stepId: string) => {
                input: any;
                output: any;
            } | undefined;
            suspend: (reason?: string, suspendData?: SS extends z.ZodTypeAny ? z.infer<SS> : z.infer<SUSPEND_SCHEMA>) => Promise<never>;
            resumeData?: RS extends z.ZodTypeAny ? z.infer<RS> : z.infer<RESUME_SCHEMA>;
            logger: Logger;
            writer: WorkflowStreamWriter;
        }) => Promise<z.infer<OS>>;
        id: string;
        name?: string;
        purpose?: string;
    }): WorkflowChain<INPUT_SCHEMA, RESULT_SCHEMA, z.infer<OS>, SUSPEND_SCHEMA, RESUME_SCHEMA>;
    /**
     * Add a function step to the workflow with only resumeSchema
     * @param config - Step configuration with resumeSchema
     * @returns A new chain with the function step added
     */
    andThen<NEW_DATA, SS extends z.ZodTypeAny = z.ZodTypeAny, RS extends z.ZodTypeAny = z.ZodTypeAny>(config: {
        inputSchema?: never;
        outputSchema?: never;
        suspendSchema?: SS;
        resumeSchema: RS;
        execute: (context: {
            data: CURRENT_DATA;
            state: any;
            getStepData: (stepId: string) => {
                input: any;
                output: any;
            } | undefined;
            suspend: (reason?: string, suspendData?: SS extends z.ZodTypeAny ? z.infer<SS> : z.infer<SUSPEND_SCHEMA>) => Promise<never>;
            resumeData?: z.infer<RS>;
            logger: Logger;
            writer: WorkflowStreamWriter;
        }) => Promise<NEW_DATA>;
        id: string;
        name?: string;
        purpose?: string;
    }): WorkflowChain<INPUT_SCHEMA, RESULT_SCHEMA, NEW_DATA, SUSPEND_SCHEMA, RESUME_SCHEMA>;
    /**
     * Add a function step to the workflow
     *
     * @example
     * ```ts
     * const workflow = createWorkflowChain(config)
     *   .andThen({
     *     id: "process",
     *     execute: async ({ data }) => {
     *       const processed = await someAsyncOperation(data.value);
     *       return { ...data, processed };
     *     }
     *   })
     *   .andThen({
     *     id: "enrich",
     *     execute: async ({ data }) => {
     *       const enriched = await enrichData(data.processed);
     *       return { ...data, enriched };
     *     }
     *   });
     * ```
     *
     * @param config - Step configuration
     * @returns A new chain with the function step added
     */
    andThen<NEW_DATA>(config: {
        execute: (context: {
            data: CURRENT_DATA;
            state: any;
            getStepData: (stepId: string) => {
                input: any;
                output: any;
            } | undefined;
            suspend: (reason?: string, suspendData?: z.infer<SUSPEND_SCHEMA>) => Promise<never>;
            resumeData?: z.infer<RESUME_SCHEMA>;
            logger: Logger;
            writer: WorkflowStreamWriter;
        }) => Promise<NEW_DATA>;
        id: string;
        name?: string;
        purpose?: string;
        inputSchema?: never;
        outputSchema?: never;
        suspendSchema?: z.ZodTypeAny;
        resumeSchema?: z.ZodTypeAny;
    }): WorkflowChain<INPUT_SCHEMA, RESULT_SCHEMA, NEW_DATA, SUSPEND_SCHEMA, RESUME_SCHEMA>;
    /**
     * Add a conditional step with explicit schemas
     * @param config - Step configuration with schemas
     * @returns A new chain with the conditional step added
     */
    andWhen<IS extends z.ZodTypeAny, OS extends z.ZodTypeAny, SS extends z.ZodTypeAny = z.ZodTypeAny, RS extends z.ZodTypeAny = z.ZodTypeAny>(config: WorkflowStepConditionalWhenConfig<WorkflowInput<INPUT_SCHEMA>, z.infer<IS>, z.infer<OS>> & {
        inputSchema: IS;
        outputSchema: OS;
        suspendSchema?: SS;
        resumeSchema?: RS;
        condition: (context: {
            data: z.infer<IS>;
            state: any;
            getStepData: (stepId: string) => {
                input: any;
                output: any;
            } | undefined;
            suspend: (reason?: string, suspendData?: SS extends z.ZodTypeAny ? z.infer<SS> : z.infer<SUSPEND_SCHEMA>) => Promise<never>;
            resumeData?: RS extends z.ZodTypeAny ? z.infer<RS> : z.infer<RESUME_SCHEMA>;
            logger: Logger;
            writer: WorkflowStreamWriter;
        }) => Promise<boolean>;
    }): WorkflowChain<INPUT_SCHEMA, RESULT_SCHEMA, z.infer<OS> | z.infer<IS>, SUSPEND_SCHEMA, RESUME_SCHEMA>;
    /**
     * Add a conditional step that executes when a condition is true
     *
     * @example
     * ```ts
     * const workflow = createWorkflowChain(config)
     *   .andWhen({
     *     id: "admin-permissions",
     *     condition: async ({ data }) => data.userType === "admin",
     *     execute: async ({ data }) => ({ ...data, permissions: ["read", "write", "delete"] })
     *   })
     *   .andWhen({
     *     id: "high-value-flag",
     *     condition: async ({ data }) => data.value > 1000,
     *     execute: async ({ data }) => ({ ...data, flagged: true, requiresReview: true })
     *   })
     *   .andWhen({
     *     id: "process-pending",
     *     condition: async ({ data }) => data.status === "pending",
     *     execute: async ({ data }) => {
     *       const result = await agent.generateObject(
     *         `Process pending request for ${data.userId}`,
     *         z.object({ processed: z.boolean() })
     *       );
     *       return { ...data, ...result.object };
     *     }
     *   });
     * ```
     *
     * @param condition - Function that determines if the step should execute based on the current data
     * @param stepInput - Either a workflow step or an agent to execute when the condition is true
     * @returns A new chain with the conditional step added
     */
    andWhen<NEW_DATA>(config: WorkflowStepConditionalWhenConfig<WorkflowInput<INPUT_SCHEMA>, CURRENT_DATA, NEW_DATA> & {
        inputSchema?: never;
        outputSchema?: never;
        suspendSchema?: z.ZodTypeAny;
        resumeSchema?: z.ZodTypeAny;
    }): WorkflowChain<INPUT_SCHEMA, RESULT_SCHEMA, NEW_DATA | CURRENT_DATA, SUSPEND_SCHEMA, RESUME_SCHEMA>;
    /**
     * Add a tap step to the workflow with optional input schema
     * @param config - Step configuration with optional inputSchema
     * @returns A new chain with the tap step added (data unchanged)
     */
    andTap<IS extends z.ZodTypeAny, SS extends z.ZodTypeAny = z.ZodTypeAny, RS extends z.ZodTypeAny = z.ZodTypeAny>(config: {
        inputSchema: IS;
        suspendSchema?: SS;
        resumeSchema?: RS;
        execute: (context: {
            data: z.infer<IS>;
            state: any;
            getStepData: (stepId: string) => {
                input: any;
                output: any;
            } | undefined;
            suspend: (reason?: string, suspendData?: SS extends z.ZodTypeAny ? z.infer<SS> : z.infer<SUSPEND_SCHEMA>) => Promise<never>;
            resumeData?: RS extends z.ZodTypeAny ? z.infer<RS> : z.infer<RESUME_SCHEMA>;
            logger: Logger;
            writer: WorkflowStreamWriter;
        }) => Promise<void>;
        id: string;
        name?: string;
        purpose?: string;
    }): WorkflowChain<INPUT_SCHEMA, RESULT_SCHEMA, CURRENT_DATA, SUSPEND_SCHEMA, RESUME_SCHEMA>;
    /**
     * Add a tap step to the workflow
     *
     * @example
     * ```ts
     * const workflow = createWorkflowChain(config)
     *   .andTap({
     *     id: "log-translation",
     *     execute: async ({ data }) => {
     *       console.log(" Translating text:", data);
     *     }
     *   })
     *   .andThen({
     *     id: "return-translation",
     *     // the input data is still the same as the andTap ONLY executes, it doesn't return anything
     *     execute: async ({ data }) => {
     *       return { ...data, translatedText: data.translatedText };
     *     }
     *   });
     * ```
     *
     * @param fn - The async function to execute with the current workflow data
     * @returns A new chain with the tap step added
     */
    andTap<_NEW_DATA>(config: {
        execute: (context: {
            data: CURRENT_DATA;
            state: any;
            getStepData: (stepId: string) => {
                input: any;
                output: any;
            } | undefined;
            suspend: (reason?: string, suspendData?: z.infer<SUSPEND_SCHEMA>) => Promise<never>;
            resumeData?: z.infer<RESUME_SCHEMA>;
            logger: Logger;
            writer: WorkflowStreamWriter;
        }) => Promise<void>;
        id: string;
        name?: string;
        purpose?: string;
        inputSchema?: never;
        suspendSchema?: z.ZodTypeAny;
        resumeSchema?: z.ZodTypeAny;
    }): WorkflowChain<INPUT_SCHEMA, RESULT_SCHEMA, CURRENT_DATA, SUSPEND_SCHEMA, RESUME_SCHEMA>;
    /**
     * Add a workflow step to the workflow
     *
     * @example
     * ```ts
     * import { myWorkflow } from "./my-workflow";
     *
     * const workflow = createWorkflowChain(config)
     *   .andThen({
     *     id: "fetch-user",
     *     execute: async ({ data }) => {
     *       const userInfo = await fetchUserInfo(data.userId);
     *       return { userInfo };
     *     }
     *   })
     *   .andWorkflow(myWorkflow)
     * ```
     */
    andWorkflow<NEW_DATA>(workflow: InternalWorkflow<INPUT_SCHEMA, CURRENT_DATA, NEW_DATA>): WorkflowChain<INPUT_SCHEMA, RESULT_SCHEMA, NEW_DATA>;
    /**
     * Add a parallel execution step that runs multiple steps simultaneously and waits for all to complete
     *
     * @example
     * ```ts
     * const workflow = createWorkflowChain(config)
     *   .andAll({
     *     id: "parallel-fetch",
     *     steps: [
     *       {
     *         id: "fetch-user",
     *         execute: async ({ data }) => {
     *           const userInfo = await fetchUserInfo(data.userId);
     *           return { userInfo };
     *         }
     *       },
     *       {
     *         id: "fetch-permissions",
     *         execute: async ({ data }) => {
     *           const permissions = await fetchPermissions(data.userId);
     *           return { permissions };
     *         }
     *       },
     *       {
     *         id: "generate-recommendations",
     *         execute: async ({ data }) => {
     *           const result = await agent.generateObject(
     *             `Generate recommendations for user ${data.userId}`,
     *             z.object({ recommendations: z.array(z.string()) })
     *           );
     *           return result.object;
     *         }
     *       }
     *     ]
     *   })
     *   .andThen({
     *     id: "combine-results",
     *     execute: async ({ data }) => {
     *       // data is now an array: [{ userInfo }, { permissions }, { recommendations }]
     *       return { combined: data.flat() };
     *     }
     *   });
     * ```
     *
     * @param steps - Array of workflow steps to execute in parallel
     * @returns A new chain with the parallel step added
     */
    andAll<NEW_DATA, STEPS extends ReadonlyArray<InternalAnyWorkflowStep<WorkflowInput<INPUT_SCHEMA>, CURRENT_DATA, NEW_DATA>>, INFERRED_RESULT = InternalInferWorkflowStepsResult<STEPS>>({ steps, ...config }: WorkflowStepParallelAllConfig<WorkflowInput<INPUT_SCHEMA>, CURRENT_DATA, NEW_DATA, STEPS>): WorkflowChain<INPUT_SCHEMA, RESULT_SCHEMA, INFERRED_RESULT, SUSPEND_SCHEMA, RESUME_SCHEMA>;
    /**
     * Add a race execution step that runs multiple steps simultaneously and returns the first completed result
     *
     * @example
     * ```ts
     * const workflow = createWorkflowChain(config)
     *   .andRace({
     *     id: "race-data-sources",
     *     steps: [
     *       {
     *         id: "check-cache",
     *         execute: async ({ data }) => {
     *           // Fast operation
     *           const cacheResult = await checkCache(data.query);
     *           return { source: "cache", result: cacheResult };
     *         }
     *       },
     *       {
     *         id: "query-database",
     *         execute: async ({ data }) => {
     *           // Slower operation
     *           const dbResult = await queryDatabase(data.query);
     *           return { source: "database", result: dbResult };
     *         }
     *       },
     *       {
     *         id: "ai-fallback",
     *         execute: async ({ data }) => {
     *           const result = await agent.generateObject(
     *             `Generate fallback response for: ${data.query}`,
     *             z.object({ source: z.literal("ai"), result: z.string() })
     *           );
     *           return result.object;
     *         }
     *       }
     *     ]
     *   })
     *   .andThen({
     *     id: "process-result",
     *     execute: async ({ data }) => {
     *       // data is the result from whichever step completed first
     *       return { finalResult: data.result, source: data.source };
     *     }
     *   });
     * ```
     *
     * @param steps - Array of workflow steps to execute in parallel
     * @returns A new chain with the race step added
     */
    andRace<NEW_DATA, STEPS extends ReadonlyArray<InternalAnyWorkflowStep<WorkflowInput<INPUT_SCHEMA>, CURRENT_DATA, NEW_DATA>>, INFERRED_RESULT = InternalInferWorkflowStepsResult<STEPS>[number]>({ steps, ...config }: WorkflowStepParallelRaceConfig<STEPS, CURRENT_DATA, NEW_DATA>): WorkflowChain<INPUT_SCHEMA, RESULT_SCHEMA, INFERRED_RESULT, SUSPEND_SCHEMA, RESUME_SCHEMA>;
    /**
     * Convert the current chain to a runnable workflow
     */
    toWorkflow(): Workflow<INPUT_SCHEMA, RESULT_SCHEMA, SUSPEND_SCHEMA, RESUME_SCHEMA>;
    /**
     * Execute the workflow with the given input
     */
    run(input: WorkflowInput<INPUT_SCHEMA>, options?: WorkflowRunOptions): Promise<WorkflowExecutionResult<RESULT_SCHEMA, RESUME_SCHEMA>>;
    /**
     * Execute the workflow with streaming support
     */
    stream(input: WorkflowInput<INPUT_SCHEMA>, options?: WorkflowRunOptions): WorkflowStreamResult<RESULT_SCHEMA, RESUME_SCHEMA>;
}
/**
 * Creates a new workflow chain with the given configuration
 */
declare function createWorkflowChain<INPUT_SCHEMA extends InternalBaseWorkflowInputSchema, RESULT_SCHEMA extends z.ZodTypeAny, SUSPEND_SCHEMA extends z.ZodTypeAny = z.ZodAny, RESUME_SCHEMA extends z.ZodTypeAny = z.ZodAny>(config: WorkflowConfig<INPUT_SCHEMA, RESULT_SCHEMA, SUSPEND_SCHEMA, RESUME_SCHEMA>): WorkflowChain<INPUT_SCHEMA, RESULT_SCHEMA, WorkflowInput<INPUT_SCHEMA>, SUSPEND_SCHEMA, RESUME_SCHEMA>;

/**
 * Union type for all workflow events
 */
type WorkflowEvent = WorkflowStartEvent | WorkflowSuccessEvent | WorkflowErrorEvent | WorkflowSuspendEvent | WorkflowStepStartEvent | WorkflowStepSuccessEvent | WorkflowStepErrorEvent | WorkflowStepSuspendEvent;
/**
 * Workflow event emitter for publishing workflow events to the timeline
 */
declare class WorkflowEventEmitter extends EventEmitter {
    private static instance;
    private workflowEventQueue;
    private logger;
    private constructor();
    /**
     * Get the singleton instance of WorkflowEventEmitter
     */
    static getInstance(): WorkflowEventEmitter;
    /**
     * Queue workflow event for background processing (non-blocking)
     */
    publishWorkflowEventAsync(params: {
        workflowId: string;
        executionId: string;
        event: WorkflowEvent;
    }): void;
    /**
     * Synchronous version of publishWorkflowEvent (internal use)
     */
    private publishWorkflowEventSync;
    /**
     * Emit immediate event for real-time updates (bypasses queue)
     */
    private emitImmediateEvent;
}

/**
 * Manages workflow execution history and persistence
 * Provides a high-level interface for workflow memory operations
 */
declare class WorkflowMemoryManager {
    private storage;
    private _exporter?;
    private logger;
    constructor(storage: Memory, _exporter?: VoltAgentExporter);
    /**
     * Set the VoltAgent exporter for telemetry
     */
    setExporter(exporter: VoltAgentExporter): void;
    /**
     * Create a new workflow execution entry
     */
    createExecution(workflowId: string, workflowName: string, input: unknown, options?: CreateWorkflowExecutionOptions): Promise<WorkflowHistoryEntry>;
    /**
     * Update an existing workflow execution
     */
    updateExecution(id: string, updates: Partial<WorkflowHistoryEntry>): Promise<WorkflowHistoryEntry | null>;
    /**
     * Get a workflow execution by ID
     */
    getExecution(id: string): Promise<WorkflowHistoryEntry | null>;
    /**
     * Get all executions for a workflow
     */
    getExecutions(workflowId: string): Promise<WorkflowHistoryEntry[]>;
    /**
     * Get workflow execution with all related data (steps and events)
     */
    getExecutionWithDetails(id: string): Promise<WorkflowHistoryEntry | null>;
    /**
     * Record the start of a workflow step
     */
    recordStepStart(workflowHistoryId: string, stepIndex: number, stepType: "agent" | "func" | "conditional-when" | "parallel-all" | "parallel-race", stepName: string, input?: unknown, options?: RecordWorkflowStepOptions): Promise<WorkflowStepHistoryEntry>;
    /**
     * Record the end of a workflow step
     */
    recordStepEnd(stepId: string, options?: UpdateWorkflowStepOptions): Promise<WorkflowStepHistoryEntry | null>;
    /**
     * Record a timeline event for a workflow
     */
    recordTimelineEvent(workflowHistoryId: string, event: Omit<WorkflowTimelineEvent$1, "workflowHistoryId" | "createdAt">): Promise<void>;
    /**
     * Get workflow statistics
     */
    getWorkflowStats(workflowId: string): Promise<WorkflowStats>;
    /**
     * Get all workflow IDs
     */
    getAllWorkflowIds(): Promise<string[]>;
    /**
     * Delete a workflow execution and all related data
     */
    deleteExecution(id: string): Promise<void>;
    /**
     * Clean up old workflow executions
     */
    cleanupOldExecutions(workflowId: string, maxEntries: number): Promise<number>;
    /**
     * Get workflow steps for a specific execution
     */
    getWorkflowSteps(workflowHistoryId: string): Promise<WorkflowStepHistoryEntry[]>;
    /**
     * Get timeline events for a specific execution
     */
    getTimelineEvents(workflowHistoryId: string): Promise<WorkflowTimelineEvent$1[]>;
    /**
     * Update a workflow step
     */
    updateStep(stepId: string, updates: Partial<WorkflowStepHistoryEntry>): Promise<WorkflowStepHistoryEntry | null>;
    /**
     * Get a single workflow step
     */
    getStep(stepId: string): Promise<WorkflowStepHistoryEntry | null>;
    /**
     * Get all suspended workflow executions for a workflow
     */
    getSuspendedExecutions(workflowId: string): Promise<WorkflowHistoryEntry[]>;
    /**
     * Store suspension checkpoint data
     */
    storeSuspensionCheckpoint(executionId: string, suspensionMetadata: any): Promise<void>;
    /**
     * Get a single timeline event
     */
    getTimelineEvent(eventId: string): Promise<WorkflowTimelineEvent$1 | null>;
}

/**
 * Manages workflow execution history and event tracking
 * Follows the same pattern as Agent HistoryManager for consistency
 */
declare class WorkflowHistoryManager {
    private readonly workflowId;
    private memoryManager?;
    private exporter?;
    private logger;
    constructor(workflowId: string, memoryManager?: WorkflowMemoryManager, exporter?: VoltAgentExporter, logger?: Logger);
    /**
     * Set memory manager for persistence
     */
    setMemoryManager(memoryManager: WorkflowMemoryManager): void;
    /**
     * Set exporter for telemetry
     */
    setExporter(exporter: VoltAgentExporter): void;
    /**
     * Check if memory manager is configured
     */
    isMemoryManagerConfigured(): boolean;
    /**
     * Record the start of a workflow step (similar to Agent system)
     * This creates persistent step records for historical analysis
     */
    recordStepStart(executionId: string, stepIndex: number, stepType: "agent" | "func" | "conditional-when" | "parallel-all" | "parallel-race", stepName: string, input?: unknown, options?: {
        stepId?: string;
        parallelIndex?: number;
        parentStepId?: string;
        metadata?: Record<string, unknown>;
    }): Promise<WorkflowStepHistoryEntry | null>;
    /**
     * Record the end of a workflow step
     */
    recordStepEnd(stepId: string, options?: {
        status?: "completed" | "error" | "skipped";
        output?: unknown;
        errorMessage?: string;
        agentExecutionId?: string;
        metadata?: Record<string, unknown>;
    }): Promise<WorkflowStepHistoryEntry | null>;
    /**
     * Persist a timeline event to workflow history (following Agent pattern)
     * This is the main responsibility of this class
     */
    persistTimelineEvent(executionId: string, event: WorkflowEvent): Promise<WorkflowHistoryEntry | null>;
    /**
     * Get workflow execution history entries
     */
    getExecutions(): Promise<WorkflowHistoryEntry[]>;
    /**
     * Get specific execution with details (including steps)
     */
    getExecutionWithDetails(executionId: string): Promise<WorkflowHistoryEntry | null>;
    /**
     * Get all steps for a specific execution
     */
    getWorkflowSteps(executionId: string): Promise<WorkflowStepHistoryEntry[]>;
    /**
     * Update a specific step
     */
    updateStep(stepId: string, updates: Partial<WorkflowStepHistoryEntry>): Promise<WorkflowStepHistoryEntry | null>;
}

/**
 * Workflow registration information
 */
interface RegisteredWorkflow {
    workflow: Workflow<any, any>;
    registeredAt: Date;
    executionCount: number;
    lastExecutedAt?: Date;
    inputSchema?: any;
    suspendSchema?: any;
    resumeSchema?: any;
    workflowMemory?: Memory;
    workflowMemoryManager?: WorkflowMemoryManager;
}
/**
 * Singleton registry for managing workflows and their execution history
 */
declare class WorkflowRegistry extends EventEmitter {
    private static instance;
    private workflows;
    private logger;
    private workflowHistoryManagers;
    activeExecutions: Map<string, WorkflowSuspendController>;
    private constructor();
    /**
     * Get the singleton instance of WorkflowRegistry
     */
    static getInstance(): WorkflowRegistry;
    getWorkflowHistoryManager(workflowId: string): WorkflowHistoryManager;
    persistWorkflowTimelineEvent(workflowId: string, executionId: string, event: WorkflowEvent): Promise<void>;
    /**
     * Get global VoltAgentExporter (helper method)
     */
    private getGlobalVoltAgentExporter;
    /**
     * Each workflow must manage its own memory
     */
    getWorkflowMemoryManager(workflowId: string): WorkflowMemoryManager | undefined;
    /**
     * Create a new workflow execution and emit historyCreated event
     */
    createWorkflowExecution(workflowId: string, workflowName: string, input: unknown, options?: {
        userId?: string;
        conversationId?: string;
        userContext?: Map<string | symbol, unknown>;
        metadata?: Record<string, unknown>;
        executionId?: string;
    }): Promise<WorkflowHistoryEntry | null>;
    /**
     * Update a workflow execution and emit historyUpdate event
     */
    updateWorkflowExecution(workflowId: string, executionId: string, updates: Partial<WorkflowHistoryEntry>): Promise<WorkflowHistoryEntry | null>;
    /**
     * Register a workflow with the registry
     */
    registerWorkflow(workflow: Workflow<any, any>): void;
    /**
     * Get a specific workflow by ID
     */
    getWorkflow(id: string): RegisteredWorkflow | undefined;
    /**
     * Get all registered workflows
     */
    getAllWorkflows(): RegisteredWorkflow[];
    /**
     * Unregister a workflow from the registry
     */
    unregisterWorkflow(id: string): void;
    /**
     * Get workflow execution history (async version for persistent storage)
     */
    getWorkflowExecutionsAsync(workflowId: string): Promise<WorkflowHistoryEntry[]>;
    /**
     * Get workflow statistics
     */
    getWorkflowStats(_workflowId: string): {
        totalExecutions: number;
        successfulExecutions: number;
        failedExecutions: number;
        averageExecutionTime: number;
        lastExecutionTime?: Date;
    };
    /**
     * Get all workflow IDs that have registrations
     */
    getAllWorkflowIds(): string[];
    /**
     * Get total number of registered workflows
     */
    getWorkflowCount(): number;
    /**
     * Resume a suspended workflow execution
     */
    resumeSuspendedWorkflow(workflowId: string, executionId: string, resumeData?: any, resumeStepId?: string): Promise<{
        executionId: string;
        startAt: Date;
        endAt: Date;
        status: "completed" | "suspended" | "error";
        result: any;
        usage: UsageInfo;
        suspension?: any;
        error?: unknown;
    } | null>;
    /**
     * Get all suspended workflow executions
     */
    getSuspendedWorkflows(): Promise<Array<{
        workflowId: string;
        executionId: string;
        suspendedAt: Date;
        reason?: string;
        suspendedStepIndex: number;
    }>>;
    /**
     * Get workflows as API response format
     */
    getWorkflowsForApi(): {
        id: string;
        name: string;
        purpose: string;
        stepsCount: number;
        status: "idle";
    }[];
    /**
     * Suspend all active workflows for graceful shutdown
     */
    suspendAllActiveWorkflows(reason?: string): Promise<void>;
    /**
     * Get detailed workflow with serialized steps for API response
     */
    getWorkflowDetailForApi(id: string): {
        id: string;
        name: string;
        purpose: string;
        stepsCount: number;
        status: "idle";
        steps: any[];
    } | null;
    /**
     * Handle immediate workflow events for real-time WebSocket broadcast
     */
    private handleImmediateWorkflowEvent;
}

/**
 * Creates a workflow suspension controller that can be used to externally suspend a running workflow.
 *
 * @example
 * ```typescript
 * import { createSuspendController } from "@voltagent/core";
 *
 * // Create controller
 * const controller = createSuspendController();
 *
 * // Run workflow with controller
 * const execution = await workflow.run(input, { suspendController: controller });
 *
 * // Suspend from outside
 * controller.suspend("Waiting for approval");
 *
 * // Check status
 * if (controller.isSuspended()) {
 *   console.log("Suspended because:", controller.getReason());
 * }
 * ```
 */
declare function createSuspendController(): WorkflowSuspendController;

/**
 * Enum defining the next action to take after a reasoning step.
 */
declare enum NextAction {
    CONTINUE = "continue",
    VALIDATE = "validate",
    FINAL_ANSWER = "final_answer"
}
/**
 * Zod schema for the ReasoningStep data structure.
 */
declare const ReasoningStepSchema: z.ZodObject<{
    id: z.ZodString;
    type: z.ZodEnum<["thought", "analysis"]>;
    title: z.ZodString;
    reasoning: z.ZodString;
    action: z.ZodOptional<z.ZodString>;
    result: z.ZodOptional<z.ZodString>;
    next_action: z.ZodOptional<z.ZodNativeEnum<typeof NextAction>>;
    confidence: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    timestamp: z.ZodString;
    historyEntryId: z.ZodString;
    agentId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "thought" | "analysis";
    id: string;
    title: string;
    agentId: string;
    reasoning: string;
    timestamp: string;
    historyEntryId: string;
    confidence: number;
    result?: string | undefined;
    action?: string | undefined;
    next_action?: NextAction | undefined;
}, {
    type: "thought" | "analysis";
    id: string;
    title: string;
    agentId: string;
    reasoning: string;
    timestamp: string;
    historyEntryId: string;
    result?: string | undefined;
    action?: string | undefined;
    next_action?: NextAction | undefined;
    confidence?: number | undefined;
}>;
/**
 * TypeScript type inferred from the ReasoningStepSchema.
 */
type ReasoningStep = z.infer<typeof ReasoningStepSchema>;
/**
 * Options specific to reasoning tool execution, extending base ToolExecuteOptions.
 */
interface ReasoningToolExecuteOptions extends ToolExecuteOptions {
    agentId: string;
    historyEntryId: string;
}

declare const DEFAULT_INSTRUCTIONS = "\nYou are equipped with 'think' and 'analyze' capabilities to methodically tackle problems and organize your reasoning process. ALWAYS utilize 'think' before initiating any tool calls or formulating a response.\n\n1.  **Think** (Internal Workspace):\n    *   Objective: Employ the 'think' tool as an internal workspace to dissect complex issues, chart out solution paths, and determine the next steps in your reasoning. Use this to organize your internal thought process.\n    *   Method: Invoke 'think' repeatedly if necessary for problem decomposition. Articulate your rationale and specify the planned next step (e.g., \"initiate tool call,\" \"compute value,\" \"request clarification\").\n\n2.  **Analyze** (Assessment):\n    *   Objective: Assess the outcome of a thinking phase or a sequence of tool interactions. Determine if the outcome aligns with expectations, is adequate, or necessitates further exploration.\n    *   Method: Call 'analyze' following a series of tool uses or a completed thought sequence. Define the 'next_action' based on your assessment: 'continue' (further reasoning is required), 'validate' (if possible, seek external verification), or 'final_answer' (prepared to deliver the conclusion).\n    *   Justify your assessment, indicating whether the result is accurate/sufficient.\n\n## Core Principles\n*   **Initiate with Thought:** It is MANDATORY to use the 'think' tool prior to other tool interactions or response generation, except for trivial requests. Use 'think' multiple times for intricate problems.\n*   **Iterative Problem Solving:** Employ 'think' and 'analyze' in cycles to construct a transparent reasoning trajectory. The standard sequence is Think -> [Think -> ...] -> [Tool Calls if needed] -> [Analyze if needed] -> ... -> final_answer. Repeat this loop until a satisfactory resolution is achieved.\n*   **Parallel Tool Execution:** Following a 'think' step, multiple tool calls can be executed concurrently if required.\n*   **Maintain Internal Reasoning:** The steps involving 'think' and 'analyze' constitute your internal cognitive process. Do not expose these steps directly to the user unless specifically asked to elaborate on your reasoning.\n*   **Deliver Concise Conclusions:** Once your analysis concludes with 'next_action: final_answer', present a clear and precise final answer to the user, synthesized from your reasoning steps.\n";
declare const FEW_SHOT_EXAMPLES = "\n## Illustrations\n\n**Illustration 1: Basic Knowledge Retrieval**\n\n*User Query:* What is the tallest mountain in the world?\n\n*Agent's Internal Processing:*\n```json\n{\n  \"tool_call\": {\n    \"name\": \"think\",\n    \"arguments\": {\n      \"title\": \"Parse Request\",\n      \"thought\": \"The user is asking for the name of the world's highest peak. This is well-known geographical data.\",\n      \"action\": \"Recall or look up the tallest mountain.\",\n      \"confidence\": 0.98\n    }\n  }\n}\n```\n*--(Agent internally accesses the information)--*\n```json\n{\n  \"tool_call\": {\n    \"name\": \"analyze\",\n    \"arguments\": {\n      \"title\": \"Assess Information\",\n      \"result\": \"Mount Everest is recognized as the tallest mountain above sea level.\",\n      \"analysis\": \"The retrieved data directly answers the user's query accurately.\",\n      \"next_action\": \"final_answer\",\n      \"confidence\": 1.0\n    }\n  }\n}\n```\n\n*Agent's Final Response to User:*\nThe tallest mountain in the world is Mount Everest.\n\n**Illustration 2: Sequential Information Gathering**\n\n*User Query:* Who directed the movie 'Inception' and what year was it released?\n\n*Agent's Internal Processing:*\n```json\n{\n  \"tool_call\": {\n    \"name\": \"think\",\n    \"arguments\": {\n      \"title\": \"Outline Information Needs\",\n      \"thought\": \"The request asks for two specific details about the movie 'Inception': its director and release year. I'll handle these sequentially. First, find the director.\",\n      \"action\": \"Search for the director of 'Inception'.\",\n      \"confidence\": 0.95\n    }\n  }\n}\n```\n*--(Tool interaction: search(query=\"director of Inception\"))--*\n*--(Tool Outcome: \"Christopher Nolan\")--*\n```json\n{\n  \"tool_call\": {\n    \"name\": \"analyze\",\n    \"arguments\": {\n      \"title\": \"Evaluate Director Search\",\n      \"result\": \"The search identified Christopher Nolan as the director.\",\n      \"analysis\": \"This fulfills the first part of the request. Next, I need the release year.\",\n      \"next_action\": \"continue\",\n      \"confidence\": 1.0\n    }\n  }\n}\n```\n```json\n{\n  \"tool_call\": {\n    \"name\": \"think\",\n    \"arguments\": {\n      \"title\": \"Plan Release Year Retrieval\",\n      \"thought\": \"The subsequent step is to determine the release year for 'Inception'.\",\n      \"action\": \"Search for the release year of 'Inception'.\",\n      \"confidence\": 0.95\n    }\n  }\n}\n```\n*--(Tool interaction: search(query=\"release year of Inception\"))--*\n*--(Tool Outcome: \"2010\")--*\n```json\n{\n  \"tool_call\": {\n    \"name\": \"analyze\",\n    \"arguments\": {\n      \"title\": \"Evaluate Release Year Search\",\n      \"result\": \"The search indicated the release year was 2010.\",\n      \"analysis\": \"I have now obtained both the director's name and the release year. I am ready to formulate the final response.\",\n      \"next_action\": \"final_answer\",\n      \"confidence\": 1.0\n    }\n  }\n}\n```\n\n*Agent's Final Response to User:*\nThe movie 'Inception' was directed by Christopher Nolan and released in 2010.\n";
type CreateReasoningToolsOptions = {
    addInstructions?: boolean;
    think?: boolean;
    analyze?: boolean;
    addFewShot?: boolean;
    fewShotExamples?: string;
};
/**
 * Factory function to create a Toolkit containing reasoning tools and instructions.
 */
declare const createReasoningTools: (options?: CreateReasoningToolsOptions) => Toolkit;

/**
 * Singleton class for managing agent events
 */
declare class AgentEventEmitter extends EventEmitter {
    private static instance;
    private timelineEventQueue;
    private constructor();
    /**
     * Get the singleton instance of AgentEventEmitter
     */
    static getInstance(): AgentEventEmitter;
    /**
     * Queue timeline event for background processing (non-blocking)
     * Uses the new BackgroundQueue utility for better reliability
     */
    publishTimelineEventAsync(params: {
        agentId: string;
        historyId: string;
        event: AgentTimelineEvent;
        skipPropagation?: boolean;
        parentHistoryEntryId?: string;
    }): void;
    /**
     * Emit immediate event for real-time updates (bypasses queue)
     */
    private emitImmediateEvent;
    /**
     * Synchronous version of publishTimelineEvent (internal use)
     * This is what gets called by the background queue
     */
    private publishTimelineEventSync;
    /**
     * Propagates a timeline event from a subagent to all its parent agents (optimized batch version)
     * This ensures all events from subagents appear in parent agent timelines
     *
     * @param agentId - The source agent ID (subagent)
     * @param historyId - The history entry ID of the source (not used directly but needed for context)
     * @param event - The agent event to propagate (no workflow events)
     * @param visited - Set of already visited agents (to prevent cycles)
     * @param parentHistoryEntryId - Optional specific parent operation context to avoid confusion between concurrent operations
     */
    private propagateEventToParentAgents;
    /**
     * Emit a history update event
     */
    emitHistoryUpdate(agentId: string, historyEntry: AgentHistoryEntry): void;
    /**
     * Emit hierarchical history entry created events to parent agents
     * This ensures that parent agents are aware of new subagent history entries
     */
    emitHierarchicalHistoryEntryCreated(agentId: string, historyEntry: AgentHistoryEntry, visited?: Set<string>): Promise<void>;
    /**
     * Emit hierarchical history update events to parent agents
     * This ensures that parent agents are aware of subagent history changes
     */
    emitHierarchicalHistoryUpdate(agentId: string, historyEntry: AgentHistoryEntry, visited?: Set<string>): Promise<void>;
    /**
     * Emit a history entry created event
     */
    emitHistoryEntryCreated(agentId: string, historyEntry: AgentHistoryEntry): void;
    /**
     * Emit an agent registered event
     */
    emitAgentRegistered(agentId: string): void;
    /**
     * Emit an agent unregistered event
     */
    emitAgentUnregistered(agentId: string): void;
    /**
     * Subscribe to history update events
     */
    onHistoryUpdate(callback: (agentId: string, historyEntry: AgentHistoryEntry) => void): () => void;
    /**
     * Subscribe to history entry created events
     */
    onHistoryEntryCreated(callback: (agentId: string, historyEntry: AgentHistoryEntry) => void): () => void;
    /**
     * Subscribe to agent registered events
     */
    onAgentRegistered(callback: (agentId: string) => void): () => void;
    /**
     * Subscribe to agent unregistered events
     */
    onAgentUnregistered(callback: (agentId: string) => void): () => void;
}

/**
 * HTTP methods supported by custom endpoints
 */
type HttpMethod = "get" | "post" | "put" | "patch" | "delete" | "options" | "head";
/**
 * Handler function for custom endpoints
 */
type CustomEndpointHandler = (c: Context) => Promise<Response> | Response;
/**
 * Definition for a custom endpoint
 */
interface CustomEndpointDefinition {
    /**
     * The path for the endpoint, relative to the API root
     * Example: "/custom-endpoint" or "/custom/:param"
     */
    path: string;
    /**
     * The HTTP method for the endpoint
     */
    method: HttpMethod;
    /**
     * The handler function for the endpoint
     */
    handler: CustomEndpointHandler;
    /**
     * Optional description for the endpoint
     */
    description?: string;
}
/**
 * Error thrown when a custom endpoint definition is invalid
 */
declare class CustomEndpointError extends Error {
    constructor(message: string);
}

/**
 * Prompt manager with caching and Liquid template processing
 */

/**
 * Implementation of VoltOpsPromptManager with caching and Liquid templates
 */
declare class VoltOpsPromptManagerImpl implements VoltOpsPromptManager {
    private readonly cache;
    private readonly apiClient;
    private readonly templateEngine;
    private readonly cacheConfig;
    private readonly logger;
    constructor(options: VoltOpsClientOptions);
    /**
     * Get prompt content by reference with caching and template processing
     */
    getPrompt(reference: PromptReference): Promise<PromptContent>;
    /**
     * Preload prompts for better performance
     */
    preload(references: PromptReference[]): Promise<void>;
    /**
     * Clear cache
     */
    clearCache(): void;
    /**
     * Get cache statistics
     */
    getCacheStats(): {
        size: number;
        entries: string[];
    };
    /**
     * Convert API response to PromptContent with metadata
     */
    private convertApiResponseToPromptContent;
    /**
     * Generate cache key for prompt reference
     */
    private getCacheKey;
    /**
     * Get cached prompt if valid
     */
    private getCachedPrompt;
    /**
     * Set cached prompt with TTL and size limit enforcement
     */
    private setCachedPrompt;
    /**
     * Evict oldest cache entry to make room for new one
     */
    private evictOldestEntry;
    /**
     * Process template variables using configured template engine
     */
    private processTemplate;
    /**
     * Process PromptContent with template processing
     */
    private processPromptContent;
    /**
     * Process MessageContent (can be string or array of parts)
     */
    private processMessageContent;
}

/**
 * API client for prompt operations
 */

/**
 * Implementation of PromptApiClient for VoltOps API communication
 */
declare class VoltOpsPromptApiClient implements PromptApiClient {
    private readonly baseUrl;
    private readonly publicKey;
    private readonly secretKey;
    private readonly fetchFn;
    private readonly logger;
    constructor(options: VoltOpsClientOptions);
    /**
     * Fetch prompt content from VoltOps API
     */
    fetchPrompt(reference: PromptReference): Promise<PromptApiResponse>;
    /**
     * Build URL for prompt API endpoint
     */
    private buildPromptUrl;
    /**
     * Build authentication headers
     */
    private buildHeaders;
}

/**
 * Simple template engine for basic variable substitution
 */
/**
 * Template engine interface
 */
type TemplateEngine = {
    /** Process template with variables */
    process: (content: string, variables: Record<string, any>) => string;
    /** Engine name for debugging */
    name: string;
};
/**
 * Simple mustache-style template engine (built-in, no dependencies)
 * Supports {{variable}} syntax for basic variable substitution
 */
declare const createSimpleTemplateEngine: () => TemplateEngine;

/**
 * Basic type definitions for VoltAgent Core
 */

/**
 * Server configuration options for VoltAgent
 */
type ServerOptions = {
    /**
     * Whether to automatically start the server
     * @default true
     */
    autoStart?: boolean;
    /**
     * Port number for the server
     * @default 3141 (or next available port)
     */
    port?: number;
    /**
     * Optional flag to enable/disable Swagger UI
     * By default:
     * - In development (NODE_ENV !== 'production'): Swagger UI is enabled
     * - In production (NODE_ENV === 'production'): Swagger UI is disabled
     */
    enableSwaggerUI?: boolean;
    /**
     * Optional array of custom endpoint definitions to register with the API server
     */
    customEndpoints?: CustomEndpointDefinition[];
};
/**
 * VoltAgent constructor options
 */
type VoltAgentOptions = {
    agents: Record<string, Agent<any>>;
    /**
     * Optional workflows to register with VoltAgent
     * Can be either Workflow instances or WorkflowChain instances
     */
    workflows?: Record<string, Workflow<DangerouslyAllowAny, DangerouslyAllowAny, DangerouslyAllowAny, DangerouslyAllowAny> | WorkflowChain<DangerouslyAllowAny, DangerouslyAllowAny, DangerouslyAllowAny, DangerouslyAllowAny, DangerouslyAllowAny>>;
    /**
     * Server configuration options
     */
    server?: ServerOptions;
    /**
     * Unified VoltOps client for telemetry and prompt management
     * Replaces the old telemetryExporter approach with a comprehensive solution.
     */
    voltOpsClient?: VoltOpsClient;
    /**
     * Global logger instance to use across all agents and workflows
     * If not provided, a default logger will be created
     */
    logger?: Logger;
    /**
     * @deprecated Use `voltOpsClient` instead. Will be removed in a future version.
     * Optional OpenTelemetry SpanExporter instance or array of instances.
     * or a VoltAgentExporter instance or array of instances.
     * If provided, VoltAgent will attempt to initialize and register
     * a NodeTracerProvider with a BatchSpanProcessor for the given exporter(s).
     * It's recommended to only provide this in one VoltAgent instance per application process.
     */
    telemetryExporter?: (SpanExporter | VoltAgentExporter) | (SpanExporter | VoltAgentExporter)[];
    /**
     * @deprecated Use `server.port` instead
     */
    port?: number;
    /**
     * @deprecated Use `server.autoStart` instead
     */
    autoStart?: boolean;
    checkDependencies?: boolean;
    /**
     * @deprecated Use `server.customEndpoints` instead
     */
    customEndpoints?: CustomEndpointDefinition[];
    /**
     * @deprecated Use `server.enableSwaggerUI` instead
     */
    enableSwaggerUI?: boolean;
};

/**
 * Prompt management utilities for agent prompt tuning
 */
type ExtractVariableNames<T extends string> = T extends `${string}{{${infer Param}}}${infer Rest}` ? Param | ExtractVariableNames<Rest> : never;
type AllowedVariableValue = string | number | boolean | undefined | null;
type TemplateVariables<T extends string> = {
    [K in ExtractVariableNames<T>]: AllowedVariableValue;
};
type PromptTemplate<T extends string> = [ExtractVariableNames<T>] extends [never] ? {
    template: T;
    variables?: Record<string, never>;
} : {
    template: T;
    variables: TemplateVariables<T>;
};
type PromptCreator<T extends string> = (extraVariables?: Partial<TemplateVariables<T>>) => string;
/**
 * Creates a type-safe, customizable prompt function from a template string.
 * Variable names are automatically inferred from the template `{{variable}}` syntax.
 *
 * @param template - The template string with `{{variable}}` placeholders.
 * @param variables - An object containing the default values for the template variables.
 * @returns A function that takes optional extra variables and returns the processed prompt string.
 */
declare const createPrompt: <T extends string>({ template, variables, }: PromptTemplate<T>) => PromptCreator<T>;

/**
 * Node types for agents, tools, and other components
 */
declare enum NodeType {
    AGENT = "agent",
    SUBAGENT = "agent",
    TOOL = "tool",
    MEMORY = "memory",
    MESSAGE = "message",
    OUTPUT = "output",
    RETRIEVER = "retriever",
    WORKFLOW_STEP = "workflow_step",
    WORKFLOW_AGENT_STEP = "workflow_agent_step",
    WORKFLOW_FUNC_STEP = "workflow_func_step",
    WORKFLOW_CONDITIONAL_STEP = "workflow_conditional_step",
    WORKFLOW_PARALLEL_ALL_STEP = "workflow_parallel_all_step",
    WORKFLOW_PARALLEL_RACE_STEP = "workflow_parallel_race_step"
}
/**
 * Standard node ID creation function
 * @param type Node type
 * @param name Main identifier (tool name, agent name, etc.)
 * @param ownerId Owner ID (optional)
 * @returns Standard formatted node ID
 */
declare const createNodeId: (type: NodeType, name: string, ownerId?: string) => string;
/**
 * Function to extract node type from NodeID
 * @param nodeId Node ID
 * @returns NodeType or null (if type cannot be found)
 */
declare const getNodeTypeFromNodeId: (nodeId: string) => NodeType | null;
/**
 * Workflow step types enum
 */
type WorkflowStepType = "agent" | "func" | "conditional-when" | "parallel-all" | "parallel-race";
/**
 * Create a workflow step node ID with consistent pattern
 * @param stepType Type of workflow step
 * @param stepIndex Index of step in workflow
 * @param workflowId Workflow identifier
 * @param options Additional options for node ID generation
 * @returns Consistent workflow step node ID
 */
declare const createWorkflowStepNodeId: (stepType: WorkflowStepType, stepIndex: number, workflowId: string, options?: {
    agentId?: string;
    parallelIndex?: number;
    stepName?: string;
    stepId?: string;
}) => string;
/**
 * Get NodeType for workflow step type
 * @param stepType Workflow step type
 * @returns Corresponding NodeType
 */
declare const getWorkflowStepNodeType: (stepType: WorkflowStepType) => NodeType;
/**
 * Extract workflow step information from node ID
 * @param nodeId Workflow step node ID
 * @returns Extracted workflow step info or null
 */
declare const extractWorkflowStepInfo: (nodeId: string) => {
    stepType: WorkflowStepType;
    stepIndex: number;
    workflowId: string;
    agentId?: string;
    parallelIndex?: number;
    stepName?: string;
} | null;

/**
 * Tool call interface
 */
interface ToolCall {
    id: string;
    type: "function";
    function: {
        name: string;
        arguments: string;
    };
}
/**
 * Converts a Zod-like schema to a JSON representation usable in the UI
 * @param schema Any Zod schema object
 * @returns A JSON Schema compatible representation of the Zod schema
 */
declare function zodSchemaToJsonUI(schema: any): any;

type UpdateOptions = {
    filter?: string;
    useCache?: boolean;
    forceRefresh?: boolean;
};
/**
 * Package update info with semver details
 */
type PackageUpdateInfo = {
    name: string;
    installed: string;
    latest: string;
    type: "major" | "minor" | "patch" | "latest";
    packageJson: string;
};
/**
 * Checks for dependency updates using native package manager commands
 * @returns Object containing update information
 */
declare const checkForUpdates: (packagePath?: string, options?: UpdateOptions) => Promise<{
    hasUpdates: boolean;
    updates: PackageUpdateInfo[];
    count: number;
    message: string;
}>;
/**
 * Update all packages that have available updates using native package manager
 * @param packagePath Optional path to package.json, uses current directory if not provided
 * @returns Result of the update operation
 */
declare const updateAllPackages: (packagePath?: string) => Promise<{
    success: boolean;
    message: string;
    updatedPackages?: string[];
    requiresRestart?: boolean;
}>;
/**
 * Update a single package to its latest version using native package manager
 * @param packageName Name of the package to update
 * @param packagePath Optional path to package.json, uses current directory if not provided
 * @returns Result of the update operation
 */
declare const updateSinglePackage: (packageName: string, packagePath?: string) => Promise<{
    success: boolean;
    message: string;
    packageName: string;
    requiresRestart?: boolean;
}>;

/**
 * Safely parse JSON string. If parsing fails, returns the original value.
 * @param value String to parse as JSON
 * @returns Parsed JSON object or original value if parsing fails
 */
declare function safeJsonParse(value: string | null | undefined): any;
declare function serializeValueForDebug(value: unknown): unknown;

/**
 * Type guard to check if content is a string
 */
declare function isTextContent(content: MessageContent): content is string;
/**
 * Type guard to check if content is structured (array of content parts)
 */
declare function isStructuredContent(content: MessageContent): content is Array<any>;
/**
 * Check if content has any text parts
 */
declare function hasTextPart(content: MessageContent): boolean;
/**
 * Check if content has any image parts
 */
declare function hasImagePart(content: MessageContent): boolean;
/**
 * Check if content has any file parts
 */
declare function hasFilePart(content: MessageContent): boolean;
/**
 * Extract text from message content
 */
declare function extractText(content: MessageContent): string;
/**
 * Extract all text parts from structured content
 */
declare function extractTextParts(content: MessageContent): Array<{
    type: "text";
    text: string;
}>;
/**
 * Extract image parts from message content
 */
declare function extractImageParts(content: MessageContent): Array<any>;
/**
 * Extract file parts from message content
 */
declare function extractFileParts(content: MessageContent): Array<any>;
/**
 * Transform text content in a message
 */
declare function transformTextContent(content: MessageContent, transformer: (text: string) => string): MessageContent;
/**
 * Map message content with a transformer function
 */
declare function mapMessageContent<T extends BaseMessage>(message: T, transformer: (text: string) => string): T;
/**
 * Filter content parts by type
 */
declare function filterContentParts(content: MessageContent, predicate: (part: any) => boolean): MessageContent;
/**
 * Normalize content to always be an array
 */
declare function normalizeToArray(content: MessageContent): Array<any>;
/**
 * Normalize content to the most compact form
 */
declare function normalizeContent(content: MessageContent): MessageContent;
/**
 * Builder class for creating message content
 */
declare class MessageContentBuilder {
    private parts;
    /**
     * Add a text part
     */
    addText(text: string): this;
    /**
     * Add an image part
     */
    addImage(image: string | Uint8Array): this;
    /**
     * Add a file part
     */
    addFile(file: string | Uint8Array, mimeType?: string): this;
    /**
     * Add a custom part
     */
    addPart(part: any): this;
    /**
     * Build the final content
     */
    build(): MessageContent;
    /**
     * Build as array (always returns array)
     */
    buildAsArray(): Array<any>;
    /**
     * Clear all parts
     */
    clear(): this;
    /**
     * Get current parts count
     */
    get length(): number;
}
/**
 * Convenience function to add timestamp to user messages
 */
declare function addTimestampToMessage(message: BaseMessage, timestamp?: string): BaseMessage;
/**
 * Convenience function to prepend text to message content
 */
declare function prependToMessage(message: BaseMessage, prefix: string): BaseMessage;
/**
 * Convenience function to append text to message content
 */
declare function appendToMessage(message: BaseMessage, suffix: string): BaseMessage;
/**
 * Check if message has any content
 */
declare function hasContent(message: BaseMessage): boolean;
/**
 * Get content length (text characters or array items)
 */
declare function getContentLength(content: MessageContent): number;
/**
 * Combined message helpers object for easy importing
 */
declare const messageHelpers: {
    isTextContent: typeof isTextContent;
    isStructuredContent: typeof isStructuredContent;
    hasTextPart: typeof hasTextPart;
    hasImagePart: typeof hasImagePart;
    hasFilePart: typeof hasFilePart;
    extractText: typeof extractText;
    extractTextParts: typeof extractTextParts;
    extractImageParts: typeof extractImageParts;
    extractFileParts: typeof extractFileParts;
    transformTextContent: typeof transformTextContent;
    mapMessageContent: typeof mapMessageContent;
    filterContentParts: typeof filterContentParts;
    normalizeToArray: typeof normalizeToArray;
    normalizeContent: typeof normalizeContent;
    addTimestampToMessage: typeof addTimestampToMessage;
    prependToMessage: typeof prependToMessage;
    appendToMessage: typeof appendToMessage;
    hasContent: typeof hasContent;
    getContentLength: typeof getContentLength;
    MessageContentBuilder: typeof MessageContentBuilder;
};

/**
 * Creates an AgentTool from a retriever, allowing it to be used as a tool in an agent.
 * This is the preferred way to use a retriever as a tool, as it properly maintains the 'this' context.
 *
 * @param retriever - The retriever instance to convert to a tool
 * @param options - Options for customizing the tool
 * @returns An AgentTool that can be added to an agent's tools
 *
 * @example
 * ```typescript
 * const retriever = new SimpleRetriever();
 * const searchTool = createRetrieverTool(retriever, {
 *   name: "search_knowledge",
 *   description: "Searches the knowledge base for information"
 * });
 *
 * agent.addTool(searchTool);
 * ```
 */
declare const createRetrieverTool: (retriever: Retriever, options?: {
    name?: string;
    description?: string;
}) => AgentTool;

/**
 * Client information for MCP
 */
interface ClientInfo {
    /**
     * Client name
     */
    name: string;
    /**
     * Client version
     */
    version: string;
    /**
     * Allow additional properties for SDK compatibility
     */
    [key: string]: unknown;
}
/**
 * Transport error from MCP
 */
interface TransportError extends Error {
    /**
     * Error code
     */
    code?: string;
    /**
     * Error details
     */
    details?: unknown;
}
/**
 * Model Context Protocol (MCP) configuration options
 */
type MCPOptions = {
    /**
     * Whether MCP is enabled
     */
    enabled: boolean;
    /**
     * MCP API endpoint
     */
    endpoint?: string;
    /**
     * API key for MCP authentication
     */
    apiKey?: string;
    /**
     * Control parameters for MCP
     */
    controlParams?: Record<string, unknown>;
    /**
     * Whether to fall back to the provider if MCP fails
     */
    fallbackToProvider?: boolean;
    /**
     * Timeout in milliseconds for MCP requests
     * @default 30000
     */
    timeout?: number;
};
/**
 * Configuration for MCP client
 */
type MCPClientConfig = {
    /**
     * Client information
     */
    clientInfo: ClientInfo;
    /**
     * MCP server configuration
     */
    server: MCPServerConfig;
    /**
     * MCP capabilities
     */
    capabilities?: ClientCapabilities;
    /**
     * Timeout in milliseconds for MCP requests
     * @default 30000
     */
    timeout?: number;
};
/**
 * MCP server configuration options
 */
type MCPServerConfig = HTTPServerConfig | SSEServerConfig | StreamableHTTPServerConfig | StdioServerConfig;
/**
 * HTTP-based MCP server configuration with automatic fallback
 * Tries streamable HTTP first, falls back to SSE if not supported
 */
type HTTPServerConfig = {
    /**
     * Type of server connection
     */
    type: "http";
    /**
     * URL of the MCP server
     */
    url: string;
    /**
     * Request initialization options
     */
    requestInit?: RequestInit;
    /**
     * Event source initialization options (used for SSE fallback)
     */
    eventSourceInit?: EventSourceInit;
    /**
     * Optional maximum request timeout in milliseconds.
     * If provided, passed to MCPClient as the per-request timeout.
     */
    timeout?: number;
};
/**
 * SSE-based MCP server configuration (explicit SSE transport)
 */
type SSEServerConfig = {
    /**
     * Type of server connection
     */
    type: "sse";
    /**
     * URL of the MCP server
     */
    url: string;
    /**
     * Request initialization options
     */
    requestInit?: RequestInit;
    /**
     * Event source initialization options
     */
    eventSourceInit?: EventSourceInit;
    /**
     * Optional maximum request timeout in milliseconds.
     * If provided, passed to MCPClient as the per-request timeout.
     */
    timeout?: number;
};
/**
 * Streamable HTTP-based MCP server configuration (no fallback)
 */
type StreamableHTTPServerConfig = {
    /**
     * Type of server connection
     */
    type: "streamable-http";
    /**
     * URL of the MCP server
     */
    url: string;
    /**
     * Request initialization options
     */
    requestInit?: RequestInit;
    /**
     * Session ID for the connection
     */
    sessionId?: string;
    /**
     * Optional maximum request timeout in milliseconds.
     * If provided, passed to MCPClient as the per-request timeout.
     */
    timeout?: number;
};
/**
 * Stdio-based MCP server configuration
 */
type StdioServerConfig = {
    /**
     * Type of server connection
     */
    type: "stdio";
    /**
     * Command to run the MCP server
     */
    command: string;
    /**
     * Arguments to pass to the command
     */
    args?: string[];
    /**
     * Environment variables for the MCP server process
     */
    env?: Record<string, string>;
    /**
     * Working directory for the MCP server process
     */
    cwd?: string;
    /**
     * Optional maximum request timeout in milliseconds.
     * If provided, passed to MCPClient as the per-request timeout.
     */
    timeout?: number;
};
/**
 * Tool call request
 */
type MCPToolCall = {
    /**
     * Name of the tool to call
     */
    name: string;
    /**
     * Arguments to pass to the tool
     */
    arguments: Record<string, unknown>;
};
/**
 * Tool call result
 */
type MCPToolResult = {
    /**
     * Result content from the tool
     */
    content: unknown;
};
/**
 * MCP client events
 */
interface MCPClientEvents {
    /**
     * Emitted when the client connects to the server
     */
    connect: () => void;
    /**
     * Emitted when the client disconnects from the server
     */
    disconnect: () => void;
    /**
     * Emitted when an error occurs
     */
    error: (error: Error | TransportError) => void;
    /**
     * Emitted when a tool call completes
     */
    toolCall: (name: string, args: Record<string, unknown>, result: unknown) => void;
}
/**
 * Map of toolset names to tools
 */
type ToolsetMap = Record<string, ToolsetWithTools>;
/**
 * A record of tools along with a helper method to convert them to an array.
 */
type ToolsetWithTools = Record<string, AnyToolConfig> & {
    /**
     * Converts the toolset to an array of BaseTool objects.
     */
    getTools: () => Tool<any>[];
};
/**
 * Any tool configuration
 */
type AnyToolConfig = Tool<any>;

/**
 * Client for interacting with Model Context Protocol (MCP) servers.
 * Wraps the official MCP SDK client to provide a higher-level interface.
 * Internal implementation differs from original source.
 */
declare class MCPClient extends EventEmitter {
    /**
     * Underlying MCP client instance from the SDK.
     */
    private client;
    /**
     * Communication channel (transport layer) for MCP interactions.
     */
    private transport;
    /**
     * Tracks the connection status to the server.
     */
    private connected;
    /**
     * Maximum time allowed for requests in milliseconds.
     */
    private readonly timeout;
    /**
     * Logger instance
     */
    private logger;
    /**
     * Information identifying this client to the server.
     */
    private readonly clientInfo;
    /**
     * Server configuration for fallback attempts.
     */
    private readonly serverConfig;
    /**
     * Whether to attempt SSE fallback if streamable HTTP fails.
     */
    private shouldAttemptFallback;
    /**
     * Client capabilities for re-initialization.
     */
    private readonly capabilities;
    /**
     * Get server info for logging
     */
    private getServerInfo;
    /**
     * Creates a new MCP client instance.
     * @param config Configuration for the client, including server details and client identity.
     */
    constructor(config: MCPClientConfig);
    /**
     * Sets up handlers for events from the underlying SDK client.
     */
    private setupEventHandlers;
    /**
     * Establishes a connection to the configured MCP server.
     * Idempotent: does nothing if already connected.
     */
    connect(): Promise<void>;
    /**
     * Attempts to connect using SSE transport as a fallback.
     * @param originalError The error from the initial connection attempt.
     */
    private attemptSSEFallback;
    /**
     * Closes the connection to the MCP server.
     * Idempotent: does nothing if not connected.
     */
    disconnect(): Promise<void>;
    /**
     * Fetches the definitions of available tools from the server.
     * @returns A record mapping tool names to their definitions (schema, description).
     */
    listTools(): Promise<Record<string, unknown>>;
    /**
     * Builds executable Tool objects from the server's tool definitions.
     * These tools include an `execute` method for calling the remote tool.
     * @returns A record mapping namespaced tool names (`clientName_toolName`) to executable Tool objects.
     */
    getAgentTools(): Promise<Record<string, Tool<any>>>;
    /**
     * Executes a specified tool on the remote MCP server.
     * @param toolCall Details of the tool to call, including name and arguments.
     * @returns The result content returned by the tool.
     */
    callTool(toolCall: MCPToolCall): Promise<MCPToolResult>;
    /**
     * Retrieves a list of resource identifiers available on the server.
     * @returns A promise resolving to an array of resource ID strings.
     */
    listResources(): Promise<string[]>;
    /**
     * Ensures the client is connected before proceeding with an operation.
     * Attempts to connect if not currently connected.
     * @throws Error if connection attempt fails.
     */
    private ensureConnected;
    /**
     * Emits an 'error' event, ensuring the payload is always an Error object.
     * @param error The error encountered, can be of any type.
     */
    private emitError;
    /**
     * Type guard to check if a server configuration is for an HTTP server.
     * @param server The server configuration object.
     * @returns True if the configuration type is 'http', false otherwise.
     */
    private isHTTPServer;
    /**
     * Type guard to check if a server configuration is for an SSE server.
     * @param server The server configuration object.
     * @returns True if the configuration type is 'sse', false otherwise.
     */
    private isSSEServer;
    /**
     * Type guard to check if a server configuration is for a Streamable HTTP server.
     * @param server The server configuration object.
     * @returns True if the configuration type is 'streamable-http', false otherwise.
     */
    private isStreamableHTTPServer;
    /**
     * Type guard to check if a server configuration is for a Stdio server.
     * @param server The server configuration object.
     * @returns True if the configuration type is 'stdio', false otherwise.
     */
    private isStdioServer;
    /**
     * Overrides EventEmitter's 'on' method for type-safe event listening.
     * Uses the original `MCPClientEvents` for event types.
     */
    on<E extends keyof MCPClientEvents>(event: E, listener: MCPClientEvents[E]): this;
    /**
     * Overrides EventEmitter's 'emit' method for type-safe event emission.
     * Uses the original `MCPClientEvents` for event types.
     */
    emit<E extends keyof MCPClientEvents>(event: E, ...args: Parameters<MCPClientEvents[E]>): boolean;
}

/**
 * Configuration manager for Model Context Protocol (MCP).
 * Handles multiple MCP server connections and tool management.
 * NOTE: This version does NOT manage singleton instances automatically.
 */
declare class MCPConfiguration<TServerKeys extends string = string> {
    /**
     * Map of server configurations keyed by server names.
     */
    private readonly serverConfigs;
    /**
     * Map of connected MCP clients keyed by server names (local cache).
     */
    private readonly mcpClientsById;
    /**
     * Creates a new, independent MCP configuration instance.
     * @param options Configuration options including server definitions.
     */
    constructor(options: {
        servers: Record<TServerKeys, MCPServerConfig>;
    });
    /**
     * Type guard to check if an object conforms to the basic structure of AnyToolConfig.
     */
    private isAnyToolConfigStructure;
    /**
     * Disconnects all associated MCP clients for THIS instance.
     */
    disconnect(): Promise<void>;
    /**
     * Retrieves agent-ready tools from all configured MCP servers for this instance.
     * @returns A flat array of all agent-ready tools.
     */
    getTools(): Promise<Tool<any>[]>;
    /**
     * Retrieves raw tool definitions from all configured MCP servers for this instance.
     * @returns A flat record of all raw tools keyed by their namespaced name.
     */
    getRawTools(): Promise<Record<string, AnyToolConfig>>;
    /**
     * Retrieves agent-ready toolsets grouped by server name for this instance.
     * @returns A record where keys are server names and values are agent-ready toolsets.
     */
    getToolsets(): Promise<Record<TServerKeys, ToolsetWithTools>>;
    /**
     * Retrieves raw tool definitions grouped by server name for this instance.
     * @returns A record where keys are server names and values are records of raw tools.
     */
    getRawToolsets(): Promise<Record<TServerKeys, Record<string, AnyToolConfig>>>;
    /**
     * Retrieves a specific connected MCP client by its server name for this instance.
     */
    getClient(serverName: TServerKeys): Promise<MCPClient | undefined>;
    /**
     * Retrieves all configured MCP clients for this instance, ensuring they are connected.
     */
    getClients(): Promise<Record<TServerKeys, MCPClient>>;
    /**
     * Internal helper to get/create/connect a client for this instance.
     * Manages the local mcpClientsById cache.
     */
    private getConnectedClient;
}

/**
 * Registry to manage and track agents
 */
declare class AgentRegistry {
    private static instance;
    private agents;
    private isInitialized;
    private globalVoltAgentExporter?;
    private globalVoltOpsClient?;
    private globalLogger?;
    /**
     * Track parent-child relationships between agents (child -> parents)
     */
    private agentRelationships;
    private constructor();
    /**
     * Get the singleton instance of AgentRegistry
     */
    static getInstance(): AgentRegistry;
    /**
     * Initialize the registry
     */
    initialize(): void;
    /**
     * Register a new agent
     */
    registerAgent(agent: Agent<any>): void;
    /**
     * Get an agent by ID
     */
    getAgent(id: string): Agent<any> | undefined;
    /**
     * Get all registered agents
     */
    getAllAgents(): Agent<any>[];
    /**
     * Register a parent-child relationship between agents
     * @param parentId ID of the parent agent
     * @param childId ID of the child agent (sub-agent)
     */
    registerSubAgent(parentId: string, childId: string): void;
    /**
     * Remove a parent-child relationship
     * @param parentId ID of the parent agent
     * @param childId ID of the child agent
     */
    unregisterSubAgent(parentId: string, childId: string): void;
    /**
     * Get all parent agent IDs for a given child agent
     * @param childId ID of the child agent
     * @returns Array of parent agent IDs
     */
    getParentAgentIds(childId: string): string[];
    /**
     * Clear all parent-child relationships for an agent when it's removed
     * @param agentId ID of the agent being removed
     */
    clearAgentRelationships(agentId: string): void;
    /**
     * Remove an agent by ID
     */
    removeAgent(id: string): boolean;
    /**
     * Get agent count
     */
    getAgentCount(): number;
    /**
     * Check if registry is initialized
     */
    isRegistryInitialized(): boolean;
    /**
     * Set the global VoltAgentExporter instance.
     * This is typically called by the main VoltAgent instance.
     */
    setGlobalVoltAgentExporter(exporter: VoltAgentExporter): void;
    /**
     * Get the global VoltAgentExporter instance.
     */
    getGlobalVoltAgentExporter(): VoltAgentExporter | undefined;
    /**
     * Set the global VoltOpsClient instance.
     * This replaces the old telemetryExporter approach with a unified solution.
     */
    setGlobalVoltOpsClient(client: VoltOpsClient$1 | undefined): void;
    /**
     * Get the global VoltOpsClient instance.
     */
    getGlobalVoltOpsClient(): VoltOpsClient$1 | undefined;
    /**
     * Set the global Logger instance.
     */
    setGlobalLogger(logger: Logger): void;
    /**
     * Get the global Logger instance.
     */
    getGlobalLogger(): Logger | undefined;
}

/**
 * Register a single custom endpoint with the API server
 * @param endpoint The custom endpoint definition
 * @throws CustomEndpointError if the endpoint definition is invalid or registration fails
 */
declare function registerCustomEndpoint(endpoint: CustomEndpointDefinition): void;
/**
 * Register multiple custom endpoints with the API server
 * @param endpoints Array of custom endpoint definitions
 * @throws CustomEndpointError if any endpoint definition is invalid or registration fails
 */
declare function registerCustomEndpoints(endpoints: CustomEndpointDefinition[]): void;

/**
 * Main VoltAgent class for managing agents and server
 */
declare class VoltAgent {
    private registry;
    private workflowRegistry;
    private serverStarted;
    private customEndpoints;
    private serverConfig;
    private serverOptions;
    private logger;
    constructor(options: VoltAgentOptions);
    /**
     * Setup graceful shutdown handlers
     */
    private setupShutdownHandlers;
    private isSoleSignalHandler;
    /**
     * Check for dependency updates
     */
    private checkDependencies;
    /**
     * Register an agent
     */
    registerAgent(agent: Agent<any>): void;
    /**
     * Helper method to extract Agent instance from SubAgentConfig
     */
    private extractAgentFromConfig;
    /**
     * Register multiple agents
     */
    registerAgents(agents: Record<string, Agent<any>>): void;
    /**
     * Start the server
     */
    startServer(): Promise<void>;
    /**
     * Register a custom endpoint with the API server
     * @param endpoint The custom endpoint definition
     * @throws Error if the endpoint definition is invalid or registration fails
     */
    registerCustomEndpoint(endpoint: CustomEndpointDefinition): void;
    /**
     * Register multiple custom endpoints with the API server
     * @param endpoints Array of custom endpoint definitions
     * @throws Error if any endpoint definition is invalid or registration fails
     */
    registerCustomEndpoints(endpoints: CustomEndpointDefinition[]): void;
    /**
     * Get all registered agents
     */
    getAgents(): Agent<any>[];
    /**
     * Get agent by ID
     */
    getAgent(id: string): Agent<any> | undefined;
    /**
     * Get agent count
     */
    getAgentCount(): number;
    /**
     * Register workflows
     */
    registerWorkflows(workflows: Record<string, Workflow<DangerouslyAllowAny, DangerouslyAllowAny, DangerouslyAllowAny, DangerouslyAllowAny> | WorkflowChain<DangerouslyAllowAny, DangerouslyAllowAny, DangerouslyAllowAny, DangerouslyAllowAny, DangerouslyAllowAny>>): void;
    /**
     * Register a single workflow
     */
    registerWorkflow(workflow: Workflow<DangerouslyAllowAny, DangerouslyAllowAny, DangerouslyAllowAny, DangerouslyAllowAny>): void;
    /**
     * Get all registered workflows
     */
    getWorkflows(): Workflow<DangerouslyAllowAny, DangerouslyAllowAny>[];
    /**
     * Get workflow by ID
     */
    getWorkflow(id: string): Workflow<DangerouslyAllowAny, DangerouslyAllowAny> | undefined;
    /**
     * Get workflow count
     */
    getWorkflowCount(): number;
    private initializeGlobalTelemetry;
    shutdownTelemetry(): Promise<void>;
}

export { type AbortError, Agent, type AgentErrorEvent, AgentEventEmitter, type AgentHistoryEntry, type AgentHookOnEnd, type AgentHookOnHandoff, type AgentHookOnPrepareMessages, type AgentHookOnStart, type AgentHookOnToolEnd, type AgentHookOnToolStart, type AgentHooks, type AgentOptions, AgentRegistry, type AgentResponse, type AgentStartEvent, type AgentStartEventMetadata, type AgentSuccessEvent, type AgentSuccessEventMetadata, type AgentTimelineEvent, type AgentTool, type AllowedVariableValue, type AnyToolConfig, type BaseEventMetadata, type BaseLLMOptions, type BaseMessage, BaseRetriever, type BaseTimelineEvent, type BaseTool, type BaseToolCall, type CachedPrompt, type ChatMessage, type ClientInfo, type Conversation, type ConversationQueryOptions, type CreateConversationInput, type CreateReasoningToolsOptions, type CustomEndpointDefinition, CustomEndpointError, type CustomEndpointHandler, DEFAULT_INSTRUCTIONS, type DataContent, type DynamicValue, type DynamicValueOptions, type ErrorStreamPart, type EventStatus, type ExtractVariableNames, FEW_SHOT_EXAMPLES, type FilePart, type FinishStreamPart, type GenerateObjectOptions, type GenerateTextOptions, type HTTPServerConfig, type HistoryStatus, type HttpMethod, type VoltOpsClient$1 as IVoltOpsClient, type ImagePart, InMemoryStorage, type InferGenerateObjectResponse, type InferGenerateTextResponse, type InferMessage, type InferModel, type InferProviderParams, type InferStreamResponse, type InferTool, type LLMProvider, LibSQLStorage, MCPClient, type MCPClientConfig, type MCPClientEvents, MCPConfiguration, type MCPOptions, type MCPServerConfig, type MCPToolCall, type MCPToolResult, type Memory, type MemoryEventMetadata, MemoryManager, type MemoryMessage, type MemoryOptions, type MemoryReadErrorEvent, type MemoryReadStartEvent, type MemoryReadSuccessEvent, type MemoryWriteErrorEvent, type MemoryWriteStartEvent, type MemoryWriteSuccessEvent, type MessageContent, MessageContentBuilder, type MessageFilterOptions, type MessageRole, type ModelToolCall, type NewTimelineEvent, NextAction, NodeType, type ObjectSubAgentConfig, type OnEndHookArgs, type OnHandoffHookArgs, type OnPrepareMessagesHookArgs, type OnPrepareMessagesHookResult, type OnStartHookArgs, type OnToolEndHookArgs, type OnToolStartHookArgs, type OperationContext, type PackageUpdateInfo, type PromptApiClient, type PromptApiResponse, type PromptContent, type PromptCreator, type PromptHelper, type PromptReference, type PromptTemplate, type ProviderObjectResponse, type ProviderObjectStreamResponse, type ProviderParams, type ProviderResponse, type ProviderTextResponse, type ProviderTextStreamResponse, type ReadableStreamType, type ReasoningStep, ReasoningStepSchema, type ReasoningStreamPart, type ReasoningToolExecuteOptions, type RetrieveOptions, type Retriever, type RetrieverErrorEvent, type RetrieverOptions, type RetrieverStartEvent, type RetrieverSuccessEvent, type SSEServerConfig, type ServerOptions, type SourceStreamPart, type StandardEventData, type StandardTimelineEvent, type StdioServerConfig, type StepChunkCallback, type StepFinishCallback, type StepWithContent, type StreamEventForwarderOptions, type StreamObjectFinishResult, type StreamObjectOnFinishCallback, type StreamObjectOptions, type StreamPart, type StreamTextFinishResult, type StreamTextOnFinishCallback, type StreamTextOptions, type StreamableHTTPServerConfig, type SubAgentConfig, type SubAgentConfigObject, type SubAgentMethod, type SupervisorConfig, type TemplateVariables, type TextDeltaStreamPart, type TextPart, type TextSubAgentConfig, type TimelineEventCoreLevel, type TimelineEventCoreStatus, type TimelineEventCoreType, Tool, type ToolCall, type ToolCallStreamPart, type ToolErrorEvent, type ToolErrorInfo, type ToolExecuteOptions, type ToolExecutionContext, ToolManager, type ToolOptions, type ToolResultStreamPart, type ToolSchema, type ToolStartEvent, type ToolStatus, type ToolStatusInfo, type ToolSuccessEvent, type Toolkit, type ToolsetMap, type ToolsetWithTools, type TransportError, type Usage, type UsageInfo, type Voice, type VoiceEventData, type VoiceEventType, type VoiceMetadata, type VoiceOptions, VoltAgent, type VoltAgentError, VoltAgentExporter, type VoltAgentExporterOptions, type VoltAgentOptions, VoltOpsClient, type VoltOpsClientOptions, VoltOpsPromptApiClient, type VoltOpsPromptManager, VoltOpsPromptManagerImpl, type Workflow, type WorkflowConfig, type WorkflowErrorEvent, type WorkflowEvent, WorkflowEventEmitter, type WorkflowEventMetadata, type WorkflowExecutionContext, type WorkflowHistoryEntry, WorkflowRegistry, type WorkflowStartEvent, type WorkflowStepContext, type WorkflowStepErrorEvent, type WorkflowStepEventMetadata, type WorkflowStepHistoryEntry, type WorkflowStepStartEvent, type WorkflowStepSuccessEvent, type WorkflowStepSuspendEvent, type WorkflowStepType, type WorkflowSuccessEvent, type WorkflowSuspendEvent, type WorkflowTimelineEvent, addTimestampToMessage, andAgent, andAll, andRace, andTap, andThen, andWhen, andWorkflow, appendToMessage, buildRetrieverLogMessage, checkForUpdates, createHooks, createNodeId, createPrompt, createReasoningTools, createRetrieverTool, createSimpleTemplateEngine, createStreamEventForwarder, createSubagent, createSuspendController, createTool, createToolkit, createVoltOpsClient, createWorkflow, createWorkflowChain, createWorkflowStepNodeId, VoltAgent as default, extractFileParts, extractImageParts, extractText, extractTextParts, extractWorkflowStepInfo, filterContentParts, getContentLength, getNodeTypeFromNodeId, getWorkflowStepNodeType, hasContent, hasFilePart, hasImagePart, hasTextPart, isAbortError, isStructuredContent, isTextContent, isVoltAgentError, mapMessageContent, messageHelpers, normalizeContent, normalizeToArray, prependToMessage, registerCustomEndpoint, registerCustomEndpoints, safeJsonParse, serializeValueForDebug, streamEventForwarder, tool, transformTextContent, updateAllPackages, updateSinglePackage, zodSchemaToJsonUI };
