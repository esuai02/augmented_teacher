"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  convertArrayToAsyncIterable: () => convertArrayToAsyncIterable,
  convertArrayToReadableStream: () => convertArrayToReadableStream,
  convertAsyncIterableToArray: () => convertAsyncIterableToArray,
  convertReadableStreamToArray: () => convertReadableStreamToArray,
  convertResponseStreamToArray: () => convertResponseStreamToArray,
  createAsyncIterableStream: () => createAsyncIterableStream,
  deepClone: () => deepClone,
  hasKey: () => hasKey,
  isEmptyObject: () => isEmptyObject,
  isFunction: () => isFunction,
  isNil: () => isNil,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  safeStringify: () => safeStringify
});
module.exports = __toCommonJS(index_exports);

// src/test/conversions.ts
async function convertReadableStreamToArray(stream) {
  const reader = stream.getReader();
  const result = [];
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    result.push(value);
  }
  return result;
}
__name(convertReadableStreamToArray, "convertReadableStreamToArray");
function convertArrayToAsyncIterable(values) {
  return {
    async *[Symbol.asyncIterator]() {
      for (const value of values) {
        yield value;
      }
    }
  };
}
__name(convertArrayToAsyncIterable, "convertArrayToAsyncIterable");
async function convertAsyncIterableToArray(iterable) {
  const result = [];
  for await (const item of iterable) {
    result.push(item);
  }
  return result;
}
__name(convertAsyncIterableToArray, "convertAsyncIterableToArray");
function convertArrayToReadableStream(values) {
  return new ReadableStream({
    start(controller) {
      try {
        for (const value of values) {
          controller.enqueue(value);
        }
      } finally {
        controller.close();
      }
    }
  });
}
__name(convertArrayToReadableStream, "convertArrayToReadableStream");
async function convertResponseStreamToArray(response) {
  return convertReadableStreamToArray(response.body.pipeThrough(new TextDecoderStream()));
}
__name(convertResponseStreamToArray, "convertResponseStreamToArray");

// src/utils/lang.ts
function isNil(obj) {
  return obj === null || obj === void 0;
}
__name(isNil, "isNil");
function isObject(obj) {
  return (typeof obj === "object" || typeof obj === "function") && !isNil(obj);
}
__name(isObject, "isObject");
function isFunction(obj) {
  return typeof obj === "function";
}
__name(isFunction, "isFunction");
function isPlainObject(obj) {
  if (!isObject(obj)) {
    return false;
  }
  const prototype = Object.getPrototypeOf(obj);
  return prototype === Object.prototype || prototype === null;
}
__name(isPlainObject, "isPlainObject");
function isEmptyObject(obj) {
  if (!isObject(obj)) {
    return false;
  }
  if (Object.getOwnPropertyNames(obj).length > 0 || Object.getOwnPropertySymbols(obj).length > 0) {
    return false;
  }
  return true;
}
__name(isEmptyObject, "isEmptyObject");

// src/utils/objects.ts
function deepClone(obj) {
  try {
    if (typeof structuredClone === "function") {
      return structuredClone(obj);
    }
    throw new Error("structuredClone is not available");
  } catch (_error) {
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    return { ...obj };
  }
}
__name(deepClone, "deepClone");
function hasKey(obj, key) {
  return isObject(obj) && key in obj;
}
__name(hasKey, "hasKey");

// src/utils/async-iterable-stream.ts
function createAsyncIterableStream(source) {
  const stream = source.pipeThrough(new TransformStream());
  stream[Symbol.asyncIterator] = () => {
    const reader = stream.getReader();
    return {
      async next() {
        const { done, value } = await reader.read();
        return done ? { done: true, value: void 0 } : { done: false, value };
      }
    };
  };
  return stream;
}
__name(createAsyncIterableStream, "createAsyncIterableStream");

// src/utils/safe-stringify.ts
function safeStringify(input, { indentation } = {}) {
  try {
    const seen = /* @__PURE__ */ new WeakSet();
    return JSON.stringify(input, safeStringifyReplacer(seen), indentation);
  } catch (error) {
    return `SAFE_STRINGIFY_ERROR: Error stringifying object: ${error instanceof Error ? error.message : "Unknown error"}`;
  }
}
__name(safeStringify, "safeStringify");
function safeStringifyReplacer(seen) {
  const replacer = /* @__PURE__ */ __name((_key, value) => {
    if (typeof value?.toJSON === "function") {
      value = value.toJSON();
    }
    if (!(value !== null && typeof value === "object")) {
      return value;
    }
    if (seen.has(value)) {
      return "[Circular]";
    }
    seen.add(value);
    const newValue = Array.isArray(value) ? [] : {};
    for (const [key2, value2] of Object.entries(value)) {
      newValue[key2] = replacer(key2, value2);
    }
    seen.delete(value);
    return newValue;
  }, "replacer");
  return replacer;
}
__name(safeStringifyReplacer, "safeStringifyReplacer");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  convertArrayToAsyncIterable,
  convertArrayToReadableStream,
  convertAsyncIterableToArray,
  convertReadableStreamToArray,
  convertResponseStreamToArray,
  createAsyncIterableStream,
  deepClone,
  hasKey,
  isEmptyObject,
  isFunction,
  isNil,
  isObject,
  isPlainObject,
  safeStringify
});
//# sourceMappingURL=index.js.map