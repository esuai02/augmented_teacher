var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/utils/lang.ts
function isNil(obj) {
  return obj === null || obj === void 0;
}
__name(isNil, "isNil");
function isObject(obj) {
  return (typeof obj === "object" || typeof obj === "function") && !isNil(obj);
}
__name(isObject, "isObject");
function isFunction(obj) {
  return typeof obj === "function";
}
__name(isFunction, "isFunction");
function isPlainObject(obj) {
  if (!isObject(obj)) {
    return false;
  }
  const prototype = Object.getPrototypeOf(obj);
  return prototype === Object.prototype || prototype === null;
}
__name(isPlainObject, "isPlainObject");
function isEmptyObject(obj) {
  if (!isObject(obj)) {
    return false;
  }
  if (Object.getOwnPropertyNames(obj).length > 0 || Object.getOwnPropertySymbols(obj).length > 0) {
    return false;
  }
  return true;
}
__name(isEmptyObject, "isEmptyObject");

// src/utils/objects.ts
function deepClone(obj) {
  try {
    if (typeof structuredClone === "function") {
      return structuredClone(obj);
    }
    throw new Error("structuredClone is not available");
  } catch (_error) {
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    return { ...obj };
  }
}
__name(deepClone, "deepClone");
function hasKey(obj, key) {
  return isObject(obj) && key in obj;
}
__name(hasKey, "hasKey");

// src/utils/async-iterable-stream.ts
function createAsyncIterableStream(source) {
  const stream = source.pipeThrough(new TransformStream());
  stream[Symbol.asyncIterator] = () => {
    const reader = stream.getReader();
    return {
      async next() {
        const { done, value } = await reader.read();
        return done ? { done: true, value: void 0 } : { done: false, value };
      }
    };
  };
  return stream;
}
__name(createAsyncIterableStream, "createAsyncIterableStream");

// src/utils/safe-stringify.ts
function safeStringify(input, { indentation } = {}) {
  try {
    const seen = /* @__PURE__ */ new WeakSet();
    return JSON.stringify(input, safeStringifyReplacer(seen), indentation);
  } catch (error) {
    return `SAFE_STRINGIFY_ERROR: Error stringifying object: ${error instanceof Error ? error.message : "Unknown error"}`;
  }
}
__name(safeStringify, "safeStringify");
function safeStringifyReplacer(seen) {
  const replacer = /* @__PURE__ */ __name((_key, value) => {
    if (typeof value?.toJSON === "function") {
      value = value.toJSON();
    }
    if (!(value !== null && typeof value === "object")) {
      return value;
    }
    if (seen.has(value)) {
      return "[Circular]";
    }
    seen.add(value);
    const newValue = Array.isArray(value) ? [] : {};
    for (const [key2, value2] of Object.entries(value)) {
      newValue[key2] = replacer(key2, value2);
    }
    seen.delete(value);
    return newValue;
  }, "replacer");
  return replacer;
}
__name(safeStringifyReplacer, "safeStringifyReplacer");
export {
  createAsyncIterableStream,
  deepClone,
  hasKey,
  isEmptyObject,
  isFunction,
  isNil,
  isObject,
  isPlainObject,
  safeStringify
};
//# sourceMappingURL=index.mjs.map