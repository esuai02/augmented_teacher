var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/providers/pino.ts
import pino from "pino";

// src/formatters.ts
function getDefaultLogLevel() {
  const envLevel = process.env.VOLTAGENT_LOG_LEVEL || process.env.LOG_LEVEL;
  if (envLevel) {
    return envLevel.toLowerCase();
  }
  return process.env.NODE_ENV === "production" ? "error" : "info";
}
__name(getDefaultLogLevel, "getDefaultLogLevel");
function getDefaultLogFormat() {
  const envFormat = process.env.VOLTAGENT_LOG_FORMAT;
  if (envFormat === "json" || envFormat === "pretty") {
    return envFormat;
  }
  return process.env.NODE_ENV === "production" ? "json" : "pretty";
}
__name(getDefaultLogFormat, "getDefaultLogFormat");
function getDefaultRedactionPaths() {
  const defaultPaths = ["password", "token", "apiKey", "secret", "authorization", "cookie"];
  const envRedact = process.env.VOLTAGENT_LOG_REDACT;
  if (envRedact) {
    const customPaths = envRedact.split(",").map((p) => p.trim());
    return [.../* @__PURE__ */ new Set([...defaultPaths, ...customPaths])];
  }
  return defaultPaths;
}
__name(getDefaultRedactionPaths, "getDefaultRedactionPaths");

// src/providers/pino.ts
var PinoLoggerProvider = class {
  static {
    __name(this, "PinoLoggerProvider");
  }
  name = "pino";
  customPinoOptions;
  constructor(_bufferSize, _externalLogBuffer, pinoOptions) {
    this.customPinoOptions = pinoOptions;
  }
  createLogger(options) {
    const pinoOptions = this.createPinoOptions(options);
    const pinoInstance = pino(pinoOptions);
    return this.wrapPinoInstance(pinoInstance);
  }
  wrapPinoInstance(pinoInstance) {
    const logger = {
      trace: /* @__PURE__ */ __name((msg, context) => {
        pinoInstance.trace(context || {}, msg);
      }, "trace"),
      debug: /* @__PURE__ */ __name((msg, context) => {
        pinoInstance.debug(context || {}, msg);
      }, "debug"),
      info: /* @__PURE__ */ __name((msg, context) => {
        pinoInstance.info(context || {}, msg);
      }, "info"),
      warn: /* @__PURE__ */ __name((msg, context) => {
        pinoInstance.warn(context || {}, msg);
      }, "warn"),
      error: /* @__PURE__ */ __name((msg, context) => {
        pinoInstance.error(context || {}, msg);
      }, "error"),
      fatal: /* @__PURE__ */ __name((msg, context) => {
        pinoInstance.fatal(context || {}, msg);
      }, "fatal"),
      child: /* @__PURE__ */ __name((bindings) => {
        const childPino = pinoInstance.child(bindings);
        return this.wrapPinoInstance(childPino);
      }, "child")
    };
    logger._pinoInstance = pinoInstance;
    const loggerWithProvider = Object.assign(logger, {
      getProvider: /* @__PURE__ */ __name(() => this, "getProvider"),
      getBuffer: /* @__PURE__ */ __name(() => this.getLogBuffer(), "getBuffer")
    });
    return loggerWithProvider;
  }
  createChildLogger(parent, bindings, _options) {
    if (parent._pinoInstance) {
      const childPino = parent._pinoInstance.child(bindings);
      return this.wrapPinoInstance(childPino);
    }
    return parent.child(bindings);
  }
  getLogBuffer() {
    throw new Error(
      "Buffer management has been moved to @voltagent/core. Loggers no longer manage their own buffers."
    );
  }
  async flush() {
    return Promise.resolve();
  }
  async close() {
    return Promise.resolve();
  }
  /**
   * Create Pino-specific options from generic logger options
   */
  createPinoOptions(options = {}) {
    const format = options.format || getDefaultLogFormat();
    const pretty = options.pretty ?? process.env.NODE_ENV !== "production";
    const shouldUsePretty = format === "pretty" && pretty;
    const pinoOptions = {
      level: options.level || getDefaultLogLevel(),
      name: options.name,
      redact: {
        paths: options.redact || getDefaultRedactionPaths(),
        censor: "[REDACTED]"
      },
      serializers: {
        err: pino.stdSerializers.err,
        error: pino.stdSerializers.err,
        exception: pino.stdSerializers.err
      },
      formatters: {
        level: /* @__PURE__ */ __name((label) => {
          return { level: label.toUpperCase() };
        }, "level"),
        bindings: /* @__PURE__ */ __name((bindings) => {
          return {
            ...bindings,
            component: "VoltAgent",
            pid: bindings.pid,
            hostname: bindings.hostname
          };
        }, "bindings")
      },
      timestamp: /* @__PURE__ */ __name(() => {
        const now = /* @__PURE__ */ new Date();
        return `,"timestamp":"${now.toISOString()}"`;
      }, "timestamp"),
      base: {
        env: process.env.NODE_ENV || "development"
      }
    };
    if (shouldUsePretty) {
      pinoOptions.transport = {
        target: "pino-pretty",
        options: {
          colorize: true,
          translateTime: "yyyy-MM-dd HH:mm:ss.l o",
          ignore: "pid,hostname,env,component",
          messageFormat: "{msg}{if userId} | user={userId}{end}{if conversationId} | conv={conversationId}{end}{if executionId} | exec={executionId}{end}",
          errorLikeObjectKeys: ["err", "error", "exception"],
          errorProps: "",
          singleLine: !["debug", "trace"].includes(options.level || getDefaultLogLevel()),
          messageKey: "msg"
        }
      };
    }
    const {
      format: _,
      pretty: __,
      redact: ___,
      bufferSize: ____,
      pinoOptions: _____,
      ...restOptions
    } = options;
    return {
      ...pinoOptions,
      ...restOptions,
      ...this.customPinoOptions
    };
  }
};

// src/base.ts
var globalLoggerProvider = null;
function getGlobalLoggerProvider() {
  if (!globalLoggerProvider) {
    globalLoggerProvider = new PinoLoggerProvider();
  }
  return globalLoggerProvider;
}
__name(getGlobalLoggerProvider, "getGlobalLoggerProvider");
function setGlobalLoggerProvider(provider) {
  globalLoggerProvider = provider;
}
__name(setGlobalLoggerProvider, "setGlobalLoggerProvider");
function getGlobalLogBuffer() {
  return getGlobalLoggerProvider().getLogBuffer();
}
__name(getGlobalLogBuffer, "getGlobalLogBuffer");
function createPinoLogger(options, _externalLogBuffer) {
  const provider = new PinoLoggerProvider(
    options?.bufferSize,
    void 0,
    // No longer using external buffer
    options?.pinoOptions
  );
  if (!globalLoggerProvider) {
    globalLoggerProvider = provider;
  }
  return provider.createLogger(options);
}
__name(createPinoLogger, "createPinoLogger");
function connectExternalLogBuffer(_logger, _externalBuffer) {
}
__name(connectExternalLogBuffer, "connectExternalLogBuffer");

// src/buffer.ts
var InMemoryLogBuffer = class {
  static {
    __name(this, "InMemoryLogBuffer");
  }
  buffer = [];
  maxSize;
  constructor(maxSize = 1e3) {
    this.maxSize = maxSize;
  }
  add(entry) {
    this.buffer.push(entry);
    if (this.buffer.length > this.maxSize) {
      this.buffer.shift();
    }
  }
  query(filter) {
    if (!filter) {
      return [...this.buffer];
    }
    let results = this.buffer;
    if (filter.level) {
      const levelPriority = this.getLevelPriority(filter.level);
      results = results.filter((entry) => this.getLevelPriority(entry.level) >= levelPriority);
    }
    if (filter.agentId) {
      results = results.filter((entry) => entry.agentId === filter.agentId);
    }
    if (filter.conversationId) {
      results = results.filter((entry) => entry.conversationId === filter.conversationId);
    }
    if (filter.workflowId) {
      results = results.filter((entry) => entry.workflowId === filter.workflowId);
    }
    if (filter.executionId) {
      results = results.filter(
        (entry) => entry.executionId === filter.executionId || entry.parentExecutionId === filter.executionId
      );
    }
    if (filter.since || filter.until) {
      results = results.filter((entry) => {
        const entryTime = new Date(entry.timestamp);
        if (filter.since && entryTime < filter.since) return false;
        if (filter.until && entryTime > filter.until) return false;
        return true;
      });
    }
    if (filter.limit && filter.limit > 0) {
      results = results.slice(-filter.limit);
    }
    return [...results];
  }
  clear() {
    this.buffer = [];
  }
  size() {
    return this.buffer.length;
  }
  getLevelPriority(level) {
    const priorities = {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      fatal: 60
    };
    return priorities[level.toLowerCase()] || 0;
  }
};
export {
  InMemoryLogBuffer,
  PinoLoggerProvider,
  connectExternalLogBuffer,
  createPinoLogger,
  getDefaultLogFormat,
  getDefaultLogLevel,
  getDefaultRedactionPaths,
  getGlobalLogBuffer,
  getGlobalLoggerProvider,
  setGlobalLoggerProvider
};
//# sourceMappingURL=index.mjs.map